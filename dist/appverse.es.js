function iu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Yd = { exports: {} }, Rs = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MS;
function SC() {
  if (MS) return Rs;
  MS = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function a(i, o, l) {
    var c = null;
    if (l !== void 0 && (c = "" + l), o.key !== void 0 && (c = "" + o.key), "key" in o) {
      l = {};
      for (var d in o)
        d !== "key" && (l[d] = o[d]);
    } else l = o;
    return o = l.ref, {
      $$typeof: e,
      type: i,
      key: c,
      ref: o !== void 0 ? o : null,
      props: l
    };
  }
  return Rs.Fragment = t, Rs.jsx = a, Rs.jsxs = a, Rs;
}
var US;
function _C() {
  return US || (US = 1, Yd.exports = SC()), Yd.exports;
}
var B = _C(), Vd = { exports: {} }, vs = {}, Wd = { exports: {} }, Xd = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BS;
function AC() {
  return BS || (BS = 1, (function(e) {
    function t(j, se) {
      var Ee = j.length;
      j.push(se);
      e: for (; 0 < Ee; ) {
        var Ne = Ee - 1 >>> 1, O = j[Ne];
        if (0 < o(O, se))
          j[Ne] = se, j[Ee] = O, Ee = Ne;
        else break e;
      }
    }
    function a(j) {
      return j.length === 0 ? null : j[0];
    }
    function i(j) {
      if (j.length === 0) return null;
      var se = j[0], Ee = j.pop();
      if (Ee !== se) {
        j[0] = Ee;
        e: for (var Ne = 0, O = j.length, F = O >>> 1; Ne < F; ) {
          var te = 2 * (Ne + 1) - 1, v = j[te], he = te + 1, ye = j[he];
          if (0 > o(v, Ee))
            he < O && 0 > o(ye, v) ? (j[Ne] = ye, j[he] = Ee, Ne = he) : (j[Ne] = v, j[te] = Ee, Ne = te);
          else if (he < O && 0 > o(ye, Ee))
            j[Ne] = ye, j[he] = Ee, Ne = he;
          else break e;
        }
      }
      return se;
    }
    function o(j, se) {
      var Ee = j.sortIndex - se.sortIndex;
      return Ee !== 0 ? Ee : j.id - se.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var l = performance;
      e.unstable_now = function() {
        return l.now();
      };
    } else {
      var c = Date, d = c.now();
      e.unstable_now = function() {
        return c.now() - d;
      };
    }
    var m = [], f = [], b = 1, E = null, T = 3, S = !1, _ = !1, k = !1, R = !1, C = typeof setTimeout == "function" ? setTimeout : null, L = typeof clearTimeout == "function" ? clearTimeout : null, x = typeof setImmediate < "u" ? setImmediate : null;
    function Y(j) {
      for (var se = a(f); se !== null; ) {
        if (se.callback === null) i(f);
        else if (se.startTime <= j)
          i(f), se.sortIndex = se.expirationTime, t(m, se);
        else break;
        se = a(f);
      }
    }
    function q(j) {
      if (k = !1, Y(j), !_)
        if (a(m) !== null)
          _ = !0, D || (D = !0, ae());
        else {
          var se = a(f);
          se !== null && ce(q, se.startTime - j);
        }
    }
    var D = !1, G = -1, K = 5, Q = -1;
    function U() {
      return R ? !0 : !(e.unstable_now() - Q < K);
    }
    function ee() {
      if (R = !1, D) {
        var j = e.unstable_now();
        Q = j;
        var se = !0;
        try {
          e: {
            _ = !1, k && (k = !1, L(G), G = -1), S = !0;
            var Ee = T;
            try {
              t: {
                for (Y(j), E = a(m); E !== null && !(E.expirationTime > j && U()); ) {
                  var Ne = E.callback;
                  if (typeof Ne == "function") {
                    E.callback = null, T = E.priorityLevel;
                    var O = Ne(
                      E.expirationTime <= j
                    );
                    if (j = e.unstable_now(), typeof O == "function") {
                      E.callback = O, Y(j), se = !0;
                      break t;
                    }
                    E === a(m) && i(m), Y(j);
                  } else i(m);
                  E = a(m);
                }
                if (E !== null) se = !0;
                else {
                  var F = a(f);
                  F !== null && ce(
                    q,
                    F.startTime - j
                  ), se = !1;
                }
              }
              break e;
            } finally {
              E = null, T = Ee, S = !1;
            }
            se = void 0;
          }
        } finally {
          se ? ae() : D = !1;
        }
      }
    }
    var ae;
    if (typeof x == "function")
      ae = function() {
        x(ee);
      };
    else if (typeof MessageChannel < "u") {
      var ue = new MessageChannel(), de = ue.port2;
      ue.port1.onmessage = ee, ae = function() {
        de.postMessage(null);
      };
    } else
      ae = function() {
        C(ee, 0);
      };
    function ce(j, se) {
      G = C(function() {
        j(e.unstable_now());
      }, se);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(j) {
      j.callback = null;
    }, e.unstable_forceFrameRate = function(j) {
      0 > j || 125 < j ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : K = 0 < j ? Math.floor(1e3 / j) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return T;
    }, e.unstable_next = function(j) {
      switch (T) {
        case 1:
        case 2:
        case 3:
          var se = 3;
          break;
        default:
          se = T;
      }
      var Ee = T;
      T = se;
      try {
        return j();
      } finally {
        T = Ee;
      }
    }, e.unstable_requestPaint = function() {
      R = !0;
    }, e.unstable_runWithPriority = function(j, se) {
      switch (j) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          j = 3;
      }
      var Ee = T;
      T = j;
      try {
        return se();
      } finally {
        T = Ee;
      }
    }, e.unstable_scheduleCallback = function(j, se, Ee) {
      var Ne = e.unstable_now();
      switch (typeof Ee == "object" && Ee !== null ? (Ee = Ee.delay, Ee = typeof Ee == "number" && 0 < Ee ? Ne + Ee : Ne) : Ee = Ne, j) {
        case 1:
          var O = -1;
          break;
        case 2:
          O = 250;
          break;
        case 5:
          O = 1073741823;
          break;
        case 4:
          O = 1e4;
          break;
        default:
          O = 5e3;
      }
      return O = Ee + O, j = {
        id: b++,
        callback: se,
        priorityLevel: j,
        startTime: Ee,
        expirationTime: O,
        sortIndex: -1
      }, Ee > Ne ? (j.sortIndex = Ee, t(f, j), a(m) === null && j === a(f) && (k ? (L(G), G = -1) : k = !0, ce(q, Ee - Ne))) : (j.sortIndex = O, t(m, j), _ || S || (_ = !0, D || (D = !0, ae()))), j;
    }, e.unstable_shouldYield = U, e.unstable_wrapCallback = function(j) {
      var se = T;
      return function() {
        var Ee = T;
        T = se;
        try {
          return j.apply(this, arguments);
        } finally {
          T = Ee;
        }
      };
    };
  })(Xd)), Xd;
}
var FS;
function NC() {
  return FS || (FS = 1, Wd.exports = AC()), Wd.exports;
}
var Kd = { exports: {} }, ke = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PS;
function RC() {
  if (PS) return ke;
  PS = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), l = Symbol.for("react.consumer"), c = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), b = Symbol.for("react.lazy"), E = Symbol.for("react.activity"), T = Symbol.iterator;
  function S(F) {
    return F === null || typeof F != "object" ? null : (F = T && F[T] || F["@@iterator"], typeof F == "function" ? F : null);
  }
  var _ = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, k = Object.assign, R = {};
  function C(F, te, v) {
    this.props = F, this.context = te, this.refs = R, this.updater = v || _;
  }
  C.prototype.isReactComponent = {}, C.prototype.setState = function(F, te) {
    if (typeof F != "object" && typeof F != "function" && F != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, F, te, "setState");
  }, C.prototype.forceUpdate = function(F) {
    this.updater.enqueueForceUpdate(this, F, "forceUpdate");
  };
  function L() {
  }
  L.prototype = C.prototype;
  function x(F, te, v) {
    this.props = F, this.context = te, this.refs = R, this.updater = v || _;
  }
  var Y = x.prototype = new L();
  Y.constructor = x, k(Y, C.prototype), Y.isPureReactComponent = !0;
  var q = Array.isArray;
  function D() {
  }
  var G = { H: null, A: null, T: null, S: null }, K = Object.prototype.hasOwnProperty;
  function Q(F, te, v) {
    var he = v.ref;
    return {
      $$typeof: e,
      type: F,
      key: te,
      ref: he !== void 0 ? he : null,
      props: v
    };
  }
  function U(F, te) {
    return Q(F.type, te, F.props);
  }
  function ee(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function ae(F) {
    var te = { "=": "=0", ":": "=2" };
    return "$" + F.replace(/[=:]/g, function(v) {
      return te[v];
    });
  }
  var ue = /\/+/g;
  function de(F, te) {
    return typeof F == "object" && F !== null && F.key != null ? ae("" + F.key) : te.toString(36);
  }
  function ce(F) {
    switch (F.status) {
      case "fulfilled":
        return F.value;
      case "rejected":
        throw F.reason;
      default:
        switch (typeof F.status == "string" ? F.then(D, D) : (F.status = "pending", F.then(
          function(te) {
            F.status === "pending" && (F.status = "fulfilled", F.value = te);
          },
          function(te) {
            F.status === "pending" && (F.status = "rejected", F.reason = te);
          }
        )), F.status) {
          case "fulfilled":
            return F.value;
          case "rejected":
            throw F.reason;
        }
    }
    throw F;
  }
  function j(F, te, v, he, ye) {
    var _e = typeof F;
    (_e === "undefined" || _e === "boolean") && (F = null);
    var Le = !1;
    if (F === null) Le = !0;
    else
      switch (_e) {
        case "bigint":
        case "string":
        case "number":
          Le = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case e:
            case t:
              Le = !0;
              break;
            case b:
              return Le = F._init, j(
                Le(F._payload),
                te,
                v,
                he,
                ye
              );
          }
      }
    if (Le)
      return ye = ye(F), Le = he === "" ? "." + de(F, 0) : he, q(ye) ? (v = "", Le != null && (v = Le.replace(ue, "$&/") + "/"), j(ye, te, v, "", function(jt) {
        return jt;
      })) : ye != null && (ee(ye) && (ye = U(
        ye,
        v + (ye.key == null || F && F.key === ye.key ? "" : ("" + ye.key).replace(
          ue,
          "$&/"
        ) + "/") + Le
      )), te.push(ye)), 1;
    Le = 0;
    var Ze = he === "" ? "." : he + ":";
    if (q(F))
      for (var Ve = 0; Ve < F.length; Ve++)
        he = F[Ve], _e = Ze + de(he, Ve), Le += j(
          he,
          te,
          v,
          _e,
          ye
        );
    else if (Ve = S(F), typeof Ve == "function")
      for (F = Ve.call(F), Ve = 0; !(he = F.next()).done; )
        he = he.value, _e = Ze + de(he, Ve++), Le += j(
          he,
          te,
          v,
          _e,
          ye
        );
    else if (_e === "object") {
      if (typeof F.then == "function")
        return j(
          ce(F),
          te,
          v,
          he,
          ye
        );
      throw te = String(F), Error(
        "Objects are not valid as a React child (found: " + (te === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : te) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Le;
  }
  function se(F, te, v) {
    if (F == null) return F;
    var he = [], ye = 0;
    return j(F, he, "", "", function(_e) {
      return te.call(v, _e, ye++);
    }), he;
  }
  function Ee(F) {
    if (F._status === -1) {
      var te = F._result;
      te = te(), te.then(
        function(v) {
          (F._status === 0 || F._status === -1) && (F._status = 1, F._result = v);
        },
        function(v) {
          (F._status === 0 || F._status === -1) && (F._status = 2, F._result = v);
        }
      ), F._status === -1 && (F._status = 0, F._result = te);
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var Ne = typeof reportError == "function" ? reportError : function(F) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var te = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof F == "object" && F !== null && typeof F.message == "string" ? String(F.message) : String(F),
        error: F
      });
      if (!window.dispatchEvent(te)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", F);
      return;
    }
    console.error(F);
  }, O = {
    map: se,
    forEach: function(F, te, v) {
      se(
        F,
        function() {
          te.apply(this, arguments);
        },
        v
      );
    },
    count: function(F) {
      var te = 0;
      return se(F, function() {
        te++;
      }), te;
    },
    toArray: function(F) {
      return se(F, function(te) {
        return te;
      }) || [];
    },
    only: function(F) {
      if (!ee(F))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return F;
    }
  };
  return ke.Activity = E, ke.Children = O, ke.Component = C, ke.Fragment = a, ke.Profiler = o, ke.PureComponent = x, ke.StrictMode = i, ke.Suspense = m, ke.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = G, ke.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(F) {
      return G.H.useMemoCache(F);
    }
  }, ke.cache = function(F) {
    return function() {
      return F.apply(null, arguments);
    };
  }, ke.cacheSignal = function() {
    return null;
  }, ke.cloneElement = function(F, te, v) {
    if (F == null)
      throw Error(
        "The argument must be a React element, but you passed " + F + "."
      );
    var he = k({}, F.props), ye = F.key;
    if (te != null)
      for (_e in te.key !== void 0 && (ye = "" + te.key), te)
        !K.call(te, _e) || _e === "key" || _e === "__self" || _e === "__source" || _e === "ref" && te.ref === void 0 || (he[_e] = te[_e]);
    var _e = arguments.length - 2;
    if (_e === 1) he.children = v;
    else if (1 < _e) {
      for (var Le = Array(_e), Ze = 0; Ze < _e; Ze++)
        Le[Ze] = arguments[Ze + 2];
      he.children = Le;
    }
    return Q(F.type, ye, he);
  }, ke.createContext = function(F) {
    return F = {
      $$typeof: c,
      _currentValue: F,
      _currentValue2: F,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, F.Provider = F, F.Consumer = {
      $$typeof: l,
      _context: F
    }, F;
  }, ke.createElement = function(F, te, v) {
    var he, ye = {}, _e = null;
    if (te != null)
      for (he in te.key !== void 0 && (_e = "" + te.key), te)
        K.call(te, he) && he !== "key" && he !== "__self" && he !== "__source" && (ye[he] = te[he]);
    var Le = arguments.length - 2;
    if (Le === 1) ye.children = v;
    else if (1 < Le) {
      for (var Ze = Array(Le), Ve = 0; Ve < Le; Ve++)
        Ze[Ve] = arguments[Ve + 2];
      ye.children = Ze;
    }
    if (F && F.defaultProps)
      for (he in Le = F.defaultProps, Le)
        ye[he] === void 0 && (ye[he] = Le[he]);
    return Q(F, _e, ye);
  }, ke.createRef = function() {
    return { current: null };
  }, ke.forwardRef = function(F) {
    return { $$typeof: d, render: F };
  }, ke.isValidElement = ee, ke.lazy = function(F) {
    return {
      $$typeof: b,
      _payload: { _status: -1, _result: F },
      _init: Ee
    };
  }, ke.memo = function(F, te) {
    return {
      $$typeof: f,
      type: F,
      compare: te === void 0 ? null : te
    };
  }, ke.startTransition = function(F) {
    var te = G.T, v = {};
    G.T = v;
    try {
      var he = F(), ye = G.S;
      ye !== null && ye(v, he), typeof he == "object" && he !== null && typeof he.then == "function" && he.then(D, Ne);
    } catch (_e) {
      Ne(_e);
    } finally {
      te !== null && v.types !== null && (te.types = v.types), G.T = te;
    }
  }, ke.unstable_useCacheRefresh = function() {
    return G.H.useCacheRefresh();
  }, ke.use = function(F) {
    return G.H.use(F);
  }, ke.useActionState = function(F, te, v) {
    return G.H.useActionState(F, te, v);
  }, ke.useCallback = function(F, te) {
    return G.H.useCallback(F, te);
  }, ke.useContext = function(F) {
    return G.H.useContext(F);
  }, ke.useDebugValue = function() {
  }, ke.useDeferredValue = function(F, te) {
    return G.H.useDeferredValue(F, te);
  }, ke.useEffect = function(F, te) {
    return G.H.useEffect(F, te);
  }, ke.useEffectEvent = function(F) {
    return G.H.useEffectEvent(F);
  }, ke.useId = function() {
    return G.H.useId();
  }, ke.useImperativeHandle = function(F, te, v) {
    return G.H.useImperativeHandle(F, te, v);
  }, ke.useInsertionEffect = function(F, te) {
    return G.H.useInsertionEffect(F, te);
  }, ke.useLayoutEffect = function(F, te) {
    return G.H.useLayoutEffect(F, te);
  }, ke.useMemo = function(F, te) {
    return G.H.useMemo(F, te);
  }, ke.useOptimistic = function(F, te) {
    return G.H.useOptimistic(F, te);
  }, ke.useReducer = function(F, te, v) {
    return G.H.useReducer(F, te, v);
  }, ke.useRef = function(F) {
    return G.H.useRef(F);
  }, ke.useState = function(F) {
    return G.H.useState(F);
  }, ke.useSyncExternalStore = function(F, te, v) {
    return G.H.useSyncExternalStore(
      F,
      te,
      v
    );
  }, ke.useTransition = function() {
    return G.H.useTransition();
  }, ke.version = "19.2.3", ke;
}
var HS;
function uf() {
  return HS || (HS = 1, Kd.exports = RC()), Kd.exports;
}
var Zd = { exports: {} }, Lt = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zS;
function vC() {
  if (zS) return Lt;
  zS = 1;
  var e = uf();
  function t(m) {
    var f = "https://react.dev/errors/" + m;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var b = 2; b < arguments.length; b++)
        f += "&args[]=" + encodeURIComponent(arguments[b]);
    }
    return "Minified React error #" + m + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a() {
  }
  var i = {
    d: {
      f: a,
      r: function() {
        throw Error(t(522));
      },
      D: a,
      C: a,
      L: a,
      m: a,
      X: a,
      S: a,
      M: a
    },
    p: 0,
    findDOMNode: null
  }, o = Symbol.for("react.portal");
  function l(m, f, b) {
    var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: o,
      key: E == null ? null : "" + E,
      children: m,
      containerInfo: f,
      implementation: b
    };
  }
  var c = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function d(m, f) {
    if (m === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return Lt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Lt.createPortal = function(m, f) {
    var b = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return l(m, f, null, b);
  }, Lt.flushSync = function(m) {
    var f = c.T, b = i.p;
    try {
      if (c.T = null, i.p = 2, m) return m();
    } finally {
      c.T = f, i.p = b, i.d.f();
    }
  }, Lt.preconnect = function(m, f) {
    typeof m == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, i.d.C(m, f));
  }, Lt.prefetchDNS = function(m) {
    typeof m == "string" && i.d.D(m);
  }, Lt.preinit = function(m, f) {
    if (typeof m == "string" && f && typeof f.as == "string") {
      var b = f.as, E = d(b, f.crossOrigin), T = typeof f.integrity == "string" ? f.integrity : void 0, S = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      b === "style" ? i.d.S(
        m,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: E,
          integrity: T,
          fetchPriority: S
        }
      ) : b === "script" && i.d.X(m, {
        crossOrigin: E,
        integrity: T,
        fetchPriority: S,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, Lt.preinitModule = function(m, f) {
    if (typeof m == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var b = d(
            f.as,
            f.crossOrigin
          );
          i.d.M(m, {
            crossOrigin: b,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && i.d.M(m);
  }, Lt.preload = function(m, f) {
    if (typeof m == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var b = f.as, E = d(b, f.crossOrigin);
      i.d.L(m, b, {
        crossOrigin: E,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, Lt.preloadModule = function(m, f) {
    if (typeof m == "string")
      if (f) {
        var b = d(f.as, f.crossOrigin);
        i.d.m(m, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: b,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else i.d.m(m);
  }, Lt.requestFormReset = function(m) {
    i.d.r(m);
  }, Lt.unstable_batchedUpdates = function(m, f) {
    return m(f);
  }, Lt.useFormState = function(m, f, b) {
    return c.H.useFormState(m, f, b);
  }, Lt.useFormStatus = function() {
    return c.H.useHostTransitionStatus();
  }, Lt.version = "19.2.3", Lt;
}
var GS;
function CC() {
  if (GS) return Zd.exports;
  GS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Zd.exports = vC(), Zd.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jS;
function wC() {
  if (jS) return vs;
  jS = 1;
  var e = NC(), t = uf(), a = CC();
  function i(n) {
    var r = "https://react.dev/errors/" + n;
    if (1 < arguments.length) {
      r += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var s = 2; s < arguments.length; s++)
        r += "&args[]=" + encodeURIComponent(arguments[s]);
    }
    return "Minified React error #" + n + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function o(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
  }
  function l(n) {
    var r = n, s = n;
    if (n.alternate) for (; r.return; ) r = r.return;
    else {
      n = r;
      do
        r = n, (r.flags & 4098) !== 0 && (s = r.return), n = r.return;
      while (n);
    }
    return r.tag === 3 ? s : null;
  }
  function c(n) {
    if (n.tag === 13) {
      var r = n.memoizedState;
      if (r === null && (n = n.alternate, n !== null && (r = n.memoizedState)), r !== null) return r.dehydrated;
    }
    return null;
  }
  function d(n) {
    if (n.tag === 31) {
      var r = n.memoizedState;
      if (r === null && (n = n.alternate, n !== null && (r = n.memoizedState)), r !== null) return r.dehydrated;
    }
    return null;
  }
  function m(n) {
    if (l(n) !== n)
      throw Error(i(188));
  }
  function f(n) {
    var r = n.alternate;
    if (!r) {
      if (r = l(n), r === null) throw Error(i(188));
      return r !== n ? null : n;
    }
    for (var s = n, u = r; ; ) {
      var p = s.return;
      if (p === null) break;
      var g = p.alternate;
      if (g === null) {
        if (u = p.return, u !== null) {
          s = u;
          continue;
        }
        break;
      }
      if (p.child === g.child) {
        for (g = p.child; g; ) {
          if (g === s) return m(p), n;
          if (g === u) return m(p), r;
          g = g.sibling;
        }
        throw Error(i(188));
      }
      if (s.return !== u.return) s = p, u = g;
      else {
        for (var y = !1, A = p.child; A; ) {
          if (A === s) {
            y = !0, s = p, u = g;
            break;
          }
          if (A === u) {
            y = !0, u = p, s = g;
            break;
          }
          A = A.sibling;
        }
        if (!y) {
          for (A = g.child; A; ) {
            if (A === s) {
              y = !0, s = g, u = p;
              break;
            }
            if (A === u) {
              y = !0, u = g, s = p;
              break;
            }
            A = A.sibling;
          }
          if (!y) throw Error(i(189));
        }
      }
      if (s.alternate !== u) throw Error(i(190));
    }
    if (s.tag !== 3) throw Error(i(188));
    return s.stateNode.current === s ? n : r;
  }
  function b(n) {
    var r = n.tag;
    if (r === 5 || r === 26 || r === 27 || r === 6) return n;
    for (n = n.child; n !== null; ) {
      if (r = b(n), r !== null) return r;
      n = n.sibling;
    }
    return null;
  }
  var E = Object.assign, T = Symbol.for("react.element"), S = Symbol.for("react.transitional.element"), _ = Symbol.for("react.portal"), k = Symbol.for("react.fragment"), R = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), L = Symbol.for("react.consumer"), x = Symbol.for("react.context"), Y = Symbol.for("react.forward_ref"), q = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), G = Symbol.for("react.memo"), K = Symbol.for("react.lazy"), Q = Symbol.for("react.activity"), U = Symbol.for("react.memo_cache_sentinel"), ee = Symbol.iterator;
  function ae(n) {
    return n === null || typeof n != "object" ? null : (n = ee && n[ee] || n["@@iterator"], typeof n == "function" ? n : null);
  }
  var ue = Symbol.for("react.client.reference");
  function de(n) {
    if (n == null) return null;
    if (typeof n == "function")
      return n.$$typeof === ue ? null : n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
      case k:
        return "Fragment";
      case C:
        return "Profiler";
      case R:
        return "StrictMode";
      case q:
        return "Suspense";
      case D:
        return "SuspenseList";
      case Q:
        return "Activity";
    }
    if (typeof n == "object")
      switch (n.$$typeof) {
        case _:
          return "Portal";
        case x:
          return n.displayName || "Context";
        case L:
          return (n._context.displayName || "Context") + ".Consumer";
        case Y:
          var r = n.render;
          return n = n.displayName, n || (n = r.displayName || r.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case G:
          return r = n.displayName || null, r !== null ? r : de(n.type) || "Memo";
        case K:
          r = n._payload, n = n._init;
          try {
            return de(n(r));
          } catch {
          }
      }
    return null;
  }
  var ce = Array.isArray, j = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, se = a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ee = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Ne = [], O = -1;
  function F(n) {
    return { current: n };
  }
  function te(n) {
    0 > O || (n.current = Ne[O], Ne[O] = null, O--);
  }
  function v(n, r) {
    O++, Ne[O] = n.current, n.current = r;
  }
  var he = F(null), ye = F(null), _e = F(null), Le = F(null);
  function Ze(n, r) {
    switch (v(_e, r), v(ye, n), v(he, null), r.nodeType) {
      case 9:
      case 11:
        n = (n = r.documentElement) && (n = n.namespaceURI) ? rS(n) : 0;
        break;
      default:
        if (n = r.tagName, r = r.namespaceURI)
          r = rS(r), n = iS(r, n);
        else
          switch (n) {
            case "svg":
              n = 1;
              break;
            case "math":
              n = 2;
              break;
            default:
              n = 0;
          }
    }
    te(he), v(he, n);
  }
  function Ve() {
    te(he), te(ye), te(_e);
  }
  function jt(n) {
    n.memoizedState !== null && v(Le, n);
    var r = he.current, s = iS(r, n.type);
    r !== s && (v(ye, n), v(he, s));
  }
  function vn(n) {
    ye.current === n && (te(he), te(ye)), Le.current === n && (te(Le), Ss._currentValue = Ee);
  }
  var xi, bo;
  function $n(n) {
    if (xi === void 0)
      try {
        throw Error();
      } catch (s) {
        var r = s.stack.trim().match(/\n( *(at )?)/);
        xi = r && r[1] || "", bo = -1 < s.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < s.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + xi + n + bo;
  }
  var _r = !1;
  function Ar(n, r) {
    if (!n || _r) return "";
    _r = !0;
    var s = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var u = {
        DetermineComponentFrameRoot: function() {
          try {
            if (r) {
              var le = function() {
                throw Error();
              };
              if (Object.defineProperty(le.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(le, []);
                } catch (J) {
                  var Z = J;
                }
                Reflect.construct(n, [], le);
              } else {
                try {
                  le.call();
                } catch (J) {
                  Z = J;
                }
                n.call(le.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (J) {
                Z = J;
              }
              (le = n()) && typeof le.catch == "function" && le.catch(function() {
              });
            }
          } catch (J) {
            if (J && Z && typeof J.stack == "string")
              return [J.stack, Z.stack];
          }
          return [null, null];
        }
      };
      u.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var p = Object.getOwnPropertyDescriptor(
        u.DetermineComponentFrameRoot,
        "name"
      );
      p && p.configurable && Object.defineProperty(
        u.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var g = u.DetermineComponentFrameRoot(), y = g[0], A = g[1];
      if (y && A) {
        var P = y.split(`
`), X = A.split(`
`);
        for (p = u = 0; u < P.length && !P[u].includes("DetermineComponentFrameRoot"); )
          u++;
        for (; p < X.length && !X[p].includes(
          "DetermineComponentFrameRoot"
        ); )
          p++;
        if (u === P.length || p === X.length)
          for (u = P.length - 1, p = X.length - 1; 1 <= u && 0 <= p && P[u] !== X[p]; )
            p--;
        for (; 1 <= u && 0 <= p; u--, p--)
          if (P[u] !== X[p]) {
            if (u !== 1 || p !== 1)
              do
                if (u--, p--, 0 > p || P[u] !== X[p]) {
                  var re = `
` + P[u].replace(" at new ", " at ");
                  return n.displayName && re.includes("<anonymous>") && (re = re.replace("<anonymous>", n.displayName)), re;
                }
              while (1 <= u && 0 <= p);
            break;
          }
      }
    } finally {
      _r = !1, Error.prepareStackTrace = s;
    }
    return (s = n ? n.displayName || n.name : "") ? $n(s) : "";
  }
  function Eo(n, r) {
    switch (n.tag) {
      case 26:
      case 27:
      case 5:
        return $n(n.type);
      case 16:
        return $n("Lazy");
      case 13:
        return n.child !== r && r !== null ? $n("Suspense Fallback") : $n("Suspense");
      case 19:
        return $n("SuspenseList");
      case 0:
      case 15:
        return Ar(n.type, !1);
      case 11:
        return Ar(n.type.render, !1);
      case 1:
        return Ar(n.type, !0);
      case 31:
        return $n("Activity");
      default:
        return "";
    }
  }
  function yo(n) {
    try {
      var r = "", s = null;
      do
        r += Eo(n, s), s = n, n = n.return;
      while (n);
      return r;
    } catch (u) {
      return `
Error generating stack: ` + u.message + `
` + u.stack;
    }
  }
  var Nr = Object.prototype.hasOwnProperty, Rr = e.unstable_scheduleCallback, Li = e.unstable_cancelCallback, Ou = e.unstable_shouldYield, xu = e.unstable_requestPaint, Pt = e.unstable_now, Lu = e.unstable_getCurrentPriorityLevel, ie = e.unstable_ImmediatePriority, be = e.unstable_UserBlockingPriority, we = e.unstable_NormalPriority, Me = e.unstable_LowPriority, We = e.unstable_IdlePriority, nn = e.log, qn = e.unstable_setDisableYieldValue, Ht = null, Tt = null;
  function $t(n) {
    if (typeof nn == "function" && qn(n), Tt && typeof Tt.setStrictMode == "function")
      try {
        Tt.setStrictMode(Ht, n);
      } catch {
      }
  }
  var tt = Math.clz32 ? Math.clz32 : oR, ma = Math.log, Cn = Math.LN2;
  function oR(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (ma(n) / Cn | 0) | 0;
  }
  var To = 256, So = 262144, _o = 4194304;
  function Va(n) {
    var r = n & 42;
    if (r !== 0) return r;
    switch (n & -n) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return n & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return n & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return n;
    }
  }
  function Ao(n, r, s) {
    var u = n.pendingLanes;
    if (u === 0) return 0;
    var p = 0, g = n.suspendedLanes, y = n.pingedLanes;
    n = n.warmLanes;
    var A = u & 134217727;
    return A !== 0 ? (u = A & ~g, u !== 0 ? p = Va(u) : (y &= A, y !== 0 ? p = Va(y) : s || (s = A & ~n, s !== 0 && (p = Va(s))))) : (A = u & ~g, A !== 0 ? p = Va(A) : y !== 0 ? p = Va(y) : s || (s = u & ~n, s !== 0 && (p = Va(s)))), p === 0 ? 0 : r !== 0 && r !== p && (r & g) === 0 && (g = p & -p, s = r & -r, g >= s || g === 32 && (s & 4194048) !== 0) ? r : p;
  }
  function Di(n, r) {
    return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & r) === 0;
  }
  function lR(n, r) {
    switch (n) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return r + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function PE() {
    var n = _o;
    return _o <<= 1, (_o & 62914560) === 0 && (_o = 4194304), n;
  }
  function Du(n) {
    for (var r = [], s = 0; 31 > s; s++) r.push(n);
    return r;
  }
  function Mi(n, r) {
    n.pendingLanes |= r, r !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0);
  }
  function uR(n, r, s, u, p, g) {
    var y = n.pendingLanes;
    n.pendingLanes = s, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= s, n.entangledLanes &= s, n.errorRecoveryDisabledLanes &= s, n.shellSuspendCounter = 0;
    var A = n.entanglements, P = n.expirationTimes, X = n.hiddenUpdates;
    for (s = y & ~s; 0 < s; ) {
      var re = 31 - tt(s), le = 1 << re;
      A[re] = 0, P[re] = -1;
      var Z = X[re];
      if (Z !== null)
        for (X[re] = null, re = 0; re < Z.length; re++) {
          var J = Z[re];
          J !== null && (J.lane &= -536870913);
        }
      s &= ~le;
    }
    u !== 0 && HE(n, u, 0), g !== 0 && p === 0 && n.tag !== 0 && (n.suspendedLanes |= g & ~(y & ~r));
  }
  function HE(n, r, s) {
    n.pendingLanes |= r, n.suspendedLanes &= ~r;
    var u = 31 - tt(r);
    n.entangledLanes |= r, n.entanglements[u] = n.entanglements[u] | 1073741824 | s & 261930;
  }
  function zE(n, r) {
    var s = n.entangledLanes |= r;
    for (n = n.entanglements; s; ) {
      var u = 31 - tt(s), p = 1 << u;
      p & r | n[u] & r && (n[u] |= r), s &= ~p;
    }
  }
  function GE(n, r) {
    var s = r & -r;
    return s = (s & 42) !== 0 ? 1 : Mu(s), (s & (n.suspendedLanes | r)) !== 0 ? 0 : s;
  }
  function Mu(n) {
    switch (n) {
      case 2:
        n = 1;
        break;
      case 8:
        n = 4;
        break;
      case 32:
        n = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        n = 128;
        break;
      case 268435456:
        n = 134217728;
        break;
      default:
        n = 0;
    }
    return n;
  }
  function Uu(n) {
    return n &= -n, 2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function jE() {
    var n = se.p;
    return n !== 0 ? n : (n = window.event, n === void 0 ? 32 : wS(n.type));
  }
  function $E(n, r) {
    var s = se.p;
    try {
      return se.p = n, r();
    } finally {
      se.p = s;
    }
  }
  var ga = Math.random().toString(36).slice(2), Ct = "__reactFiber$" + ga, qt = "__reactProps$" + ga, vr = "__reactContainer$" + ga, Bu = "__reactEvents$" + ga, cR = "__reactListeners$" + ga, dR = "__reactHandles$" + ga, qE = "__reactResources$" + ga, Ui = "__reactMarker$" + ga;
  function Fu(n) {
    delete n[Ct], delete n[qt], delete n[Bu], delete n[cR], delete n[dR];
  }
  function Cr(n) {
    var r = n[Ct];
    if (r) return r;
    for (var s = n.parentNode; s; ) {
      if (r = s[vr] || s[Ct]) {
        if (s = r.alternate, r.child !== null || s !== null && s.child !== null)
          for (n = pS(n); n !== null; ) {
            if (s = n[Ct]) return s;
            n = pS(n);
          }
        return r;
      }
      n = s, s = n.parentNode;
    }
    return null;
  }
  function wr(n) {
    if (n = n[Ct] || n[vr]) {
      var r = n.tag;
      if (r === 5 || r === 6 || r === 13 || r === 31 || r === 26 || r === 27 || r === 3)
        return n;
    }
    return null;
  }
  function Bi(n) {
    var r = n.tag;
    if (r === 5 || r === 26 || r === 27 || r === 6) return n.stateNode;
    throw Error(i(33));
  }
  function kr(n) {
    var r = n[qE];
    return r || (r = n[qE] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), r;
  }
  function _t(n) {
    n[Ui] = !0;
  }
  var YE = /* @__PURE__ */ new Set(), VE = {};
  function Wa(n, r) {
    Ir(n, r), Ir(n + "Capture", r);
  }
  function Ir(n, r) {
    for (VE[n] = r, n = 0; n < r.length; n++)
      YE.add(r[n]);
  }
  var pR = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), WE = {}, XE = {};
  function fR(n) {
    return Nr.call(XE, n) ? !0 : Nr.call(WE, n) ? !1 : pR.test(n) ? XE[n] = !0 : (WE[n] = !0, !1);
  }
  function No(n, r, s) {
    if (fR(r))
      if (s === null) n.removeAttribute(r);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
            n.removeAttribute(r);
            return;
          case "boolean":
            var u = r.toLowerCase().slice(0, 5);
            if (u !== "data-" && u !== "aria-") {
              n.removeAttribute(r);
              return;
            }
        }
        n.setAttribute(r, "" + s);
      }
  }
  function Ro(n, r, s) {
    if (s === null) n.removeAttribute(r);
    else {
      switch (typeof s) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(r);
          return;
      }
      n.setAttribute(r, "" + s);
    }
  }
  function Yn(n, r, s, u) {
    if (u === null) n.removeAttribute(s);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          n.removeAttribute(s);
          return;
      }
      n.setAttributeNS(r, s, "" + u);
    }
  }
  function fn(n) {
    switch (typeof n) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return n;
      case "object":
        return n;
      default:
        return "";
    }
  }
  function KE(n) {
    var r = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
  }
  function mR(n, r, s) {
    var u = Object.getOwnPropertyDescriptor(
      n.constructor.prototype,
      r
    );
    if (!n.hasOwnProperty(r) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var p = u.get, g = u.set;
      return Object.defineProperty(n, r, {
        configurable: !0,
        get: function() {
          return p.call(this);
        },
        set: function(y) {
          s = "" + y, g.call(this, y);
        }
      }), Object.defineProperty(n, r, {
        enumerable: u.enumerable
      }), {
        getValue: function() {
          return s;
        },
        setValue: function(y) {
          s = "" + y;
        },
        stopTracking: function() {
          n._valueTracker = null, delete n[r];
        }
      };
    }
  }
  function Pu(n) {
    if (!n._valueTracker) {
      var r = KE(n) ? "checked" : "value";
      n._valueTracker = mR(
        n,
        r,
        "" + n[r]
      );
    }
  }
  function ZE(n) {
    if (!n) return !1;
    var r = n._valueTracker;
    if (!r) return !0;
    var s = r.getValue(), u = "";
    return n && (u = KE(n) ? n.checked ? "true" : "false" : n.value), n = u, n !== s ? (r.setValue(n), !0) : !1;
  }
  function vo(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
    try {
      return n.activeElement || n.body;
    } catch {
      return n.body;
    }
  }
  var gR = /[\n"\\]/g;
  function mn(n) {
    return n.replace(
      gR,
      function(r) {
        return "\\" + r.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Hu(n, r, s, u, p, g, y, A) {
    n.name = "", y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" ? n.type = y : n.removeAttribute("type"), r != null ? y === "number" ? (r === 0 && n.value === "" || n.value != r) && (n.value = "" + fn(r)) : n.value !== "" + fn(r) && (n.value = "" + fn(r)) : y !== "submit" && y !== "reset" || n.removeAttribute("value"), r != null ? zu(n, y, fn(r)) : s != null ? zu(n, y, fn(s)) : u != null && n.removeAttribute("value"), p == null && g != null && (n.defaultChecked = !!g), p != null && (n.checked = p && typeof p != "function" && typeof p != "symbol"), A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" ? n.name = "" + fn(A) : n.removeAttribute("name");
  }
  function QE(n, r, s, u, p, g, y, A) {
    if (g != null && typeof g != "function" && typeof g != "symbol" && typeof g != "boolean" && (n.type = g), r != null || s != null) {
      if (!(g !== "submit" && g !== "reset" || r != null)) {
        Pu(n);
        return;
      }
      s = s != null ? "" + fn(s) : "", r = r != null ? "" + fn(r) : s, A || r === n.value || (n.value = r), n.defaultValue = r;
    }
    u = u ?? p, u = typeof u != "function" && typeof u != "symbol" && !!u, n.checked = A ? n.checked : !!u, n.defaultChecked = !!u, y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" && (n.name = y), Pu(n);
  }
  function zu(n, r, s) {
    r === "number" && vo(n.ownerDocument) === n || n.defaultValue === "" + s || (n.defaultValue = "" + s);
  }
  function Or(n, r, s, u) {
    if (n = n.options, r) {
      r = {};
      for (var p = 0; p < s.length; p++)
        r["$" + s[p]] = !0;
      for (s = 0; s < n.length; s++)
        p = r.hasOwnProperty("$" + n[s].value), n[s].selected !== p && (n[s].selected = p), p && u && (n[s].defaultSelected = !0);
    } else {
      for (s = "" + fn(s), r = null, p = 0; p < n.length; p++) {
        if (n[p].value === s) {
          n[p].selected = !0, u && (n[p].defaultSelected = !0);
          return;
        }
        r !== null || n[p].disabled || (r = n[p]);
      }
      r !== null && (r.selected = !0);
    }
  }
  function JE(n, r, s) {
    if (r != null && (r = "" + fn(r), r !== n.value && (n.value = r), s == null)) {
      n.defaultValue !== r && (n.defaultValue = r);
      return;
    }
    n.defaultValue = s != null ? "" + fn(s) : "";
  }
  function e0(n, r, s, u) {
    if (r == null) {
      if (u != null) {
        if (s != null) throw Error(i(92));
        if (ce(u)) {
          if (1 < u.length) throw Error(i(93));
          u = u[0];
        }
        s = u;
      }
      s == null && (s = ""), r = s;
    }
    s = fn(r), n.defaultValue = s, u = n.textContent, u === s && u !== "" && u !== null && (n.value = u), Pu(n);
  }
  function xr(n, r) {
    if (r) {
      var s = n.firstChild;
      if (s && s === n.lastChild && s.nodeType === 3) {
        s.nodeValue = r;
        return;
      }
    }
    n.textContent = r;
  }
  var hR = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function t0(n, r, s) {
    var u = r.indexOf("--") === 0;
    s == null || typeof s == "boolean" || s === "" ? u ? n.setProperty(r, "") : r === "float" ? n.cssFloat = "" : n[r] = "" : u ? n.setProperty(r, s) : typeof s != "number" || s === 0 || hR.has(r) ? r === "float" ? n.cssFloat = s : n[r] = ("" + s).trim() : n[r] = s + "px";
  }
  function n0(n, r, s) {
    if (r != null && typeof r != "object")
      throw Error(i(62));
    if (n = n.style, s != null) {
      for (var u in s)
        !s.hasOwnProperty(u) || r != null && r.hasOwnProperty(u) || (u.indexOf("--") === 0 ? n.setProperty(u, "") : u === "float" ? n.cssFloat = "" : n[u] = "");
      for (var p in r)
        u = r[p], r.hasOwnProperty(p) && s[p] !== u && t0(n, p, u);
    } else
      for (var g in r)
        r.hasOwnProperty(g) && t0(n, g, r[g]);
  }
  function Gu(n) {
    if (n.indexOf("-") === -1) return !1;
    switch (n) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var bR = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), ER = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Co(n) {
    return ER.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n;
  }
  function Vn() {
  }
  var ju = null;
  function $u(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
  }
  var Lr = null, Dr = null;
  function a0(n) {
    var r = wr(n);
    if (r && (n = r.stateNode)) {
      var s = n[qt] || null;
      e: switch (n = r.stateNode, r.type) {
        case "input":
          if (Hu(
            n,
            s.value,
            s.defaultValue,
            s.defaultValue,
            s.checked,
            s.defaultChecked,
            s.type,
            s.name
          ), r = s.name, s.type === "radio" && r != null) {
            for (s = n; s.parentNode; ) s = s.parentNode;
            for (s = s.querySelectorAll(
              'input[name="' + mn(
                "" + r
              ) + '"][type="radio"]'
            ), r = 0; r < s.length; r++) {
              var u = s[r];
              if (u !== n && u.form === n.form) {
                var p = u[qt] || null;
                if (!p) throw Error(i(90));
                Hu(
                  u,
                  p.value,
                  p.defaultValue,
                  p.defaultValue,
                  p.checked,
                  p.defaultChecked,
                  p.type,
                  p.name
                );
              }
            }
            for (r = 0; r < s.length; r++)
              u = s[r], u.form === n.form && ZE(u);
          }
          break e;
        case "textarea":
          JE(n, s.value, s.defaultValue);
          break e;
        case "select":
          r = s.value, r != null && Or(n, !!s.multiple, r, !1);
      }
    }
  }
  var qu = !1;
  function r0(n, r, s) {
    if (qu) return n(r, s);
    qu = !0;
    try {
      var u = n(r);
      return u;
    } finally {
      if (qu = !1, (Lr !== null || Dr !== null) && (ml(), Lr && (r = Lr, n = Dr, Dr = Lr = null, a0(r), n)))
        for (r = 0; r < n.length; r++) a0(n[r]);
    }
  }
  function Fi(n, r) {
    var s = n.stateNode;
    if (s === null) return null;
    var u = s[qt] || null;
    if (u === null) return null;
    s = u[r];
    e: switch (r) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (u = !u.disabled) || (n = n.type, u = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !u;
        break e;
      default:
        n = !1;
    }
    if (n) return null;
    if (s && typeof s != "function")
      throw Error(
        i(231, r, typeof s)
      );
    return s;
  }
  var Wn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Yu = !1;
  if (Wn)
    try {
      var Pi = {};
      Object.defineProperty(Pi, "passive", {
        get: function() {
          Yu = !0;
        }
      }), window.addEventListener("test", Pi, Pi), window.removeEventListener("test", Pi, Pi);
    } catch {
      Yu = !1;
    }
  var ha = null, Vu = null, wo = null;
  function i0() {
    if (wo) return wo;
    var n, r = Vu, s = r.length, u, p = "value" in ha ? ha.value : ha.textContent, g = p.length;
    for (n = 0; n < s && r[n] === p[n]; n++) ;
    var y = s - n;
    for (u = 1; u <= y && r[s - u] === p[g - u]; u++) ;
    return wo = p.slice(n, 1 < u ? 1 - u : void 0);
  }
  function ko(n) {
    var r = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && r === 13 && (n = 13)) : n = r, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
  }
  function Io() {
    return !0;
  }
  function s0() {
    return !1;
  }
  function Yt(n) {
    function r(s, u, p, g, y) {
      this._reactName = s, this._targetInst = p, this.type = u, this.nativeEvent = g, this.target = y, this.currentTarget = null;
      for (var A in n)
        n.hasOwnProperty(A) && (s = n[A], this[A] = s ? s(g) : g[A]);
      return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? Io : s0, this.isPropagationStopped = s0, this;
    }
    return E(r.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var s = this.nativeEvent;
        s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1), this.isDefaultPrevented = Io);
      },
      stopPropagation: function() {
        var s = this.nativeEvent;
        s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0), this.isPropagationStopped = Io);
      },
      persist: function() {
      },
      isPersistent: Io
    }), r;
  }
  var Xa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Oo = Yt(Xa), Hi = E({}, Xa, { view: 0, detail: 0 }), yR = Yt(Hi), Wu, Xu, zi, xo = E({}, Hi, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Zu,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
      return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
    },
    movementX: function(n) {
      return "movementX" in n ? n.movementX : (n !== zi && (zi && n.type === "mousemove" ? (Wu = n.screenX - zi.screenX, Xu = n.screenY - zi.screenY) : Xu = Wu = 0, zi = n), Wu);
    },
    movementY: function(n) {
      return "movementY" in n ? n.movementY : Xu;
    }
  }), o0 = Yt(xo), TR = E({}, xo, { dataTransfer: 0 }), SR = Yt(TR), _R = E({}, Hi, { relatedTarget: 0 }), Ku = Yt(_R), AR = E({}, Xa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), NR = Yt(AR), RR = E({}, Xa, {
    clipboardData: function(n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    }
  }), vR = Yt(RR), CR = E({}, Xa, { data: 0 }), l0 = Yt(CR), wR = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, kR = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, IR = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function OR(n) {
    var r = this.nativeEvent;
    return r.getModifierState ? r.getModifierState(n) : (n = IR[n]) ? !!r[n] : !1;
  }
  function Zu() {
    return OR;
  }
  var xR = E({}, Hi, {
    key: function(n) {
      if (n.key) {
        var r = wR[n.key] || n.key;
        if (r !== "Unidentified") return r;
      }
      return n.type === "keypress" ? (n = ko(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? kR[n.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Zu,
    charCode: function(n) {
      return n.type === "keypress" ? ko(n) : 0;
    },
    keyCode: function(n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function(n) {
      return n.type === "keypress" ? ko(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    }
  }), LR = Yt(xR), DR = E({}, xo, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), u0 = Yt(DR), MR = E({}, Hi, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Zu
  }), UR = Yt(MR), BR = E({}, Xa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), FR = Yt(BR), PR = E({}, xo, {
    deltaX: function(n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function(n) {
      return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), HR = Yt(PR), zR = E({}, Xa, {
    newState: 0,
    oldState: 0
  }), GR = Yt(zR), jR = [9, 13, 27, 32], Qu = Wn && "CompositionEvent" in window, Gi = null;
  Wn && "documentMode" in document && (Gi = document.documentMode);
  var $R = Wn && "TextEvent" in window && !Gi, c0 = Wn && (!Qu || Gi && 8 < Gi && 11 >= Gi), d0 = " ", p0 = !1;
  function f0(n, r) {
    switch (n) {
      case "keyup":
        return jR.indexOf(r.keyCode) !== -1;
      case "keydown":
        return r.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function m0(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
  }
  var Mr = !1;
  function qR(n, r) {
    switch (n) {
      case "compositionend":
        return m0(r);
      case "keypress":
        return r.which !== 32 ? null : (p0 = !0, d0);
      case "textInput":
        return n = r.data, n === d0 && p0 ? null : n;
      default:
        return null;
    }
  }
  function YR(n, r) {
    if (Mr)
      return n === "compositionend" || !Qu && f0(n, r) ? (n = i0(), wo = Vu = ha = null, Mr = !1, n) : null;
    switch (n) {
      case "paste":
        return null;
      case "keypress":
        if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
          if (r.char && 1 < r.char.length)
            return r.char;
          if (r.which) return String.fromCharCode(r.which);
        }
        return null;
      case "compositionend":
        return c0 && r.locale !== "ko" ? null : r.data;
      default:
        return null;
    }
  }
  var VR = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function g0(n) {
    var r = n && n.nodeName && n.nodeName.toLowerCase();
    return r === "input" ? !!VR[n.type] : r === "textarea";
  }
  function h0(n, r, s, u) {
    Lr ? Dr ? Dr.push(u) : Dr = [u] : Lr = u, r = Sl(r, "onChange"), 0 < r.length && (s = new Oo(
      "onChange",
      "change",
      null,
      s,
      u
    ), n.push({ event: s, listeners: r }));
  }
  var ji = null, $i = null;
  function WR(n) {
    QT(n, 0);
  }
  function Lo(n) {
    var r = Bi(n);
    if (ZE(r)) return n;
  }
  function b0(n, r) {
    if (n === "change") return r;
  }
  var E0 = !1;
  if (Wn) {
    var Ju;
    if (Wn) {
      var ec = "oninput" in document;
      if (!ec) {
        var y0 = document.createElement("div");
        y0.setAttribute("oninput", "return;"), ec = typeof y0.oninput == "function";
      }
      Ju = ec;
    } else Ju = !1;
    E0 = Ju && (!document.documentMode || 9 < document.documentMode);
  }
  function T0() {
    ji && (ji.detachEvent("onpropertychange", S0), $i = ji = null);
  }
  function S0(n) {
    if (n.propertyName === "value" && Lo($i)) {
      var r = [];
      h0(
        r,
        $i,
        n,
        $u(n)
      ), r0(WR, r);
    }
  }
  function XR(n, r, s) {
    n === "focusin" ? (T0(), ji = r, $i = s, ji.attachEvent("onpropertychange", S0)) : n === "focusout" && T0();
  }
  function KR(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
      return Lo($i);
  }
  function ZR(n, r) {
    if (n === "click") return Lo(r);
  }
  function QR(n, r) {
    if (n === "input" || n === "change")
      return Lo(r);
  }
  function JR(n, r) {
    return n === r && (n !== 0 || 1 / n === 1 / r) || n !== n && r !== r;
  }
  var an = typeof Object.is == "function" ? Object.is : JR;
  function qi(n, r) {
    if (an(n, r)) return !0;
    if (typeof n != "object" || n === null || typeof r != "object" || r === null)
      return !1;
    var s = Object.keys(n), u = Object.keys(r);
    if (s.length !== u.length) return !1;
    for (u = 0; u < s.length; u++) {
      var p = s[u];
      if (!Nr.call(r, p) || !an(n[p], r[p]))
        return !1;
    }
    return !0;
  }
  function _0(n) {
    for (; n && n.firstChild; ) n = n.firstChild;
    return n;
  }
  function A0(n, r) {
    var s = _0(n);
    n = 0;
    for (var u; s; ) {
      if (s.nodeType === 3) {
        if (u = n + s.textContent.length, n <= r && u >= r)
          return { node: s, offset: r - n };
        n = u;
      }
      e: {
        for (; s; ) {
          if (s.nextSibling) {
            s = s.nextSibling;
            break e;
          }
          s = s.parentNode;
        }
        s = void 0;
      }
      s = _0(s);
    }
  }
  function N0(n, r) {
    return n && r ? n === r ? !0 : n && n.nodeType === 3 ? !1 : r && r.nodeType === 3 ? N0(n, r.parentNode) : "contains" in n ? n.contains(r) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(r) & 16) : !1 : !1;
  }
  function R0(n) {
    n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
    for (var r = vo(n.document); r instanceof n.HTMLIFrameElement; ) {
      try {
        var s = typeof r.contentWindow.location.href == "string";
      } catch {
        s = !1;
      }
      if (s) n = r.contentWindow;
      else break;
      r = vo(n.document);
    }
    return r;
  }
  function tc(n) {
    var r = n && n.nodeName && n.nodeName.toLowerCase();
    return r && (r === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || r === "textarea" || n.contentEditable === "true");
  }
  var ev = Wn && "documentMode" in document && 11 >= document.documentMode, Ur = null, nc = null, Yi = null, ac = !1;
  function v0(n, r, s) {
    var u = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
    ac || Ur == null || Ur !== vo(u) || (u = Ur, "selectionStart" in u && tc(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = {
      anchorNode: u.anchorNode,
      anchorOffset: u.anchorOffset,
      focusNode: u.focusNode,
      focusOffset: u.focusOffset
    }), Yi && qi(Yi, u) || (Yi = u, u = Sl(nc, "onSelect"), 0 < u.length && (r = new Oo(
      "onSelect",
      "select",
      null,
      r,
      s
    ), n.push({ event: r, listeners: u }), r.target = Ur)));
  }
  function Ka(n, r) {
    var s = {};
    return s[n.toLowerCase()] = r.toLowerCase(), s["Webkit" + n] = "webkit" + r, s["Moz" + n] = "moz" + r, s;
  }
  var Br = {
    animationend: Ka("Animation", "AnimationEnd"),
    animationiteration: Ka("Animation", "AnimationIteration"),
    animationstart: Ka("Animation", "AnimationStart"),
    transitionrun: Ka("Transition", "TransitionRun"),
    transitionstart: Ka("Transition", "TransitionStart"),
    transitioncancel: Ka("Transition", "TransitionCancel"),
    transitionend: Ka("Transition", "TransitionEnd")
  }, rc = {}, C0 = {};
  Wn && (C0 = document.createElement("div").style, "AnimationEvent" in window || (delete Br.animationend.animation, delete Br.animationiteration.animation, delete Br.animationstart.animation), "TransitionEvent" in window || delete Br.transitionend.transition);
  function Za(n) {
    if (rc[n]) return rc[n];
    if (!Br[n]) return n;
    var r = Br[n], s;
    for (s in r)
      if (r.hasOwnProperty(s) && s in C0)
        return rc[n] = r[s];
    return n;
  }
  var w0 = Za("animationend"), k0 = Za("animationiteration"), I0 = Za("animationstart"), tv = Za("transitionrun"), nv = Za("transitionstart"), av = Za("transitioncancel"), O0 = Za("transitionend"), x0 = /* @__PURE__ */ new Map(), ic = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  ic.push("scrollEnd");
  function wn(n, r) {
    x0.set(n, r), Wa(r, [n]);
  }
  var Do = typeof reportError == "function" ? reportError : function(n) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var r = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
        error: n
      });
      if (!window.dispatchEvent(r)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", n);
      return;
    }
    console.error(n);
  }, gn = [], Fr = 0, sc = 0;
  function Mo() {
    for (var n = Fr, r = sc = Fr = 0; r < n; ) {
      var s = gn[r];
      gn[r++] = null;
      var u = gn[r];
      gn[r++] = null;
      var p = gn[r];
      gn[r++] = null;
      var g = gn[r];
      if (gn[r++] = null, u !== null && p !== null) {
        var y = u.pending;
        y === null ? p.next = p : (p.next = y.next, y.next = p), u.pending = p;
      }
      g !== 0 && L0(s, p, g);
    }
  }
  function Uo(n, r, s, u) {
    gn[Fr++] = n, gn[Fr++] = r, gn[Fr++] = s, gn[Fr++] = u, sc |= u, n.lanes |= u, n = n.alternate, n !== null && (n.lanes |= u);
  }
  function oc(n, r, s, u) {
    return Uo(n, r, s, u), Bo(n);
  }
  function Qa(n, r) {
    return Uo(n, null, null, r), Bo(n);
  }
  function L0(n, r, s) {
    n.lanes |= s;
    var u = n.alternate;
    u !== null && (u.lanes |= s);
    for (var p = !1, g = n.return; g !== null; )
      g.childLanes |= s, u = g.alternate, u !== null && (u.childLanes |= s), g.tag === 22 && (n = g.stateNode, n === null || n._visibility & 1 || (p = !0)), n = g, g = g.return;
    return n.tag === 3 ? (g = n.stateNode, p && r !== null && (p = 31 - tt(s), n = g.hiddenUpdates, u = n[p], u === null ? n[p] = [r] : u.push(r), r.lane = s | 536870912), g) : null;
  }
  function Bo(n) {
    if (50 < ms)
      throw ms = 0, hd = null, Error(i(185));
    for (var r = n.return; r !== null; )
      n = r, r = n.return;
    return n.tag === 3 ? n.stateNode : null;
  }
  var Pr = {};
  function rv(n, r, s, u) {
    this.tag = n, this.key = s, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = r, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function rn(n, r, s, u) {
    return new rv(n, r, s, u);
  }
  function lc(n) {
    return n = n.prototype, !(!n || !n.isReactComponent);
  }
  function Xn(n, r) {
    var s = n.alternate;
    return s === null ? (s = rn(
      n.tag,
      r,
      n.key,
      n.mode
    ), s.elementType = n.elementType, s.type = n.type, s.stateNode = n.stateNode, s.alternate = n, n.alternate = s) : (s.pendingProps = r, s.type = n.type, s.flags = 0, s.subtreeFlags = 0, s.deletions = null), s.flags = n.flags & 65011712, s.childLanes = n.childLanes, s.lanes = n.lanes, s.child = n.child, s.memoizedProps = n.memoizedProps, s.memoizedState = n.memoizedState, s.updateQueue = n.updateQueue, r = n.dependencies, s.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }, s.sibling = n.sibling, s.index = n.index, s.ref = n.ref, s.refCleanup = n.refCleanup, s;
  }
  function D0(n, r) {
    n.flags &= 65011714;
    var s = n.alternate;
    return s === null ? (n.childLanes = 0, n.lanes = r, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = s.childLanes, n.lanes = s.lanes, n.child = s.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = s.memoizedProps, n.memoizedState = s.memoizedState, n.updateQueue = s.updateQueue, n.type = s.type, r = s.dependencies, n.dependencies = r === null ? null : {
      lanes: r.lanes,
      firstContext: r.firstContext
    }), n;
  }
  function Fo(n, r, s, u, p, g) {
    var y = 0;
    if (u = n, typeof n == "function") lc(n) && (y = 1);
    else if (typeof n == "string")
      y = uC(
        n,
        s,
        he.current
      ) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
    else
      e: switch (n) {
        case Q:
          return n = rn(31, s, r, p), n.elementType = Q, n.lanes = g, n;
        case k:
          return Ja(s.children, p, g, r);
        case R:
          y = 8, p |= 24;
          break;
        case C:
          return n = rn(12, s, r, p | 2), n.elementType = C, n.lanes = g, n;
        case q:
          return n = rn(13, s, r, p), n.elementType = q, n.lanes = g, n;
        case D:
          return n = rn(19, s, r, p), n.elementType = D, n.lanes = g, n;
        default:
          if (typeof n == "object" && n !== null)
            switch (n.$$typeof) {
              case x:
                y = 10;
                break e;
              case L:
                y = 9;
                break e;
              case Y:
                y = 11;
                break e;
              case G:
                y = 14;
                break e;
              case K:
                y = 16, u = null;
                break e;
            }
          y = 29, s = Error(
            i(130, n === null ? "null" : typeof n, "")
          ), u = null;
      }
    return r = rn(y, s, r, p), r.elementType = n, r.type = u, r.lanes = g, r;
  }
  function Ja(n, r, s, u) {
    return n = rn(7, n, u, r), n.lanes = s, n;
  }
  function uc(n, r, s) {
    return n = rn(6, n, null, r), n.lanes = s, n;
  }
  function M0(n) {
    var r = rn(18, null, null, 0);
    return r.stateNode = n, r;
  }
  function cc(n, r, s) {
    return r = rn(
      4,
      n.children !== null ? n.children : [],
      n.key,
      r
    ), r.lanes = s, r.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation
    }, r;
  }
  var U0 = /* @__PURE__ */ new WeakMap();
  function hn(n, r) {
    if (typeof n == "object" && n !== null) {
      var s = U0.get(n);
      return s !== void 0 ? s : (r = {
        value: n,
        source: r,
        stack: yo(r)
      }, U0.set(n, r), r);
    }
    return {
      value: n,
      source: r,
      stack: yo(r)
    };
  }
  var Hr = [], zr = 0, Po = null, Vi = 0, bn = [], En = 0, ba = null, Mn = 1, Un = "";
  function Kn(n, r) {
    Hr[zr++] = Vi, Hr[zr++] = Po, Po = n, Vi = r;
  }
  function B0(n, r, s) {
    bn[En++] = Mn, bn[En++] = Un, bn[En++] = ba, ba = n;
    var u = Mn;
    n = Un;
    var p = 32 - tt(u) - 1;
    u &= ~(1 << p), s += 1;
    var g = 32 - tt(r) + p;
    if (30 < g) {
      var y = p - p % 5;
      g = (u & (1 << y) - 1).toString(32), u >>= y, p -= y, Mn = 1 << 32 - tt(r) + p | s << p | u, Un = g + n;
    } else
      Mn = 1 << g | s << p | u, Un = n;
  }
  function dc(n) {
    n.return !== null && (Kn(n, 1), B0(n, 1, 0));
  }
  function pc(n) {
    for (; n === Po; )
      Po = Hr[--zr], Hr[zr] = null, Vi = Hr[--zr], Hr[zr] = null;
    for (; n === ba; )
      ba = bn[--En], bn[En] = null, Un = bn[--En], bn[En] = null, Mn = bn[--En], bn[En] = null;
  }
  function F0(n, r) {
    bn[En++] = Mn, bn[En++] = Un, bn[En++] = ba, Mn = r.id, Un = r.overflow, ba = n;
  }
  var wt = null, it = null, Ge = !1, Ea = null, yn = !1, fc = Error(i(519));
  function ya(n) {
    var r = Error(
      i(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw Wi(hn(r, n)), fc;
  }
  function P0(n) {
    var r = n.stateNode, s = n.type, u = n.memoizedProps;
    switch (r[Ct] = n, r[qt] = u, s) {
      case "dialog":
        Be("cancel", r), Be("close", r);
        break;
      case "iframe":
      case "object":
      case "embed":
        Be("load", r);
        break;
      case "video":
      case "audio":
        for (s = 0; s < hs.length; s++)
          Be(hs[s], r);
        break;
      case "source":
        Be("error", r);
        break;
      case "img":
      case "image":
      case "link":
        Be("error", r), Be("load", r);
        break;
      case "details":
        Be("toggle", r);
        break;
      case "input":
        Be("invalid", r), QE(
          r,
          u.value,
          u.defaultValue,
          u.checked,
          u.defaultChecked,
          u.type,
          u.name,
          !0
        );
        break;
      case "select":
        Be("invalid", r);
        break;
      case "textarea":
        Be("invalid", r), e0(r, u.value, u.defaultValue, u.children);
    }
    s = u.children, typeof s != "string" && typeof s != "number" && typeof s != "bigint" || r.textContent === "" + s || u.suppressHydrationWarning === !0 || nS(r.textContent, s) ? (u.popover != null && (Be("beforetoggle", r), Be("toggle", r)), u.onScroll != null && Be("scroll", r), u.onScrollEnd != null && Be("scrollend", r), u.onClick != null && (r.onclick = Vn), r = !0) : r = !1, r || ya(n, !0);
  }
  function H0(n) {
    for (wt = n.return; wt; )
      switch (wt.tag) {
        case 5:
        case 31:
        case 13:
          yn = !1;
          return;
        case 27:
        case 3:
          yn = !0;
          return;
        default:
          wt = wt.return;
      }
  }
  function Gr(n) {
    if (n !== wt) return !1;
    if (!Ge) return H0(n), Ge = !0, !1;
    var r = n.tag, s;
    if ((s = r !== 3 && r !== 27) && ((s = r === 5) && (s = n.type, s = !(s !== "form" && s !== "button") || Od(n.type, n.memoizedProps)), s = !s), s && it && ya(n), H0(n), r === 13) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(i(317));
      it = dS(n);
    } else if (r === 31) {
      if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(i(317));
      it = dS(n);
    } else
      r === 27 ? (r = it, La(n.type) ? (n = Ud, Ud = null, it = n) : it = r) : it = wt ? Sn(n.stateNode.nextSibling) : null;
    return !0;
  }
  function er() {
    it = wt = null, Ge = !1;
  }
  function mc() {
    var n = Ea;
    return n !== null && (Kt === null ? Kt = n : Kt.push.apply(
      Kt,
      n
    ), Ea = null), n;
  }
  function Wi(n) {
    Ea === null ? Ea = [n] : Ea.push(n);
  }
  var gc = F(null), tr = null, Zn = null;
  function Ta(n, r, s) {
    v(gc, r._currentValue), r._currentValue = s;
  }
  function Qn(n) {
    n._currentValue = gc.current, te(gc);
  }
  function hc(n, r, s) {
    for (; n !== null; ) {
      var u = n.alternate;
      if ((n.childLanes & r) !== r ? (n.childLanes |= r, u !== null && (u.childLanes |= r)) : u !== null && (u.childLanes & r) !== r && (u.childLanes |= r), n === s) break;
      n = n.return;
    }
  }
  function bc(n, r, s, u) {
    var p = n.child;
    for (p !== null && (p.return = n); p !== null; ) {
      var g = p.dependencies;
      if (g !== null) {
        var y = p.child;
        g = g.firstContext;
        e: for (; g !== null; ) {
          var A = g;
          g = p;
          for (var P = 0; P < r.length; P++)
            if (A.context === r[P]) {
              g.lanes |= s, A = g.alternate, A !== null && (A.lanes |= s), hc(
                g.return,
                s,
                n
              ), u || (y = null);
              break e;
            }
          g = A.next;
        }
      } else if (p.tag === 18) {
        if (y = p.return, y === null) throw Error(i(341));
        y.lanes |= s, g = y.alternate, g !== null && (g.lanes |= s), hc(y, s, n), y = null;
      } else y = p.child;
      if (y !== null) y.return = p;
      else
        for (y = p; y !== null; ) {
          if (y === n) {
            y = null;
            break;
          }
          if (p = y.sibling, p !== null) {
            p.return = y.return, y = p;
            break;
          }
          y = y.return;
        }
      p = y;
    }
  }
  function jr(n, r, s, u) {
    n = null;
    for (var p = r, g = !1; p !== null; ) {
      if (!g) {
        if ((p.flags & 524288) !== 0) g = !0;
        else if ((p.flags & 262144) !== 0) break;
      }
      if (p.tag === 10) {
        var y = p.alternate;
        if (y === null) throw Error(i(387));
        if (y = y.memoizedProps, y !== null) {
          var A = p.type;
          an(p.pendingProps.value, y.value) || (n !== null ? n.push(A) : n = [A]);
        }
      } else if (p === Le.current) {
        if (y = p.alternate, y === null) throw Error(i(387));
        y.memoizedState.memoizedState !== p.memoizedState.memoizedState && (n !== null ? n.push(Ss) : n = [Ss]);
      }
      p = p.return;
    }
    n !== null && bc(
      r,
      n,
      s,
      u
    ), r.flags |= 262144;
  }
  function Ho(n) {
    for (n = n.firstContext; n !== null; ) {
      if (!an(
        n.context._currentValue,
        n.memoizedValue
      ))
        return !0;
      n = n.next;
    }
    return !1;
  }
  function nr(n) {
    tr = n, Zn = null, n = n.dependencies, n !== null && (n.firstContext = null);
  }
  function kt(n) {
    return z0(tr, n);
  }
  function zo(n, r) {
    return tr === null && nr(n), z0(n, r);
  }
  function z0(n, r) {
    var s = r._currentValue;
    if (r = { context: r, memoizedValue: s, next: null }, Zn === null) {
      if (n === null) throw Error(i(308));
      Zn = r, n.dependencies = { lanes: 0, firstContext: r }, n.flags |= 524288;
    } else Zn = Zn.next = r;
    return s;
  }
  var iv = typeof AbortController < "u" ? AbortController : function() {
    var n = [], r = this.signal = {
      aborted: !1,
      addEventListener: function(s, u) {
        n.push(u);
      }
    };
    this.abort = function() {
      r.aborted = !0, n.forEach(function(s) {
        return s();
      });
    };
  }, sv = e.unstable_scheduleCallback, ov = e.unstable_NormalPriority, gt = {
    $$typeof: x,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Ec() {
    return {
      controller: new iv(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Xi(n) {
    n.refCount--, n.refCount === 0 && sv(ov, function() {
      n.controller.abort();
    });
  }
  var Ki = null, yc = 0, $r = 0, qr = null;
  function lv(n, r) {
    if (Ki === null) {
      var s = Ki = [];
      yc = 0, $r = _d(), qr = {
        status: "pending",
        value: void 0,
        then: function(u) {
          s.push(u);
        }
      };
    }
    return yc++, r.then(G0, G0), r;
  }
  function G0() {
    if (--yc === 0 && Ki !== null) {
      qr !== null && (qr.status = "fulfilled");
      var n = Ki;
      Ki = null, $r = 0, qr = null;
      for (var r = 0; r < n.length; r++) (0, n[r])();
    }
  }
  function uv(n, r) {
    var s = [], u = {
      status: "pending",
      value: null,
      reason: null,
      then: function(p) {
        s.push(p);
      }
    };
    return n.then(
      function() {
        u.status = "fulfilled", u.value = r;
        for (var p = 0; p < s.length; p++) (0, s[p])(r);
      },
      function(p) {
        for (u.status = "rejected", u.reason = p, p = 0; p < s.length; p++)
          (0, s[p])(void 0);
      }
    ), u;
  }
  var j0 = j.S;
  j.S = function(n, r) {
    vT = Pt(), typeof r == "object" && r !== null && typeof r.then == "function" && lv(n, r), j0 !== null && j0(n, r);
  };
  var ar = F(null);
  function Tc() {
    var n = ar.current;
    return n !== null ? n : nt.pooledCache;
  }
  function Go(n, r) {
    r === null ? v(ar, ar.current) : v(ar, r.pool);
  }
  function $0() {
    var n = Tc();
    return n === null ? null : { parent: gt._currentValue, pool: n };
  }
  var Yr = Error(i(460)), Sc = Error(i(474)), jo = Error(i(542)), $o = { then: function() {
  } };
  function q0(n) {
    return n = n.status, n === "fulfilled" || n === "rejected";
  }
  function Y0(n, r, s) {
    switch (s = n[s], s === void 0 ? n.push(r) : s !== r && (r.then(Vn, Vn), r = s), r.status) {
      case "fulfilled":
        return r.value;
      case "rejected":
        throw n = r.reason, W0(n), n;
      default:
        if (typeof r.status == "string") r.then(Vn, Vn);
        else {
          if (n = nt, n !== null && 100 < n.shellSuspendCounter)
            throw Error(i(482));
          n = r, n.status = "pending", n.then(
            function(u) {
              if (r.status === "pending") {
                var p = r;
                p.status = "fulfilled", p.value = u;
              }
            },
            function(u) {
              if (r.status === "pending") {
                var p = r;
                p.status = "rejected", p.reason = u;
              }
            }
          );
        }
        switch (r.status) {
          case "fulfilled":
            return r.value;
          case "rejected":
            throw n = r.reason, W0(n), n;
        }
        throw ir = r, Yr;
    }
  }
  function rr(n) {
    try {
      var r = n._init;
      return r(n._payload);
    } catch (s) {
      throw s !== null && typeof s == "object" && typeof s.then == "function" ? (ir = s, Yr) : s;
    }
  }
  var ir = null;
  function V0() {
    if (ir === null) throw Error(i(459));
    var n = ir;
    return ir = null, n;
  }
  function W0(n) {
    if (n === Yr || n === jo)
      throw Error(i(483));
  }
  var Vr = null, Zi = 0;
  function qo(n) {
    var r = Zi;
    return Zi += 1, Vr === null && (Vr = []), Y0(Vr, n, r);
  }
  function Qi(n, r) {
    r = r.props.ref, n.ref = r !== void 0 ? r : null;
  }
  function Yo(n, r) {
    throw r.$$typeof === T ? Error(i(525)) : (n = Object.prototype.toString.call(r), Error(
      i(
        31,
        n === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : n
      )
    ));
  }
  function X0(n) {
    function r($, H) {
      if (n) {
        var W = $.deletions;
        W === null ? ($.deletions = [H], $.flags |= 16) : W.push(H);
      }
    }
    function s($, H) {
      if (!n) return null;
      for (; H !== null; )
        r($, H), H = H.sibling;
      return null;
    }
    function u($) {
      for (var H = /* @__PURE__ */ new Map(); $ !== null; )
        $.key !== null ? H.set($.key, $) : H.set($.index, $), $ = $.sibling;
      return H;
    }
    function p($, H) {
      return $ = Xn($, H), $.index = 0, $.sibling = null, $;
    }
    function g($, H, W) {
      return $.index = W, n ? (W = $.alternate, W !== null ? (W = W.index, W < H ? ($.flags |= 67108866, H) : W) : ($.flags |= 67108866, H)) : ($.flags |= 1048576, H);
    }
    function y($) {
      return n && $.alternate === null && ($.flags |= 67108866), $;
    }
    function A($, H, W, oe) {
      return H === null || H.tag !== 6 ? (H = uc(W, $.mode, oe), H.return = $, H) : (H = p(H, W), H.return = $, H);
    }
    function P($, H, W, oe) {
      var Ae = W.type;
      return Ae === k ? re(
        $,
        H,
        W.props.children,
        oe,
        W.key
      ) : H !== null && (H.elementType === Ae || typeof Ae == "object" && Ae !== null && Ae.$$typeof === K && rr(Ae) === H.type) ? (H = p(H, W.props), Qi(H, W), H.return = $, H) : (H = Fo(
        W.type,
        W.key,
        W.props,
        null,
        $.mode,
        oe
      ), Qi(H, W), H.return = $, H);
    }
    function X($, H, W, oe) {
      return H === null || H.tag !== 4 || H.stateNode.containerInfo !== W.containerInfo || H.stateNode.implementation !== W.implementation ? (H = cc(W, $.mode, oe), H.return = $, H) : (H = p(H, W.children || []), H.return = $, H);
    }
    function re($, H, W, oe, Ae) {
      return H === null || H.tag !== 7 ? (H = Ja(
        W,
        $.mode,
        oe,
        Ae
      ), H.return = $, H) : (H = p(H, W), H.return = $, H);
    }
    function le($, H, W) {
      if (typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint")
        return H = uc(
          "" + H,
          $.mode,
          W
        ), H.return = $, H;
      if (typeof H == "object" && H !== null) {
        switch (H.$$typeof) {
          case S:
            return W = Fo(
              H.type,
              H.key,
              H.props,
              null,
              $.mode,
              W
            ), Qi(W, H), W.return = $, W;
          case _:
            return H = cc(
              H,
              $.mode,
              W
            ), H.return = $, H;
          case K:
            return H = rr(H), le($, H, W);
        }
        if (ce(H) || ae(H))
          return H = Ja(
            H,
            $.mode,
            W,
            null
          ), H.return = $, H;
        if (typeof H.then == "function")
          return le($, qo(H), W);
        if (H.$$typeof === x)
          return le(
            $,
            zo($, H),
            W
          );
        Yo($, H);
      }
      return null;
    }
    function Z($, H, W, oe) {
      var Ae = H !== null ? H.key : null;
      if (typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint")
        return Ae !== null ? null : A($, H, "" + W, oe);
      if (typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case S:
            return W.key === Ae ? P($, H, W, oe) : null;
          case _:
            return W.key === Ae ? X($, H, W, oe) : null;
          case K:
            return W = rr(W), Z($, H, W, oe);
        }
        if (ce(W) || ae(W))
          return Ae !== null ? null : re($, H, W, oe, null);
        if (typeof W.then == "function")
          return Z(
            $,
            H,
            qo(W),
            oe
          );
        if (W.$$typeof === x)
          return Z(
            $,
            H,
            zo($, W),
            oe
          );
        Yo($, W);
      }
      return null;
    }
    function J($, H, W, oe, Ae) {
      if (typeof oe == "string" && oe !== "" || typeof oe == "number" || typeof oe == "bigint")
        return $ = $.get(W) || null, A(H, $, "" + oe, Ae);
      if (typeof oe == "object" && oe !== null) {
        switch (oe.$$typeof) {
          case S:
            return $ = $.get(
              oe.key === null ? W : oe.key
            ) || null, P(H, $, oe, Ae);
          case _:
            return $ = $.get(
              oe.key === null ? W : oe.key
            ) || null, X(H, $, oe, Ae);
          case K:
            return oe = rr(oe), J(
              $,
              H,
              W,
              oe,
              Ae
            );
        }
        if (ce(oe) || ae(oe))
          return $ = $.get(W) || null, re(H, $, oe, Ae, null);
        if (typeof oe.then == "function")
          return J(
            $,
            H,
            W,
            qo(oe),
            Ae
          );
        if (oe.$$typeof === x)
          return J(
            $,
            H,
            W,
            zo(H, oe),
            Ae
          );
        Yo(H, oe);
      }
      return null;
    }
    function Te($, H, W, oe) {
      for (var Ae = null, $e = null, Se = H, Oe = H = 0, He = null; Se !== null && Oe < W.length; Oe++) {
        Se.index > Oe ? (He = Se, Se = null) : He = Se.sibling;
        var qe = Z(
          $,
          Se,
          W[Oe],
          oe
        );
        if (qe === null) {
          Se === null && (Se = He);
          break;
        }
        n && Se && qe.alternate === null && r($, Se), H = g(qe, H, Oe), $e === null ? Ae = qe : $e.sibling = qe, $e = qe, Se = He;
      }
      if (Oe === W.length)
        return s($, Se), Ge && Kn($, Oe), Ae;
      if (Se === null) {
        for (; Oe < W.length; Oe++)
          Se = le($, W[Oe], oe), Se !== null && (H = g(
            Se,
            H,
            Oe
          ), $e === null ? Ae = Se : $e.sibling = Se, $e = Se);
        return Ge && Kn($, Oe), Ae;
      }
      for (Se = u(Se); Oe < W.length; Oe++)
        He = J(
          Se,
          $,
          Oe,
          W[Oe],
          oe
        ), He !== null && (n && He.alternate !== null && Se.delete(
          He.key === null ? Oe : He.key
        ), H = g(
          He,
          H,
          Oe
        ), $e === null ? Ae = He : $e.sibling = He, $e = He);
      return n && Se.forEach(function(Fa) {
        return r($, Fa);
      }), Ge && Kn($, Oe), Ae;
    }
    function Ce($, H, W, oe) {
      if (W == null) throw Error(i(151));
      for (var Ae = null, $e = null, Se = H, Oe = H = 0, He = null, qe = W.next(); Se !== null && !qe.done; Oe++, qe = W.next()) {
        Se.index > Oe ? (He = Se, Se = null) : He = Se.sibling;
        var Fa = Z($, Se, qe.value, oe);
        if (Fa === null) {
          Se === null && (Se = He);
          break;
        }
        n && Se && Fa.alternate === null && r($, Se), H = g(Fa, H, Oe), $e === null ? Ae = Fa : $e.sibling = Fa, $e = Fa, Se = He;
      }
      if (qe.done)
        return s($, Se), Ge && Kn($, Oe), Ae;
      if (Se === null) {
        for (; !qe.done; Oe++, qe = W.next())
          qe = le($, qe.value, oe), qe !== null && (H = g(qe, H, Oe), $e === null ? Ae = qe : $e.sibling = qe, $e = qe);
        return Ge && Kn($, Oe), Ae;
      }
      for (Se = u(Se); !qe.done; Oe++, qe = W.next())
        qe = J(Se, $, Oe, qe.value, oe), qe !== null && (n && qe.alternate !== null && Se.delete(qe.key === null ? Oe : qe.key), H = g(qe, H, Oe), $e === null ? Ae = qe : $e.sibling = qe, $e = qe);
      return n && Se.forEach(function(TC) {
        return r($, TC);
      }), Ge && Kn($, Oe), Ae;
    }
    function et($, H, W, oe) {
      if (typeof W == "object" && W !== null && W.type === k && W.key === null && (W = W.props.children), typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case S:
            e: {
              for (var Ae = W.key; H !== null; ) {
                if (H.key === Ae) {
                  if (Ae = W.type, Ae === k) {
                    if (H.tag === 7) {
                      s(
                        $,
                        H.sibling
                      ), oe = p(
                        H,
                        W.props.children
                      ), oe.return = $, $ = oe;
                      break e;
                    }
                  } else if (H.elementType === Ae || typeof Ae == "object" && Ae !== null && Ae.$$typeof === K && rr(Ae) === H.type) {
                    s(
                      $,
                      H.sibling
                    ), oe = p(H, W.props), Qi(oe, W), oe.return = $, $ = oe;
                    break e;
                  }
                  s($, H);
                  break;
                } else r($, H);
                H = H.sibling;
              }
              W.type === k ? (oe = Ja(
                W.props.children,
                $.mode,
                oe,
                W.key
              ), oe.return = $, $ = oe) : (oe = Fo(
                W.type,
                W.key,
                W.props,
                null,
                $.mode,
                oe
              ), Qi(oe, W), oe.return = $, $ = oe);
            }
            return y($);
          case _:
            e: {
              for (Ae = W.key; H !== null; ) {
                if (H.key === Ae)
                  if (H.tag === 4 && H.stateNode.containerInfo === W.containerInfo && H.stateNode.implementation === W.implementation) {
                    s(
                      $,
                      H.sibling
                    ), oe = p(H, W.children || []), oe.return = $, $ = oe;
                    break e;
                  } else {
                    s($, H);
                    break;
                  }
                else r($, H);
                H = H.sibling;
              }
              oe = cc(W, $.mode, oe), oe.return = $, $ = oe;
            }
            return y($);
          case K:
            return W = rr(W), et(
              $,
              H,
              W,
              oe
            );
        }
        if (ce(W))
          return Te(
            $,
            H,
            W,
            oe
          );
        if (ae(W)) {
          if (Ae = ae(W), typeof Ae != "function") throw Error(i(150));
          return W = Ae.call(W), Ce(
            $,
            H,
            W,
            oe
          );
        }
        if (typeof W.then == "function")
          return et(
            $,
            H,
            qo(W),
            oe
          );
        if (W.$$typeof === x)
          return et(
            $,
            H,
            zo($, W),
            oe
          );
        Yo($, W);
      }
      return typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint" ? (W = "" + W, H !== null && H.tag === 6 ? (s($, H.sibling), oe = p(H, W), oe.return = $, $ = oe) : (s($, H), oe = uc(W, $.mode, oe), oe.return = $, $ = oe), y($)) : s($, H);
    }
    return function($, H, W, oe) {
      try {
        Zi = 0;
        var Ae = et(
          $,
          H,
          W,
          oe
        );
        return Vr = null, Ae;
      } catch (Se) {
        if (Se === Yr || Se === jo) throw Se;
        var $e = rn(29, Se, null, $.mode);
        return $e.lanes = oe, $e.return = $, $e;
      } finally {
      }
    };
  }
  var sr = X0(!0), K0 = X0(!1), Sa = !1;
  function _c(n) {
    n.updateQueue = {
      baseState: n.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Ac(n, r) {
    n = n.updateQueue, r.updateQueue === n && (r.updateQueue = {
      baseState: n.baseState,
      firstBaseUpdate: n.firstBaseUpdate,
      lastBaseUpdate: n.lastBaseUpdate,
      shared: n.shared,
      callbacks: null
    });
  }
  function _a(n) {
    return { lane: n, tag: 0, payload: null, callback: null, next: null };
  }
  function Aa(n, r, s) {
    var u = n.updateQueue;
    if (u === null) return null;
    if (u = u.shared, (Ye & 2) !== 0) {
      var p = u.pending;
      return p === null ? r.next = r : (r.next = p.next, p.next = r), u.pending = r, r = Bo(n), L0(n, null, s), r;
    }
    return Uo(n, u, r, s), Bo(n);
  }
  function Ji(n, r, s) {
    if (r = r.updateQueue, r !== null && (r = r.shared, (s & 4194048) !== 0)) {
      var u = r.lanes;
      u &= n.pendingLanes, s |= u, r.lanes = s, zE(n, s);
    }
  }
  function Nc(n, r) {
    var s = n.updateQueue, u = n.alternate;
    if (u !== null && (u = u.updateQueue, s === u)) {
      var p = null, g = null;
      if (s = s.firstBaseUpdate, s !== null) {
        do {
          var y = {
            lane: s.lane,
            tag: s.tag,
            payload: s.payload,
            callback: null,
            next: null
          };
          g === null ? p = g = y : g = g.next = y, s = s.next;
        } while (s !== null);
        g === null ? p = g = r : g = g.next = r;
      } else p = g = r;
      s = {
        baseState: u.baseState,
        firstBaseUpdate: p,
        lastBaseUpdate: g,
        shared: u.shared,
        callbacks: u.callbacks
      }, n.updateQueue = s;
      return;
    }
    n = s.lastBaseUpdate, n === null ? s.firstBaseUpdate = r : n.next = r, s.lastBaseUpdate = r;
  }
  var Rc = !1;
  function es() {
    if (Rc) {
      var n = qr;
      if (n !== null) throw n;
    }
  }
  function ts(n, r, s, u) {
    Rc = !1;
    var p = n.updateQueue;
    Sa = !1;
    var g = p.firstBaseUpdate, y = p.lastBaseUpdate, A = p.shared.pending;
    if (A !== null) {
      p.shared.pending = null;
      var P = A, X = P.next;
      P.next = null, y === null ? g = X : y.next = X, y = P;
      var re = n.alternate;
      re !== null && (re = re.updateQueue, A = re.lastBaseUpdate, A !== y && (A === null ? re.firstBaseUpdate = X : A.next = X, re.lastBaseUpdate = P));
    }
    if (g !== null) {
      var le = p.baseState;
      y = 0, re = X = P = null, A = g;
      do {
        var Z = A.lane & -536870913, J = Z !== A.lane;
        if (J ? (Pe & Z) === Z : (u & Z) === Z) {
          Z !== 0 && Z === $r && (Rc = !0), re !== null && (re = re.next = {
            lane: 0,
            tag: A.tag,
            payload: A.payload,
            callback: null,
            next: null
          });
          e: {
            var Te = n, Ce = A;
            Z = r;
            var et = s;
            switch (Ce.tag) {
              case 1:
                if (Te = Ce.payload, typeof Te == "function") {
                  le = Te.call(et, le, Z);
                  break e;
                }
                le = Te;
                break e;
              case 3:
                Te.flags = Te.flags & -65537 | 128;
              case 0:
                if (Te = Ce.payload, Z = typeof Te == "function" ? Te.call(et, le, Z) : Te, Z == null) break e;
                le = E({}, le, Z);
                break e;
              case 2:
                Sa = !0;
            }
          }
          Z = A.callback, Z !== null && (n.flags |= 64, J && (n.flags |= 8192), J = p.callbacks, J === null ? p.callbacks = [Z] : J.push(Z));
        } else
          J = {
            lane: Z,
            tag: A.tag,
            payload: A.payload,
            callback: A.callback,
            next: null
          }, re === null ? (X = re = J, P = le) : re = re.next = J, y |= Z;
        if (A = A.next, A === null) {
          if (A = p.shared.pending, A === null)
            break;
          J = A, A = J.next, J.next = null, p.lastBaseUpdate = J, p.shared.pending = null;
        }
      } while (!0);
      re === null && (P = le), p.baseState = P, p.firstBaseUpdate = X, p.lastBaseUpdate = re, g === null && (p.shared.lanes = 0), wa |= y, n.lanes = y, n.memoizedState = le;
    }
  }
  function Z0(n, r) {
    if (typeof n != "function")
      throw Error(i(191, n));
    n.call(r);
  }
  function Q0(n, r) {
    var s = n.callbacks;
    if (s !== null)
      for (n.callbacks = null, n = 0; n < s.length; n++)
        Z0(s[n], r);
  }
  var Wr = F(null), Vo = F(0);
  function J0(n, r) {
    n = oa, v(Vo, n), v(Wr, r), oa = n | r.baseLanes;
  }
  function vc() {
    v(Vo, oa), v(Wr, Wr.current);
  }
  function Cc() {
    oa = Vo.current, te(Wr), te(Vo);
  }
  var sn = F(null), Tn = null;
  function Na(n) {
    var r = n.alternate;
    v(pt, pt.current & 1), v(sn, n), Tn === null && (r === null || Wr.current !== null || r.memoizedState !== null) && (Tn = n);
  }
  function wc(n) {
    v(pt, pt.current), v(sn, n), Tn === null && (Tn = n);
  }
  function ey(n) {
    n.tag === 22 ? (v(pt, pt.current), v(sn, n), Tn === null && (Tn = n)) : Ra();
  }
  function Ra() {
    v(pt, pt.current), v(sn, sn.current);
  }
  function on(n) {
    te(sn), Tn === n && (Tn = null), te(pt);
  }
  var pt = F(0);
  function Wo(n) {
    for (var r = n; r !== null; ) {
      if (r.tag === 13) {
        var s = r.memoizedState;
        if (s !== null && (s = s.dehydrated, s === null || Dd(s) || Md(s)))
          return r;
      } else if (r.tag === 19 && (r.memoizedProps.revealOrder === "forwards" || r.memoizedProps.revealOrder === "backwards" || r.memoizedProps.revealOrder === "unstable_legacy-backwards" || r.memoizedProps.revealOrder === "together")) {
        if ((r.flags & 128) !== 0) return r;
      } else if (r.child !== null) {
        r.child.return = r, r = r.child;
        continue;
      }
      if (r === n) break;
      for (; r.sibling === null; ) {
        if (r.return === null || r.return === n) return null;
        r = r.return;
      }
      r.sibling.return = r.return, r = r.sibling;
    }
    return null;
  }
  var Jn = 0, Ie = null, Qe = null, ht = null, Xo = !1, Xr = !1, or = !1, Ko = 0, ns = 0, Kr = null, cv = 0;
  function ct() {
    throw Error(i(321));
  }
  function kc(n, r) {
    if (r === null) return !1;
    for (var s = 0; s < r.length && s < n.length; s++)
      if (!an(n[s], r[s])) return !1;
    return !0;
  }
  function Ic(n, r, s, u, p, g) {
    return Jn = g, Ie = r, r.memoizedState = null, r.updateQueue = null, r.lanes = 0, j.H = n === null || n.memoizedState === null ? By : qc, or = !1, g = s(u, p), or = !1, Xr && (g = ny(
      r,
      s,
      u,
      p
    )), ty(n), g;
  }
  function ty(n) {
    j.H = is;
    var r = Qe !== null && Qe.next !== null;
    if (Jn = 0, ht = Qe = Ie = null, Xo = !1, ns = 0, Kr = null, r) throw Error(i(300));
    n === null || bt || (n = n.dependencies, n !== null && Ho(n) && (bt = !0));
  }
  function ny(n, r, s, u) {
    Ie = n;
    var p = 0;
    do {
      if (Xr && (Kr = null), ns = 0, Xr = !1, 25 <= p) throw Error(i(301));
      if (p += 1, ht = Qe = null, n.updateQueue != null) {
        var g = n.updateQueue;
        g.lastEffect = null, g.events = null, g.stores = null, g.memoCache != null && (g.memoCache.index = 0);
      }
      j.H = Fy, g = r(s, u);
    } while (Xr);
    return g;
  }
  function dv() {
    var n = j.H, r = n.useState()[0];
    return r = typeof r.then == "function" ? as(r) : r, n = n.useState()[0], (Qe !== null ? Qe.memoizedState : null) !== n && (Ie.flags |= 1024), r;
  }
  function Oc() {
    var n = Ko !== 0;
    return Ko = 0, n;
  }
  function xc(n, r, s) {
    r.updateQueue = n.updateQueue, r.flags &= -2053, n.lanes &= ~s;
  }
  function Lc(n) {
    if (Xo) {
      for (n = n.memoizedState; n !== null; ) {
        var r = n.queue;
        r !== null && (r.pending = null), n = n.next;
      }
      Xo = !1;
    }
    Jn = 0, ht = Qe = Ie = null, Xr = !1, ns = Ko = 0, Kr = null;
  }
  function zt() {
    var n = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return ht === null ? Ie.memoizedState = ht = n : ht = ht.next = n, ht;
  }
  function ft() {
    if (Qe === null) {
      var n = Ie.alternate;
      n = n !== null ? n.memoizedState : null;
    } else n = Qe.next;
    var r = ht === null ? Ie.memoizedState : ht.next;
    if (r !== null)
      ht = r, Qe = n;
    else {
      if (n === null)
        throw Ie.alternate === null ? Error(i(467)) : Error(i(310));
      Qe = n, n = {
        memoizedState: Qe.memoizedState,
        baseState: Qe.baseState,
        baseQueue: Qe.baseQueue,
        queue: Qe.queue,
        next: null
      }, ht === null ? Ie.memoizedState = ht = n : ht = ht.next = n;
    }
    return ht;
  }
  function Zo() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function as(n) {
    var r = ns;
    return ns += 1, Kr === null && (Kr = []), n = Y0(Kr, n, r), r = Ie, (ht === null ? r.memoizedState : ht.next) === null && (r = r.alternate, j.H = r === null || r.memoizedState === null ? By : qc), n;
  }
  function Qo(n) {
    if (n !== null && typeof n == "object") {
      if (typeof n.then == "function") return as(n);
      if (n.$$typeof === x) return kt(n);
    }
    throw Error(i(438, String(n)));
  }
  function Dc(n) {
    var r = null, s = Ie.updateQueue;
    if (s !== null && (r = s.memoCache), r == null) {
      var u = Ie.alternate;
      u !== null && (u = u.updateQueue, u !== null && (u = u.memoCache, u != null && (r = {
        data: u.data.map(function(p) {
          return p.slice();
        }),
        index: 0
      })));
    }
    if (r == null && (r = { data: [], index: 0 }), s === null && (s = Zo(), Ie.updateQueue = s), s.memoCache = r, s = r.data[r.index], s === void 0)
      for (s = r.data[r.index] = Array(n), u = 0; u < n; u++)
        s[u] = U;
    return r.index++, s;
  }
  function ea(n, r) {
    return typeof r == "function" ? r(n) : r;
  }
  function Jo(n) {
    var r = ft();
    return Mc(r, Qe, n);
  }
  function Mc(n, r, s) {
    var u = n.queue;
    if (u === null) throw Error(i(311));
    u.lastRenderedReducer = s;
    var p = n.baseQueue, g = u.pending;
    if (g !== null) {
      if (p !== null) {
        var y = p.next;
        p.next = g.next, g.next = y;
      }
      r.baseQueue = p = g, u.pending = null;
    }
    if (g = n.baseState, p === null) n.memoizedState = g;
    else {
      r = p.next;
      var A = y = null, P = null, X = r, re = !1;
      do {
        var le = X.lane & -536870913;
        if (le !== X.lane ? (Pe & le) === le : (Jn & le) === le) {
          var Z = X.revertLane;
          if (Z === 0)
            P !== null && (P = P.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: X.action,
              hasEagerState: X.hasEagerState,
              eagerState: X.eagerState,
              next: null
            }), le === $r && (re = !0);
          else if ((Jn & Z) === Z) {
            X = X.next, Z === $r && (re = !0);
            continue;
          } else
            le = {
              lane: 0,
              revertLane: X.revertLane,
              gesture: null,
              action: X.action,
              hasEagerState: X.hasEagerState,
              eagerState: X.eagerState,
              next: null
            }, P === null ? (A = P = le, y = g) : P = P.next = le, Ie.lanes |= Z, wa |= Z;
          le = X.action, or && s(g, le), g = X.hasEagerState ? X.eagerState : s(g, le);
        } else
          Z = {
            lane: le,
            revertLane: X.revertLane,
            gesture: X.gesture,
            action: X.action,
            hasEagerState: X.hasEagerState,
            eagerState: X.eagerState,
            next: null
          }, P === null ? (A = P = Z, y = g) : P = P.next = Z, Ie.lanes |= le, wa |= le;
        X = X.next;
      } while (X !== null && X !== r);
      if (P === null ? y = g : P.next = A, !an(g, n.memoizedState) && (bt = !0, re && (s = qr, s !== null)))
        throw s;
      n.memoizedState = g, n.baseState = y, n.baseQueue = P, u.lastRenderedState = g;
    }
    return p === null && (u.lanes = 0), [n.memoizedState, u.dispatch];
  }
  function Uc(n) {
    var r = ft(), s = r.queue;
    if (s === null) throw Error(i(311));
    s.lastRenderedReducer = n;
    var u = s.dispatch, p = s.pending, g = r.memoizedState;
    if (p !== null) {
      s.pending = null;
      var y = p = p.next;
      do
        g = n(g, y.action), y = y.next;
      while (y !== p);
      an(g, r.memoizedState) || (bt = !0), r.memoizedState = g, r.baseQueue === null && (r.baseState = g), s.lastRenderedState = g;
    }
    return [g, u];
  }
  function ay(n, r, s) {
    var u = Ie, p = ft(), g = Ge;
    if (g) {
      if (s === void 0) throw Error(i(407));
      s = s();
    } else s = r();
    var y = !an(
      (Qe || p).memoizedState,
      s
    );
    if (y && (p.memoizedState = s, bt = !0), p = p.queue, Pc(sy.bind(null, u, p, n), [
      n
    ]), p.getSnapshot !== r || y || ht !== null && ht.memoizedState.tag & 1) {
      if (u.flags |= 2048, Zr(
        9,
        { destroy: void 0 },
        iy.bind(
          null,
          u,
          p,
          s,
          r
        ),
        null
      ), nt === null) throw Error(i(349));
      g || (Jn & 127) !== 0 || ry(u, r, s);
    }
    return s;
  }
  function ry(n, r, s) {
    n.flags |= 16384, n = { getSnapshot: r, value: s }, r = Ie.updateQueue, r === null ? (r = Zo(), Ie.updateQueue = r, r.stores = [n]) : (s = r.stores, s === null ? r.stores = [n] : s.push(n));
  }
  function iy(n, r, s, u) {
    r.value = s, r.getSnapshot = u, oy(r) && ly(n);
  }
  function sy(n, r, s) {
    return s(function() {
      oy(r) && ly(n);
    });
  }
  function oy(n) {
    var r = n.getSnapshot;
    n = n.value;
    try {
      var s = r();
      return !an(n, s);
    } catch {
      return !0;
    }
  }
  function ly(n) {
    var r = Qa(n, 2);
    r !== null && Zt(r, n, 2);
  }
  function Bc(n) {
    var r = zt();
    if (typeof n == "function") {
      var s = n;
      if (n = s(), or) {
        $t(!0);
        try {
          s();
        } finally {
          $t(!1);
        }
      }
    }
    return r.memoizedState = r.baseState = n, r.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ea,
      lastRenderedState: n
    }, r;
  }
  function uy(n, r, s, u) {
    return n.baseState = s, Mc(
      n,
      Qe,
      typeof u == "function" ? u : ea
    );
  }
  function pv(n, r, s, u, p) {
    if (nl(n)) throw Error(i(485));
    if (n = r.action, n !== null) {
      var g = {
        payload: p,
        action: n,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(y) {
          g.listeners.push(y);
        }
      };
      j.T !== null ? s(!0) : g.isTransition = !1, u(g), s = r.pending, s === null ? (g.next = r.pending = g, cy(r, g)) : (g.next = s.next, r.pending = s.next = g);
    }
  }
  function cy(n, r) {
    var s = r.action, u = r.payload, p = n.state;
    if (r.isTransition) {
      var g = j.T, y = {};
      j.T = y;
      try {
        var A = s(p, u), P = j.S;
        P !== null && P(y, A), dy(n, r, A);
      } catch (X) {
        Fc(n, r, X);
      } finally {
        g !== null && y.types !== null && (g.types = y.types), j.T = g;
      }
    } else
      try {
        g = s(p, u), dy(n, r, g);
      } catch (X) {
        Fc(n, r, X);
      }
  }
  function dy(n, r, s) {
    s !== null && typeof s == "object" && typeof s.then == "function" ? s.then(
      function(u) {
        py(n, r, u);
      },
      function(u) {
        return Fc(n, r, u);
      }
    ) : py(n, r, s);
  }
  function py(n, r, s) {
    r.status = "fulfilled", r.value = s, fy(r), n.state = s, r = n.pending, r !== null && (s = r.next, s === r ? n.pending = null : (s = s.next, r.next = s, cy(n, s)));
  }
  function Fc(n, r, s) {
    var u = n.pending;
    if (n.pending = null, u !== null) {
      u = u.next;
      do
        r.status = "rejected", r.reason = s, fy(r), r = r.next;
      while (r !== u);
    }
    n.action = null;
  }
  function fy(n) {
    n = n.listeners;
    for (var r = 0; r < n.length; r++) (0, n[r])();
  }
  function my(n, r) {
    return r;
  }
  function gy(n, r) {
    if (Ge) {
      var s = nt.formState;
      if (s !== null) {
        e: {
          var u = Ie;
          if (Ge) {
            if (it) {
              t: {
                for (var p = it, g = yn; p.nodeType !== 8; ) {
                  if (!g) {
                    p = null;
                    break t;
                  }
                  if (p = Sn(
                    p.nextSibling
                  ), p === null) {
                    p = null;
                    break t;
                  }
                }
                g = p.data, p = g === "F!" || g === "F" ? p : null;
              }
              if (p) {
                it = Sn(
                  p.nextSibling
                ), u = p.data === "F!";
                break e;
              }
            }
            ya(u);
          }
          u = !1;
        }
        u && (r = s[0]);
      }
    }
    return s = zt(), s.memoizedState = s.baseState = r, u = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: my,
      lastRenderedState: r
    }, s.queue = u, s = Dy.bind(
      null,
      Ie,
      u
    ), u.dispatch = s, u = Bc(!1), g = $c.bind(
      null,
      Ie,
      !1,
      u.queue
    ), u = zt(), p = {
      state: r,
      dispatch: null,
      action: n,
      pending: null
    }, u.queue = p, s = pv.bind(
      null,
      Ie,
      p,
      g,
      s
    ), p.dispatch = s, u.memoizedState = n, [r, s, !1];
  }
  function hy(n) {
    var r = ft();
    return by(r, Qe, n);
  }
  function by(n, r, s) {
    if (r = Mc(
      n,
      r,
      my
    )[0], n = Jo(ea)[0], typeof r == "object" && r !== null && typeof r.then == "function")
      try {
        var u = as(r);
      } catch (y) {
        throw y === Yr ? jo : y;
      }
    else u = r;
    r = ft();
    var p = r.queue, g = p.dispatch;
    return s !== r.memoizedState && (Ie.flags |= 2048, Zr(
      9,
      { destroy: void 0 },
      fv.bind(null, p, s),
      null
    )), [u, g, n];
  }
  function fv(n, r) {
    n.action = r;
  }
  function Ey(n) {
    var r = ft(), s = Qe;
    if (s !== null)
      return by(r, s, n);
    ft(), r = r.memoizedState, s = ft();
    var u = s.queue.dispatch;
    return s.memoizedState = n, [r, u, !1];
  }
  function Zr(n, r, s, u) {
    return n = { tag: n, create: s, deps: u, inst: r, next: null }, r = Ie.updateQueue, r === null && (r = Zo(), Ie.updateQueue = r), s = r.lastEffect, s === null ? r.lastEffect = n.next = n : (u = s.next, s.next = n, n.next = u, r.lastEffect = n), n;
  }
  function yy() {
    return ft().memoizedState;
  }
  function el(n, r, s, u) {
    var p = zt();
    Ie.flags |= n, p.memoizedState = Zr(
      1 | r,
      { destroy: void 0 },
      s,
      u === void 0 ? null : u
    );
  }
  function tl(n, r, s, u) {
    var p = ft();
    u = u === void 0 ? null : u;
    var g = p.memoizedState.inst;
    Qe !== null && u !== null && kc(u, Qe.memoizedState.deps) ? p.memoizedState = Zr(r, g, s, u) : (Ie.flags |= n, p.memoizedState = Zr(
      1 | r,
      g,
      s,
      u
    ));
  }
  function Ty(n, r) {
    el(8390656, 8, n, r);
  }
  function Pc(n, r) {
    tl(2048, 8, n, r);
  }
  function mv(n) {
    Ie.flags |= 4;
    var r = Ie.updateQueue;
    if (r === null)
      r = Zo(), Ie.updateQueue = r, r.events = [n];
    else {
      var s = r.events;
      s === null ? r.events = [n] : s.push(n);
    }
  }
  function Sy(n) {
    var r = ft().memoizedState;
    return mv({ ref: r, nextImpl: n }), function() {
      if ((Ye & 2) !== 0) throw Error(i(440));
      return r.impl.apply(void 0, arguments);
    };
  }
  function _y(n, r) {
    return tl(4, 2, n, r);
  }
  function Ay(n, r) {
    return tl(4, 4, n, r);
  }
  function Ny(n, r) {
    if (typeof r == "function") {
      n = n();
      var s = r(n);
      return function() {
        typeof s == "function" ? s() : r(null);
      };
    }
    if (r != null)
      return n = n(), r.current = n, function() {
        r.current = null;
      };
  }
  function Ry(n, r, s) {
    s = s != null ? s.concat([n]) : null, tl(4, 4, Ny.bind(null, r, n), s);
  }
  function Hc() {
  }
  function vy(n, r) {
    var s = ft();
    r = r === void 0 ? null : r;
    var u = s.memoizedState;
    return r !== null && kc(r, u[1]) ? u[0] : (s.memoizedState = [n, r], n);
  }
  function Cy(n, r) {
    var s = ft();
    r = r === void 0 ? null : r;
    var u = s.memoizedState;
    if (r !== null && kc(r, u[1]))
      return u[0];
    if (u = n(), or) {
      $t(!0);
      try {
        n();
      } finally {
        $t(!1);
      }
    }
    return s.memoizedState = [u, r], u;
  }
  function zc(n, r, s) {
    return s === void 0 || (Jn & 1073741824) !== 0 && (Pe & 261930) === 0 ? n.memoizedState = r : (n.memoizedState = s, n = wT(), Ie.lanes |= n, wa |= n, s);
  }
  function wy(n, r, s, u) {
    return an(s, r) ? s : Wr.current !== null ? (n = zc(n, s, u), an(n, r) || (bt = !0), n) : (Jn & 42) === 0 || (Jn & 1073741824) !== 0 && (Pe & 261930) === 0 ? (bt = !0, n.memoizedState = s) : (n = wT(), Ie.lanes |= n, wa |= n, r);
  }
  function ky(n, r, s, u, p) {
    var g = se.p;
    se.p = g !== 0 && 8 > g ? g : 8;
    var y = j.T, A = {};
    j.T = A, $c(n, !1, r, s);
    try {
      var P = p(), X = j.S;
      if (X !== null && X(A, P), P !== null && typeof P == "object" && typeof P.then == "function") {
        var re = uv(
          P,
          u
        );
        rs(
          n,
          r,
          re,
          cn(n)
        );
      } else
        rs(
          n,
          r,
          u,
          cn(n)
        );
    } catch (le) {
      rs(
        n,
        r,
        { then: function() {
        }, status: "rejected", reason: le },
        cn()
      );
    } finally {
      se.p = g, y !== null && A.types !== null && (y.types = A.types), j.T = y;
    }
  }
  function gv() {
  }
  function Gc(n, r, s, u) {
    if (n.tag !== 5) throw Error(i(476));
    var p = Iy(n).queue;
    ky(
      n,
      p,
      r,
      Ee,
      s === null ? gv : function() {
        return Oy(n), s(u);
      }
    );
  }
  function Iy(n) {
    var r = n.memoizedState;
    if (r !== null) return r;
    r = {
      memoizedState: Ee,
      baseState: Ee,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ea,
        lastRenderedState: Ee
      },
      next: null
    };
    var s = {};
    return r.next = {
      memoizedState: s,
      baseState: s,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ea,
        lastRenderedState: s
      },
      next: null
    }, n.memoizedState = r, n = n.alternate, n !== null && (n.memoizedState = r), r;
  }
  function Oy(n) {
    var r = Iy(n);
    r.next === null && (r = n.alternate.memoizedState), rs(
      n,
      r.next.queue,
      {},
      cn()
    );
  }
  function jc() {
    return kt(Ss);
  }
  function xy() {
    return ft().memoizedState;
  }
  function Ly() {
    return ft().memoizedState;
  }
  function hv(n) {
    for (var r = n.return; r !== null; ) {
      switch (r.tag) {
        case 24:
        case 3:
          var s = cn();
          n = _a(s);
          var u = Aa(r, n, s);
          u !== null && (Zt(u, r, s), Ji(u, r, s)), r = { cache: Ec() }, n.payload = r;
          return;
      }
      r = r.return;
    }
  }
  function bv(n, r, s) {
    var u = cn();
    s = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, nl(n) ? My(r, s) : (s = oc(n, r, s, u), s !== null && (Zt(s, n, u), Uy(s, r, u)));
  }
  function Dy(n, r, s) {
    var u = cn();
    rs(n, r, s, u);
  }
  function rs(n, r, s, u) {
    var p = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (nl(n)) My(r, p);
    else {
      var g = n.alternate;
      if (n.lanes === 0 && (g === null || g.lanes === 0) && (g = r.lastRenderedReducer, g !== null))
        try {
          var y = r.lastRenderedState, A = g(y, s);
          if (p.hasEagerState = !0, p.eagerState = A, an(A, y))
            return Uo(n, r, p, 0), nt === null && Mo(), !1;
        } catch {
        } finally {
        }
      if (s = oc(n, r, p, u), s !== null)
        return Zt(s, n, u), Uy(s, r, u), !0;
    }
    return !1;
  }
  function $c(n, r, s, u) {
    if (u = {
      lane: 2,
      revertLane: _d(),
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, nl(n)) {
      if (r) throw Error(i(479));
    } else
      r = oc(
        n,
        s,
        u,
        2
      ), r !== null && Zt(r, n, 2);
  }
  function nl(n) {
    var r = n.alternate;
    return n === Ie || r !== null && r === Ie;
  }
  function My(n, r) {
    Xr = Xo = !0;
    var s = n.pending;
    s === null ? r.next = r : (r.next = s.next, s.next = r), n.pending = r;
  }
  function Uy(n, r, s) {
    if ((s & 4194048) !== 0) {
      var u = r.lanes;
      u &= n.pendingLanes, s |= u, r.lanes = s, zE(n, s);
    }
  }
  var is = {
    readContext: kt,
    use: Qo,
    useCallback: ct,
    useContext: ct,
    useEffect: ct,
    useImperativeHandle: ct,
    useLayoutEffect: ct,
    useInsertionEffect: ct,
    useMemo: ct,
    useReducer: ct,
    useRef: ct,
    useState: ct,
    useDebugValue: ct,
    useDeferredValue: ct,
    useTransition: ct,
    useSyncExternalStore: ct,
    useId: ct,
    useHostTransitionStatus: ct,
    useFormState: ct,
    useActionState: ct,
    useOptimistic: ct,
    useMemoCache: ct,
    useCacheRefresh: ct
  };
  is.useEffectEvent = ct;
  var By = {
    readContext: kt,
    use: Qo,
    useCallback: function(n, r) {
      return zt().memoizedState = [
        n,
        r === void 0 ? null : r
      ], n;
    },
    useContext: kt,
    useEffect: Ty,
    useImperativeHandle: function(n, r, s) {
      s = s != null ? s.concat([n]) : null, el(
        4194308,
        4,
        Ny.bind(null, r, n),
        s
      );
    },
    useLayoutEffect: function(n, r) {
      return el(4194308, 4, n, r);
    },
    useInsertionEffect: function(n, r) {
      el(4, 2, n, r);
    },
    useMemo: function(n, r) {
      var s = zt();
      r = r === void 0 ? null : r;
      var u = n();
      if (or) {
        $t(!0);
        try {
          n();
        } finally {
          $t(!1);
        }
      }
      return s.memoizedState = [u, r], u;
    },
    useReducer: function(n, r, s) {
      var u = zt();
      if (s !== void 0) {
        var p = s(r);
        if (or) {
          $t(!0);
          try {
            s(r);
          } finally {
            $t(!1);
          }
        }
      } else p = r;
      return u.memoizedState = u.baseState = p, n = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: p
      }, u.queue = n, n = n.dispatch = bv.bind(
        null,
        Ie,
        n
      ), [u.memoizedState, n];
    },
    useRef: function(n) {
      var r = zt();
      return n = { current: n }, r.memoizedState = n;
    },
    useState: function(n) {
      n = Bc(n);
      var r = n.queue, s = Dy.bind(null, Ie, r);
      return r.dispatch = s, [n.memoizedState, s];
    },
    useDebugValue: Hc,
    useDeferredValue: function(n, r) {
      var s = zt();
      return zc(s, n, r);
    },
    useTransition: function() {
      var n = Bc(!1);
      return n = ky.bind(
        null,
        Ie,
        n.queue,
        !0,
        !1
      ), zt().memoizedState = n, [!1, n];
    },
    useSyncExternalStore: function(n, r, s) {
      var u = Ie, p = zt();
      if (Ge) {
        if (s === void 0)
          throw Error(i(407));
        s = s();
      } else {
        if (s = r(), nt === null)
          throw Error(i(349));
        (Pe & 127) !== 0 || ry(u, r, s);
      }
      p.memoizedState = s;
      var g = { value: s, getSnapshot: r };
      return p.queue = g, Ty(sy.bind(null, u, g, n), [
        n
      ]), u.flags |= 2048, Zr(
        9,
        { destroy: void 0 },
        iy.bind(
          null,
          u,
          g,
          s,
          r
        ),
        null
      ), s;
    },
    useId: function() {
      var n = zt(), r = nt.identifierPrefix;
      if (Ge) {
        var s = Un, u = Mn;
        s = (u & ~(1 << 32 - tt(u) - 1)).toString(32) + s, r = "_" + r + "R_" + s, s = Ko++, 0 < s && (r += "H" + s.toString(32)), r += "_";
      } else
        s = cv++, r = "_" + r + "r_" + s.toString(32) + "_";
      return n.memoizedState = r;
    },
    useHostTransitionStatus: jc,
    useFormState: gy,
    useActionState: gy,
    useOptimistic: function(n) {
      var r = zt();
      r.memoizedState = r.baseState = n;
      var s = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return r.queue = s, r = $c.bind(
        null,
        Ie,
        !0,
        s
      ), s.dispatch = r, [n, r];
    },
    useMemoCache: Dc,
    useCacheRefresh: function() {
      return zt().memoizedState = hv.bind(
        null,
        Ie
      );
    },
    useEffectEvent: function(n) {
      var r = zt(), s = { impl: n };
      return r.memoizedState = s, function() {
        if ((Ye & 2) !== 0)
          throw Error(i(440));
        return s.impl.apply(void 0, arguments);
      };
    }
  }, qc = {
    readContext: kt,
    use: Qo,
    useCallback: vy,
    useContext: kt,
    useEffect: Pc,
    useImperativeHandle: Ry,
    useInsertionEffect: _y,
    useLayoutEffect: Ay,
    useMemo: Cy,
    useReducer: Jo,
    useRef: yy,
    useState: function() {
      return Jo(ea);
    },
    useDebugValue: Hc,
    useDeferredValue: function(n, r) {
      var s = ft();
      return wy(
        s,
        Qe.memoizedState,
        n,
        r
      );
    },
    useTransition: function() {
      var n = Jo(ea)[0], r = ft().memoizedState;
      return [
        typeof n == "boolean" ? n : as(n),
        r
      ];
    },
    useSyncExternalStore: ay,
    useId: xy,
    useHostTransitionStatus: jc,
    useFormState: hy,
    useActionState: hy,
    useOptimistic: function(n, r) {
      var s = ft();
      return uy(s, Qe, n, r);
    },
    useMemoCache: Dc,
    useCacheRefresh: Ly
  };
  qc.useEffectEvent = Sy;
  var Fy = {
    readContext: kt,
    use: Qo,
    useCallback: vy,
    useContext: kt,
    useEffect: Pc,
    useImperativeHandle: Ry,
    useInsertionEffect: _y,
    useLayoutEffect: Ay,
    useMemo: Cy,
    useReducer: Uc,
    useRef: yy,
    useState: function() {
      return Uc(ea);
    },
    useDebugValue: Hc,
    useDeferredValue: function(n, r) {
      var s = ft();
      return Qe === null ? zc(s, n, r) : wy(
        s,
        Qe.memoizedState,
        n,
        r
      );
    },
    useTransition: function() {
      var n = Uc(ea)[0], r = ft().memoizedState;
      return [
        typeof n == "boolean" ? n : as(n),
        r
      ];
    },
    useSyncExternalStore: ay,
    useId: xy,
    useHostTransitionStatus: jc,
    useFormState: Ey,
    useActionState: Ey,
    useOptimistic: function(n, r) {
      var s = ft();
      return Qe !== null ? uy(s, Qe, n, r) : (s.baseState = n, [n, s.queue.dispatch]);
    },
    useMemoCache: Dc,
    useCacheRefresh: Ly
  };
  Fy.useEffectEvent = Sy;
  function Yc(n, r, s, u) {
    r = n.memoizedState, s = s(u, r), s = s == null ? r : E({}, r, s), n.memoizedState = s, n.lanes === 0 && (n.updateQueue.baseState = s);
  }
  var Vc = {
    enqueueSetState: function(n, r, s) {
      n = n._reactInternals;
      var u = cn(), p = _a(u);
      p.payload = r, s != null && (p.callback = s), r = Aa(n, p, u), r !== null && (Zt(r, n, u), Ji(r, n, u));
    },
    enqueueReplaceState: function(n, r, s) {
      n = n._reactInternals;
      var u = cn(), p = _a(u);
      p.tag = 1, p.payload = r, s != null && (p.callback = s), r = Aa(n, p, u), r !== null && (Zt(r, n, u), Ji(r, n, u));
    },
    enqueueForceUpdate: function(n, r) {
      n = n._reactInternals;
      var s = cn(), u = _a(s);
      u.tag = 2, r != null && (u.callback = r), r = Aa(n, u, s), r !== null && (Zt(r, n, s), Ji(r, n, s));
    }
  };
  function Py(n, r, s, u, p, g, y) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(u, g, y) : r.prototype && r.prototype.isPureReactComponent ? !qi(s, u) || !qi(p, g) : !0;
  }
  function Hy(n, r, s, u) {
    n = r.state, typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(s, u), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(s, u), r.state !== n && Vc.enqueueReplaceState(r, r.state, null);
  }
  function lr(n, r) {
    var s = r;
    if ("ref" in r) {
      s = {};
      for (var u in r)
        u !== "ref" && (s[u] = r[u]);
    }
    if (n = n.defaultProps) {
      s === r && (s = E({}, s));
      for (var p in n)
        s[p] === void 0 && (s[p] = n[p]);
    }
    return s;
  }
  function zy(n) {
    Do(n);
  }
  function Gy(n) {
    console.error(n);
  }
  function jy(n) {
    Do(n);
  }
  function al(n, r) {
    try {
      var s = n.onUncaughtError;
      s(r.value, { componentStack: r.stack });
    } catch (u) {
      setTimeout(function() {
        throw u;
      });
    }
  }
  function $y(n, r, s) {
    try {
      var u = n.onCaughtError;
      u(s.value, {
        componentStack: s.stack,
        errorBoundary: r.tag === 1 ? r.stateNode : null
      });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function Wc(n, r, s) {
    return s = _a(s), s.tag = 3, s.payload = { element: null }, s.callback = function() {
      al(n, r);
    }, s;
  }
  function qy(n) {
    return n = _a(n), n.tag = 3, n;
  }
  function Yy(n, r, s, u) {
    var p = s.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var g = u.value;
      n.payload = function() {
        return p(g);
      }, n.callback = function() {
        $y(r, s, u);
      };
    }
    var y = s.stateNode;
    y !== null && typeof y.componentDidCatch == "function" && (n.callback = function() {
      $y(r, s, u), typeof p != "function" && (ka === null ? ka = /* @__PURE__ */ new Set([this]) : ka.add(this));
      var A = u.stack;
      this.componentDidCatch(u.value, {
        componentStack: A !== null ? A : ""
      });
    });
  }
  function Ev(n, r, s, u, p) {
    if (s.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
      if (r = s.alternate, r !== null && jr(
        r,
        s,
        p,
        !0
      ), s = sn.current, s !== null) {
        switch (s.tag) {
          case 31:
          case 13:
            return Tn === null ? gl() : s.alternate === null && dt === 0 && (dt = 3), s.flags &= -257, s.flags |= 65536, s.lanes = p, u === $o ? s.flags |= 16384 : (r = s.updateQueue, r === null ? s.updateQueue = /* @__PURE__ */ new Set([u]) : r.add(u), yd(n, u, p)), !1;
          case 22:
            return s.flags |= 65536, u === $o ? s.flags |= 16384 : (r = s.updateQueue, r === null ? (r = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([u])
            }, s.updateQueue = r) : (s = r.retryQueue, s === null ? r.retryQueue = /* @__PURE__ */ new Set([u]) : s.add(u)), yd(n, u, p)), !1;
        }
        throw Error(i(435, s.tag));
      }
      return yd(n, u, p), gl(), !1;
    }
    if (Ge)
      return r = sn.current, r !== null ? ((r.flags & 65536) === 0 && (r.flags |= 256), r.flags |= 65536, r.lanes = p, u !== fc && (n = Error(i(422), { cause: u }), Wi(hn(n, s)))) : (u !== fc && (r = Error(i(423), {
        cause: u
      }), Wi(
        hn(r, s)
      )), n = n.current.alternate, n.flags |= 65536, p &= -p, n.lanes |= p, u = hn(u, s), p = Wc(
        n.stateNode,
        u,
        p
      ), Nc(n, p), dt !== 4 && (dt = 2)), !1;
    var g = Error(i(520), { cause: u });
    if (g = hn(g, s), fs === null ? fs = [g] : fs.push(g), dt !== 4 && (dt = 2), r === null) return !0;
    u = hn(u, s), s = r;
    do {
      switch (s.tag) {
        case 3:
          return s.flags |= 65536, n = p & -p, s.lanes |= n, n = Wc(s.stateNode, u, n), Nc(s, n), !1;
        case 1:
          if (r = s.type, g = s.stateNode, (s.flags & 128) === 0 && (typeof r.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (ka === null || !ka.has(g))))
            return s.flags |= 65536, p &= -p, s.lanes |= p, p = qy(p), Yy(
              p,
              n,
              s,
              u
            ), Nc(s, p), !1;
      }
      s = s.return;
    } while (s !== null);
    return !1;
  }
  var Xc = Error(i(461)), bt = !1;
  function It(n, r, s, u) {
    r.child = n === null ? K0(r, null, s, u) : sr(
      r,
      n.child,
      s,
      u
    );
  }
  function Vy(n, r, s, u, p) {
    s = s.render;
    var g = r.ref;
    if ("ref" in u) {
      var y = {};
      for (var A in u)
        A !== "ref" && (y[A] = u[A]);
    } else y = u;
    return nr(r), u = Ic(
      n,
      r,
      s,
      y,
      g,
      p
    ), A = Oc(), n !== null && !bt ? (xc(n, r, p), ta(n, r, p)) : (Ge && A && dc(r), r.flags |= 1, It(n, r, u, p), r.child);
  }
  function Wy(n, r, s, u, p) {
    if (n === null) {
      var g = s.type;
      return typeof g == "function" && !lc(g) && g.defaultProps === void 0 && s.compare === null ? (r.tag = 15, r.type = g, Xy(
        n,
        r,
        g,
        u,
        p
      )) : (n = Fo(
        s.type,
        null,
        u,
        r,
        r.mode,
        p
      ), n.ref = r.ref, n.return = r, r.child = n);
    }
    if (g = n.child, !ad(n, p)) {
      var y = g.memoizedProps;
      if (s = s.compare, s = s !== null ? s : qi, s(y, u) && n.ref === r.ref)
        return ta(n, r, p);
    }
    return r.flags |= 1, n = Xn(g, u), n.ref = r.ref, n.return = r, r.child = n;
  }
  function Xy(n, r, s, u, p) {
    if (n !== null) {
      var g = n.memoizedProps;
      if (qi(g, u) && n.ref === r.ref)
        if (bt = !1, r.pendingProps = u = g, ad(n, p))
          (n.flags & 131072) !== 0 && (bt = !0);
        else
          return r.lanes = n.lanes, ta(n, r, p);
    }
    return Kc(
      n,
      r,
      s,
      u,
      p
    );
  }
  function Ky(n, r, s, u) {
    var p = u.children, g = n !== null ? n.memoizedState : null;
    if (n === null && r.stateNode === null && (r.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), u.mode === "hidden") {
      if ((r.flags & 128) !== 0) {
        if (g = g !== null ? g.baseLanes | s : s, n !== null) {
          for (u = r.child = n.child, p = 0; u !== null; )
            p = p | u.lanes | u.childLanes, u = u.sibling;
          u = p & ~g;
        } else u = 0, r.child = null;
        return Zy(
          n,
          r,
          g,
          s,
          u
        );
      }
      if ((s & 536870912) !== 0)
        r.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && Go(
          r,
          g !== null ? g.cachePool : null
        ), g !== null ? J0(r, g) : vc(), ey(r);
      else
        return u = r.lanes = 536870912, Zy(
          n,
          r,
          g !== null ? g.baseLanes | s : s,
          s,
          u
        );
    } else
      g !== null ? (Go(r, g.cachePool), J0(r, g), Ra(), r.memoizedState = null) : (n !== null && Go(r, null), vc(), Ra());
    return It(n, r, p, s), r.child;
  }
  function ss(n, r) {
    return n !== null && n.tag === 22 || r.stateNode !== null || (r.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), r.sibling;
  }
  function Zy(n, r, s, u, p) {
    var g = Tc();
    return g = g === null ? null : { parent: gt._currentValue, pool: g }, r.memoizedState = {
      baseLanes: s,
      cachePool: g
    }, n !== null && Go(r, null), vc(), ey(r), n !== null && jr(n, r, u, !0), r.childLanes = p, null;
  }
  function rl(n, r) {
    return r = sl(
      { mode: r.mode, children: r.children },
      n.mode
    ), r.ref = n.ref, n.child = r, r.return = n, r;
  }
  function Qy(n, r, s) {
    return sr(r, n.child, null, s), n = rl(r, r.pendingProps), n.flags |= 2, on(r), r.memoizedState = null, n;
  }
  function yv(n, r, s) {
    var u = r.pendingProps, p = (r.flags & 128) !== 0;
    if (r.flags &= -129, n === null) {
      if (Ge) {
        if (u.mode === "hidden")
          return n = rl(r, u), r.lanes = 536870912, ss(null, n);
        if (wc(r), (n = it) ? (n = cS(
          n,
          yn
        ), n = n !== null && n.data === "&" ? n : null, n !== null && (r.memoizedState = {
          dehydrated: n,
          treeContext: ba !== null ? { id: Mn, overflow: Un } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = M0(n), s.return = r, r.child = s, wt = r, it = null)) : n = null, n === null) throw ya(r);
        return r.lanes = 536870912, null;
      }
      return rl(r, u);
    }
    var g = n.memoizedState;
    if (g !== null) {
      var y = g.dehydrated;
      if (wc(r), p)
        if (r.flags & 256)
          r.flags &= -257, r = Qy(
            n,
            r,
            s
          );
        else if (r.memoizedState !== null)
          r.child = n.child, r.flags |= 128, r = null;
        else throw Error(i(558));
      else if (bt || jr(n, r, s, !1), p = (s & n.childLanes) !== 0, bt || p) {
        if (u = nt, u !== null && (y = GE(u, s), y !== 0 && y !== g.retryLane))
          throw g.retryLane = y, Qa(n, y), Zt(u, n, y), Xc;
        gl(), r = Qy(
          n,
          r,
          s
        );
      } else
        n = g.treeContext, it = Sn(y.nextSibling), wt = r, Ge = !0, Ea = null, yn = !1, n !== null && F0(r, n), r = rl(r, u), r.flags |= 4096;
      return r;
    }
    return n = Xn(n.child, {
      mode: u.mode,
      children: u.children
    }), n.ref = r.ref, r.child = n, n.return = r, n;
  }
  function il(n, r) {
    var s = r.ref;
    if (s === null)
      n !== null && n.ref !== null && (r.flags |= 4194816);
    else {
      if (typeof s != "function" && typeof s != "object")
        throw Error(i(284));
      (n === null || n.ref !== s) && (r.flags |= 4194816);
    }
  }
  function Kc(n, r, s, u, p) {
    return nr(r), s = Ic(
      n,
      r,
      s,
      u,
      void 0,
      p
    ), u = Oc(), n !== null && !bt ? (xc(n, r, p), ta(n, r, p)) : (Ge && u && dc(r), r.flags |= 1, It(n, r, s, p), r.child);
  }
  function Jy(n, r, s, u, p, g) {
    return nr(r), r.updateQueue = null, s = ny(
      r,
      u,
      s,
      p
    ), ty(n), u = Oc(), n !== null && !bt ? (xc(n, r, g), ta(n, r, g)) : (Ge && u && dc(r), r.flags |= 1, It(n, r, s, g), r.child);
  }
  function eT(n, r, s, u, p) {
    if (nr(r), r.stateNode === null) {
      var g = Pr, y = s.contextType;
      typeof y == "object" && y !== null && (g = kt(y)), g = new s(u, g), r.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = Vc, r.stateNode = g, g._reactInternals = r, g = r.stateNode, g.props = u, g.state = r.memoizedState, g.refs = {}, _c(r), y = s.contextType, g.context = typeof y == "object" && y !== null ? kt(y) : Pr, g.state = r.memoizedState, y = s.getDerivedStateFromProps, typeof y == "function" && (Yc(
        r,
        s,
        y,
        u
      ), g.state = r.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (y = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), y !== g.state && Vc.enqueueReplaceState(g, g.state, null), ts(r, u, g, p), es(), g.state = r.memoizedState), typeof g.componentDidMount == "function" && (r.flags |= 4194308), u = !0;
    } else if (n === null) {
      g = r.stateNode;
      var A = r.memoizedProps, P = lr(s, A);
      g.props = P;
      var X = g.context, re = s.contextType;
      y = Pr, typeof re == "object" && re !== null && (y = kt(re));
      var le = s.getDerivedStateFromProps;
      re = typeof le == "function" || typeof g.getSnapshotBeforeUpdate == "function", A = r.pendingProps !== A, re || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (A || X !== y) && Hy(
        r,
        g,
        u,
        y
      ), Sa = !1;
      var Z = r.memoizedState;
      g.state = Z, ts(r, u, g, p), es(), X = r.memoizedState, A || Z !== X || Sa ? (typeof le == "function" && (Yc(
        r,
        s,
        le,
        u
      ), X = r.memoizedState), (P = Sa || Py(
        r,
        s,
        P,
        u,
        Z,
        X,
        y
      )) ? (re || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (r.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (r.flags |= 4194308), r.memoizedProps = u, r.memoizedState = X), g.props = u, g.state = X, g.context = y, u = P) : (typeof g.componentDidMount == "function" && (r.flags |= 4194308), u = !1);
    } else {
      g = r.stateNode, Ac(n, r), y = r.memoizedProps, re = lr(s, y), g.props = re, le = r.pendingProps, Z = g.context, X = s.contextType, P = Pr, typeof X == "object" && X !== null && (P = kt(X)), A = s.getDerivedStateFromProps, (X = typeof A == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (y !== le || Z !== P) && Hy(
        r,
        g,
        u,
        P
      ), Sa = !1, Z = r.memoizedState, g.state = Z, ts(r, u, g, p), es();
      var J = r.memoizedState;
      y !== le || Z !== J || Sa || n !== null && n.dependencies !== null && Ho(n.dependencies) ? (typeof A == "function" && (Yc(
        r,
        s,
        A,
        u
      ), J = r.memoizedState), (re = Sa || Py(
        r,
        s,
        re,
        u,
        Z,
        J,
        P
      ) || n !== null && n.dependencies !== null && Ho(n.dependencies)) ? (X || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(u, J, P), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(
        u,
        J,
        P
      )), typeof g.componentDidUpdate == "function" && (r.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (r.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || y === n.memoizedProps && Z === n.memoizedState || (r.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || y === n.memoizedProps && Z === n.memoizedState || (r.flags |= 1024), r.memoizedProps = u, r.memoizedState = J), g.props = u, g.state = J, g.context = P, u = re) : (typeof g.componentDidUpdate != "function" || y === n.memoizedProps && Z === n.memoizedState || (r.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || y === n.memoizedProps && Z === n.memoizedState || (r.flags |= 1024), u = !1);
    }
    return g = u, il(n, r), u = (r.flags & 128) !== 0, g || u ? (g = r.stateNode, s = u && typeof s.getDerivedStateFromError != "function" ? null : g.render(), r.flags |= 1, n !== null && u ? (r.child = sr(
      r,
      n.child,
      null,
      p
    ), r.child = sr(
      r,
      null,
      s,
      p
    )) : It(n, r, s, p), r.memoizedState = g.state, n = r.child) : n = ta(
      n,
      r,
      p
    ), n;
  }
  function tT(n, r, s, u) {
    return er(), r.flags |= 256, It(n, r, s, u), r.child;
  }
  var Zc = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Qc(n) {
    return { baseLanes: n, cachePool: $0() };
  }
  function Jc(n, r, s) {
    return n = n !== null ? n.childLanes & ~s : 0, r && (n |= un), n;
  }
  function nT(n, r, s) {
    var u = r.pendingProps, p = !1, g = (r.flags & 128) !== 0, y;
    if ((y = g) || (y = n !== null && n.memoizedState === null ? !1 : (pt.current & 2) !== 0), y && (p = !0, r.flags &= -129), y = (r.flags & 32) !== 0, r.flags &= -33, n === null) {
      if (Ge) {
        if (p ? Na(r) : Ra(), (n = it) ? (n = cS(
          n,
          yn
        ), n = n !== null && n.data !== "&" ? n : null, n !== null && (r.memoizedState = {
          dehydrated: n,
          treeContext: ba !== null ? { id: Mn, overflow: Un } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = M0(n), s.return = r, r.child = s, wt = r, it = null)) : n = null, n === null) throw ya(r);
        return Md(n) ? r.lanes = 32 : r.lanes = 536870912, null;
      }
      var A = u.children;
      return u = u.fallback, p ? (Ra(), p = r.mode, A = sl(
        { mode: "hidden", children: A },
        p
      ), u = Ja(
        u,
        p,
        s,
        null
      ), A.return = r, u.return = r, A.sibling = u, r.child = A, u = r.child, u.memoizedState = Qc(s), u.childLanes = Jc(
        n,
        y,
        s
      ), r.memoizedState = Zc, ss(null, u)) : (Na(r), ed(r, A));
    }
    var P = n.memoizedState;
    if (P !== null && (A = P.dehydrated, A !== null)) {
      if (g)
        r.flags & 256 ? (Na(r), r.flags &= -257, r = td(
          n,
          r,
          s
        )) : r.memoizedState !== null ? (Ra(), r.child = n.child, r.flags |= 128, r = null) : (Ra(), A = u.fallback, p = r.mode, u = sl(
          { mode: "visible", children: u.children },
          p
        ), A = Ja(
          A,
          p,
          s,
          null
        ), A.flags |= 2, u.return = r, A.return = r, u.sibling = A, r.child = u, sr(
          r,
          n.child,
          null,
          s
        ), u = r.child, u.memoizedState = Qc(s), u.childLanes = Jc(
          n,
          y,
          s
        ), r.memoizedState = Zc, r = ss(null, u));
      else if (Na(r), Md(A)) {
        if (y = A.nextSibling && A.nextSibling.dataset, y) var X = y.dgst;
        y = X, u = Error(i(419)), u.stack = "", u.digest = y, Wi({ value: u, source: null, stack: null }), r = td(
          n,
          r,
          s
        );
      } else if (bt || jr(n, r, s, !1), y = (s & n.childLanes) !== 0, bt || y) {
        if (y = nt, y !== null && (u = GE(y, s), u !== 0 && u !== P.retryLane))
          throw P.retryLane = u, Qa(n, u), Zt(y, n, u), Xc;
        Dd(A) || gl(), r = td(
          n,
          r,
          s
        );
      } else
        Dd(A) ? (r.flags |= 192, r.child = n.child, r = null) : (n = P.treeContext, it = Sn(
          A.nextSibling
        ), wt = r, Ge = !0, Ea = null, yn = !1, n !== null && F0(r, n), r = ed(
          r,
          u.children
        ), r.flags |= 4096);
      return r;
    }
    return p ? (Ra(), A = u.fallback, p = r.mode, P = n.child, X = P.sibling, u = Xn(P, {
      mode: "hidden",
      children: u.children
    }), u.subtreeFlags = P.subtreeFlags & 65011712, X !== null ? A = Xn(
      X,
      A
    ) : (A = Ja(
      A,
      p,
      s,
      null
    ), A.flags |= 2), A.return = r, u.return = r, u.sibling = A, r.child = u, ss(null, u), u = r.child, A = n.child.memoizedState, A === null ? A = Qc(s) : (p = A.cachePool, p !== null ? (P = gt._currentValue, p = p.parent !== P ? { parent: P, pool: P } : p) : p = $0(), A = {
      baseLanes: A.baseLanes | s,
      cachePool: p
    }), u.memoizedState = A, u.childLanes = Jc(
      n,
      y,
      s
    ), r.memoizedState = Zc, ss(n.child, u)) : (Na(r), s = n.child, n = s.sibling, s = Xn(s, {
      mode: "visible",
      children: u.children
    }), s.return = r, s.sibling = null, n !== null && (y = r.deletions, y === null ? (r.deletions = [n], r.flags |= 16) : y.push(n)), r.child = s, r.memoizedState = null, s);
  }
  function ed(n, r) {
    return r = sl(
      { mode: "visible", children: r },
      n.mode
    ), r.return = n, n.child = r;
  }
  function sl(n, r) {
    return n = rn(22, n, null, r), n.lanes = 0, n;
  }
  function td(n, r, s) {
    return sr(r, n.child, null, s), n = ed(
      r,
      r.pendingProps.children
    ), n.flags |= 2, r.memoizedState = null, n;
  }
  function aT(n, r, s) {
    n.lanes |= r;
    var u = n.alternate;
    u !== null && (u.lanes |= r), hc(n.return, r, s);
  }
  function nd(n, r, s, u, p, g) {
    var y = n.memoizedState;
    y === null ? n.memoizedState = {
      isBackwards: r,
      rendering: null,
      renderingStartTime: 0,
      last: u,
      tail: s,
      tailMode: p,
      treeForkCount: g
    } : (y.isBackwards = r, y.rendering = null, y.renderingStartTime = 0, y.last = u, y.tail = s, y.tailMode = p, y.treeForkCount = g);
  }
  function rT(n, r, s) {
    var u = r.pendingProps, p = u.revealOrder, g = u.tail;
    u = u.children;
    var y = pt.current, A = (y & 2) !== 0;
    if (A ? (y = y & 1 | 2, r.flags |= 128) : y &= 1, v(pt, y), It(n, r, u, s), u = Ge ? Vi : 0, !A && n !== null && (n.flags & 128) !== 0)
      e: for (n = r.child; n !== null; ) {
        if (n.tag === 13)
          n.memoizedState !== null && aT(n, s, r);
        else if (n.tag === 19)
          aT(n, s, r);
        else if (n.child !== null) {
          n.child.return = n, n = n.child;
          continue;
        }
        if (n === r) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === r)
            break e;
          n = n.return;
        }
        n.sibling.return = n.return, n = n.sibling;
      }
    switch (p) {
      case "forwards":
        for (s = r.child, p = null; s !== null; )
          n = s.alternate, n !== null && Wo(n) === null && (p = s), s = s.sibling;
        s = p, s === null ? (p = r.child, r.child = null) : (p = s.sibling, s.sibling = null), nd(
          r,
          !1,
          p,
          s,
          g,
          u
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (s = null, p = r.child, r.child = null; p !== null; ) {
          if (n = p.alternate, n !== null && Wo(n) === null) {
            r.child = p;
            break;
          }
          n = p.sibling, p.sibling = s, s = p, p = n;
        }
        nd(
          r,
          !0,
          s,
          null,
          g,
          u
        );
        break;
      case "together":
        nd(
          r,
          !1,
          null,
          null,
          void 0,
          u
        );
        break;
      default:
        r.memoizedState = null;
    }
    return r.child;
  }
  function ta(n, r, s) {
    if (n !== null && (r.dependencies = n.dependencies), wa |= r.lanes, (s & r.childLanes) === 0)
      if (n !== null) {
        if (jr(
          n,
          r,
          s,
          !1
        ), (s & r.childLanes) === 0)
          return null;
      } else return null;
    if (n !== null && r.child !== n.child)
      throw Error(i(153));
    if (r.child !== null) {
      for (n = r.child, s = Xn(n, n.pendingProps), r.child = s, s.return = r; n.sibling !== null; )
        n = n.sibling, s = s.sibling = Xn(n, n.pendingProps), s.return = r;
      s.sibling = null;
    }
    return r.child;
  }
  function ad(n, r) {
    return (n.lanes & r) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && Ho(n)));
  }
  function Tv(n, r, s) {
    switch (r.tag) {
      case 3:
        Ze(r, r.stateNode.containerInfo), Ta(r, gt, n.memoizedState.cache), er();
        break;
      case 27:
      case 5:
        jt(r);
        break;
      case 4:
        Ze(r, r.stateNode.containerInfo);
        break;
      case 10:
        Ta(
          r,
          r.type,
          r.memoizedProps.value
        );
        break;
      case 31:
        if (r.memoizedState !== null)
          return r.flags |= 128, wc(r), null;
        break;
      case 13:
        var u = r.memoizedState;
        if (u !== null)
          return u.dehydrated !== null ? (Na(r), r.flags |= 128, null) : (s & r.child.childLanes) !== 0 ? nT(n, r, s) : (Na(r), n = ta(
            n,
            r,
            s
          ), n !== null ? n.sibling : null);
        Na(r);
        break;
      case 19:
        var p = (n.flags & 128) !== 0;
        if (u = (s & r.childLanes) !== 0, u || (jr(
          n,
          r,
          s,
          !1
        ), u = (s & r.childLanes) !== 0), p) {
          if (u)
            return rT(
              n,
              r,
              s
            );
          r.flags |= 128;
        }
        if (p = r.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), v(pt, pt.current), u) break;
        return null;
      case 22:
        return r.lanes = 0, Ky(
          n,
          r,
          s,
          r.pendingProps
        );
      case 24:
        Ta(r, gt, n.memoizedState.cache);
    }
    return ta(n, r, s);
  }
  function iT(n, r, s) {
    if (n !== null)
      if (n.memoizedProps !== r.pendingProps)
        bt = !0;
      else {
        if (!ad(n, s) && (r.flags & 128) === 0)
          return bt = !1, Tv(
            n,
            r,
            s
          );
        bt = (n.flags & 131072) !== 0;
      }
    else
      bt = !1, Ge && (r.flags & 1048576) !== 0 && B0(r, Vi, r.index);
    switch (r.lanes = 0, r.tag) {
      case 16:
        e: {
          var u = r.pendingProps;
          if (n = rr(r.elementType), r.type = n, typeof n == "function")
            lc(n) ? (u = lr(n, u), r.tag = 1, r = eT(
              null,
              r,
              n,
              u,
              s
            )) : (r.tag = 0, r = Kc(
              null,
              r,
              n,
              u,
              s
            ));
          else {
            if (n != null) {
              var p = n.$$typeof;
              if (p === Y) {
                r.tag = 11, r = Vy(
                  null,
                  r,
                  n,
                  u,
                  s
                );
                break e;
              } else if (p === G) {
                r.tag = 14, r = Wy(
                  null,
                  r,
                  n,
                  u,
                  s
                );
                break e;
              }
            }
            throw r = de(n) || n, Error(i(306, r, ""));
          }
        }
        return r;
      case 0:
        return Kc(
          n,
          r,
          r.type,
          r.pendingProps,
          s
        );
      case 1:
        return u = r.type, p = lr(
          u,
          r.pendingProps
        ), eT(
          n,
          r,
          u,
          p,
          s
        );
      case 3:
        e: {
          if (Ze(
            r,
            r.stateNode.containerInfo
          ), n === null) throw Error(i(387));
          u = r.pendingProps;
          var g = r.memoizedState;
          p = g.element, Ac(n, r), ts(r, u, null, s);
          var y = r.memoizedState;
          if (u = y.cache, Ta(r, gt, u), u !== g.cache && bc(
            r,
            [gt],
            s,
            !0
          ), es(), u = y.element, g.isDehydrated)
            if (g = {
              element: u,
              isDehydrated: !1,
              cache: y.cache
            }, r.updateQueue.baseState = g, r.memoizedState = g, r.flags & 256) {
              r = tT(
                n,
                r,
                u,
                s
              );
              break e;
            } else if (u !== p) {
              p = hn(
                Error(i(424)),
                r
              ), Wi(p), r = tT(
                n,
                r,
                u,
                s
              );
              break e;
            } else {
              switch (n = r.stateNode.containerInfo, n.nodeType) {
                case 9:
                  n = n.body;
                  break;
                default:
                  n = n.nodeName === "HTML" ? n.ownerDocument.body : n;
              }
              for (it = Sn(n.firstChild), wt = r, Ge = !0, Ea = null, yn = !0, s = K0(
                r,
                null,
                u,
                s
              ), r.child = s; s; )
                s.flags = s.flags & -3 | 4096, s = s.sibling;
            }
          else {
            if (er(), u === p) {
              r = ta(
                n,
                r,
                s
              );
              break e;
            }
            It(n, r, u, s);
          }
          r = r.child;
        }
        return r;
      case 26:
        return il(n, r), n === null ? (s = hS(
          r.type,
          null,
          r.pendingProps,
          null
        )) ? r.memoizedState = s : Ge || (s = r.type, n = r.pendingProps, u = _l(
          _e.current
        ).createElement(s), u[Ct] = r, u[qt] = n, Ot(u, s, n), _t(u), r.stateNode = u) : r.memoizedState = hS(
          r.type,
          n.memoizedProps,
          r.pendingProps,
          n.memoizedState
        ), null;
      case 27:
        return jt(r), n === null && Ge && (u = r.stateNode = fS(
          r.type,
          r.pendingProps,
          _e.current
        ), wt = r, yn = !0, p = it, La(r.type) ? (Ud = p, it = Sn(u.firstChild)) : it = p), It(
          n,
          r,
          r.pendingProps.children,
          s
        ), il(n, r), n === null && (r.flags |= 4194304), r.child;
      case 5:
        return n === null && Ge && ((p = u = it) && (u = Kv(
          u,
          r.type,
          r.pendingProps,
          yn
        ), u !== null ? (r.stateNode = u, wt = r, it = Sn(u.firstChild), yn = !1, p = !0) : p = !1), p || ya(r)), jt(r), p = r.type, g = r.pendingProps, y = n !== null ? n.memoizedProps : null, u = g.children, Od(p, g) ? u = null : y !== null && Od(p, y) && (r.flags |= 32), r.memoizedState !== null && (p = Ic(
          n,
          r,
          dv,
          null,
          null,
          s
        ), Ss._currentValue = p), il(n, r), It(n, r, u, s), r.child;
      case 6:
        return n === null && Ge && ((n = s = it) && (s = Zv(
          s,
          r.pendingProps,
          yn
        ), s !== null ? (r.stateNode = s, wt = r, it = null, n = !0) : n = !1), n || ya(r)), null;
      case 13:
        return nT(n, r, s);
      case 4:
        return Ze(
          r,
          r.stateNode.containerInfo
        ), u = r.pendingProps, n === null ? r.child = sr(
          r,
          null,
          u,
          s
        ) : It(n, r, u, s), r.child;
      case 11:
        return Vy(
          n,
          r,
          r.type,
          r.pendingProps,
          s
        );
      case 7:
        return It(
          n,
          r,
          r.pendingProps,
          s
        ), r.child;
      case 8:
        return It(
          n,
          r,
          r.pendingProps.children,
          s
        ), r.child;
      case 12:
        return It(
          n,
          r,
          r.pendingProps.children,
          s
        ), r.child;
      case 10:
        return u = r.pendingProps, Ta(r, r.type, u.value), It(n, r, u.children, s), r.child;
      case 9:
        return p = r.type._context, u = r.pendingProps.children, nr(r), p = kt(p), u = u(p), r.flags |= 1, It(n, r, u, s), r.child;
      case 14:
        return Wy(
          n,
          r,
          r.type,
          r.pendingProps,
          s
        );
      case 15:
        return Xy(
          n,
          r,
          r.type,
          r.pendingProps,
          s
        );
      case 19:
        return rT(n, r, s);
      case 31:
        return yv(n, r, s);
      case 22:
        return Ky(
          n,
          r,
          s,
          r.pendingProps
        );
      case 24:
        return nr(r), u = kt(gt), n === null ? (p = Tc(), p === null && (p = nt, g = Ec(), p.pooledCache = g, g.refCount++, g !== null && (p.pooledCacheLanes |= s), p = g), r.memoizedState = { parent: u, cache: p }, _c(r), Ta(r, gt, p)) : ((n.lanes & s) !== 0 && (Ac(n, r), ts(r, null, null, s), es()), p = n.memoizedState, g = r.memoizedState, p.parent !== u ? (p = { parent: u, cache: u }, r.memoizedState = p, r.lanes === 0 && (r.memoizedState = r.updateQueue.baseState = p), Ta(r, gt, u)) : (u = g.cache, Ta(r, gt, u), u !== p.cache && bc(
          r,
          [gt],
          s,
          !0
        ))), It(
          n,
          r,
          r.pendingProps.children,
          s
        ), r.child;
      case 29:
        throw r.pendingProps;
    }
    throw Error(i(156, r.tag));
  }
  function na(n) {
    n.flags |= 4;
  }
  function rd(n, r, s, u, p) {
    if ((r = (n.mode & 32) !== 0) && (r = !1), r) {
      if (n.flags |= 16777216, (p & 335544128) === p)
        if (n.stateNode.complete) n.flags |= 8192;
        else if (xT()) n.flags |= 8192;
        else
          throw ir = $o, Sc;
    } else n.flags &= -16777217;
  }
  function sT(n, r) {
    if (r.type !== "stylesheet" || (r.state.loading & 4) !== 0)
      n.flags &= -16777217;
    else if (n.flags |= 16777216, !SS(r))
      if (xT()) n.flags |= 8192;
      else
        throw ir = $o, Sc;
  }
  function ol(n, r) {
    r !== null && (n.flags |= 4), n.flags & 16384 && (r = n.tag !== 22 ? PE() : 536870912, n.lanes |= r, ti |= r);
  }
  function os(n, r) {
    if (!Ge)
      switch (n.tailMode) {
        case "hidden":
          r = n.tail;
          for (var s = null; r !== null; )
            r.alternate !== null && (s = r), r = r.sibling;
          s === null ? n.tail = null : s.sibling = null;
          break;
        case "collapsed":
          s = n.tail;
          for (var u = null; s !== null; )
            s.alternate !== null && (u = s), s = s.sibling;
          u === null ? r || n.tail === null ? n.tail = null : n.tail.sibling = null : u.sibling = null;
      }
  }
  function st(n) {
    var r = n.alternate !== null && n.alternate.child === n.child, s = 0, u = 0;
    if (r)
      for (var p = n.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags & 65011712, u |= p.flags & 65011712, p.return = n, p = p.sibling;
    else
      for (p = n.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags, u |= p.flags, p.return = n, p = p.sibling;
    return n.subtreeFlags |= u, n.childLanes = s, r;
  }
  function Sv(n, r, s) {
    var u = r.pendingProps;
    switch (pc(r), r.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return st(r), null;
      case 1:
        return st(r), null;
      case 3:
        return s = r.stateNode, u = null, n !== null && (u = n.memoizedState.cache), r.memoizedState.cache !== u && (r.flags |= 2048), Qn(gt), Ve(), s.pendingContext && (s.context = s.pendingContext, s.pendingContext = null), (n === null || n.child === null) && (Gr(r) ? na(r) : n === null || n.memoizedState.isDehydrated && (r.flags & 256) === 0 || (r.flags |= 1024, mc())), st(r), null;
      case 26:
        var p = r.type, g = r.memoizedState;
        return n === null ? (na(r), g !== null ? (st(r), sT(r, g)) : (st(r), rd(
          r,
          p,
          null,
          u,
          s
        ))) : g ? g !== n.memoizedState ? (na(r), st(r), sT(r, g)) : (st(r), r.flags &= -16777217) : (n = n.memoizedProps, n !== u && na(r), st(r), rd(
          r,
          p,
          n,
          u,
          s
        )), null;
      case 27:
        if (vn(r), s = _e.current, p = r.type, n !== null && r.stateNode != null)
          n.memoizedProps !== u && na(r);
        else {
          if (!u) {
            if (r.stateNode === null)
              throw Error(i(166));
            return st(r), null;
          }
          n = he.current, Gr(r) ? P0(r) : (n = fS(p, u, s), r.stateNode = n, na(r));
        }
        return st(r), null;
      case 5:
        if (vn(r), p = r.type, n !== null && r.stateNode != null)
          n.memoizedProps !== u && na(r);
        else {
          if (!u) {
            if (r.stateNode === null)
              throw Error(i(166));
            return st(r), null;
          }
          if (g = he.current, Gr(r))
            P0(r);
          else {
            var y = _l(
              _e.current
            );
            switch (g) {
              case 1:
                g = y.createElementNS(
                  "http://www.w3.org/2000/svg",
                  p
                );
                break;
              case 2:
                g = y.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  p
                );
                break;
              default:
                switch (p) {
                  case "svg":
                    g = y.createElementNS(
                      "http://www.w3.org/2000/svg",
                      p
                    );
                    break;
                  case "math":
                    g = y.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      p
                    );
                    break;
                  case "script":
                    g = y.createElement("div"), g.innerHTML = "<script><\/script>", g = g.removeChild(
                      g.firstChild
                    );
                    break;
                  case "select":
                    g = typeof u.is == "string" ? y.createElement("select", {
                      is: u.is
                    }) : y.createElement("select"), u.multiple ? g.multiple = !0 : u.size && (g.size = u.size);
                    break;
                  default:
                    g = typeof u.is == "string" ? y.createElement(p, { is: u.is }) : y.createElement(p);
                }
            }
            g[Ct] = r, g[qt] = u;
            e: for (y = r.child; y !== null; ) {
              if (y.tag === 5 || y.tag === 6)
                g.appendChild(y.stateNode);
              else if (y.tag !== 4 && y.tag !== 27 && y.child !== null) {
                y.child.return = y, y = y.child;
                continue;
              }
              if (y === r) break e;
              for (; y.sibling === null; ) {
                if (y.return === null || y.return === r)
                  break e;
                y = y.return;
              }
              y.sibling.return = y.return, y = y.sibling;
            }
            r.stateNode = g;
            e: switch (Ot(g, p, u), p) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                u = !!u.autoFocus;
                break e;
              case "img":
                u = !0;
                break e;
              default:
                u = !1;
            }
            u && na(r);
          }
        }
        return st(r), rd(
          r,
          r.type,
          n === null ? null : n.memoizedProps,
          r.pendingProps,
          s
        ), null;
      case 6:
        if (n && r.stateNode != null)
          n.memoizedProps !== u && na(r);
        else {
          if (typeof u != "string" && r.stateNode === null)
            throw Error(i(166));
          if (n = _e.current, Gr(r)) {
            if (n = r.stateNode, s = r.memoizedProps, u = null, p = wt, p !== null)
              switch (p.tag) {
                case 27:
                case 5:
                  u = p.memoizedProps;
              }
            n[Ct] = r, n = !!(n.nodeValue === s || u !== null && u.suppressHydrationWarning === !0 || nS(n.nodeValue, s)), n || ya(r, !0);
          } else
            n = _l(n).createTextNode(
              u
            ), n[Ct] = r, r.stateNode = n;
        }
        return st(r), null;
      case 31:
        if (s = r.memoizedState, n === null || n.memoizedState !== null) {
          if (u = Gr(r), s !== null) {
            if (n === null) {
              if (!u) throw Error(i(318));
              if (n = r.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(i(557));
              n[Ct] = r;
            } else
              er(), (r.flags & 128) === 0 && (r.memoizedState = null), r.flags |= 4;
            st(r), n = !1;
          } else
            s = mc(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = s), n = !0;
          if (!n)
            return r.flags & 256 ? (on(r), r) : (on(r), null);
          if ((r.flags & 128) !== 0)
            throw Error(i(558));
        }
        return st(r), null;
      case 13:
        if (u = r.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
          if (p = Gr(r), u !== null && u.dehydrated !== null) {
            if (n === null) {
              if (!p) throw Error(i(318));
              if (p = r.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(i(317));
              p[Ct] = r;
            } else
              er(), (r.flags & 128) === 0 && (r.memoizedState = null), r.flags |= 4;
            st(r), p = !1;
          } else
            p = mc(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = p), p = !0;
          if (!p)
            return r.flags & 256 ? (on(r), r) : (on(r), null);
        }
        return on(r), (r.flags & 128) !== 0 ? (r.lanes = s, r) : (s = u !== null, n = n !== null && n.memoizedState !== null, s && (u = r.child, p = null, u.alternate !== null && u.alternate.memoizedState !== null && u.alternate.memoizedState.cachePool !== null && (p = u.alternate.memoizedState.cachePool.pool), g = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (g = u.memoizedState.cachePool.pool), g !== p && (u.flags |= 2048)), s !== n && s && (r.child.flags |= 8192), ol(r, r.updateQueue), st(r), null);
      case 4:
        return Ve(), n === null && vd(r.stateNode.containerInfo), st(r), null;
      case 10:
        return Qn(r.type), st(r), null;
      case 19:
        if (te(pt), u = r.memoizedState, u === null) return st(r), null;
        if (p = (r.flags & 128) !== 0, g = u.rendering, g === null)
          if (p) os(u, !1);
          else {
            if (dt !== 0 || n !== null && (n.flags & 128) !== 0)
              for (n = r.child; n !== null; ) {
                if (g = Wo(n), g !== null) {
                  for (r.flags |= 128, os(u, !1), n = g.updateQueue, r.updateQueue = n, ol(r, n), r.subtreeFlags = 0, n = s, s = r.child; s !== null; )
                    D0(s, n), s = s.sibling;
                  return v(
                    pt,
                    pt.current & 1 | 2
                  ), Ge && Kn(r, u.treeForkCount), r.child;
                }
                n = n.sibling;
              }
            u.tail !== null && Pt() > pl && (r.flags |= 128, p = !0, os(u, !1), r.lanes = 4194304);
          }
        else {
          if (!p)
            if (n = Wo(g), n !== null) {
              if (r.flags |= 128, p = !0, n = n.updateQueue, r.updateQueue = n, ol(r, n), os(u, !0), u.tail === null && u.tailMode === "hidden" && !g.alternate && !Ge)
                return st(r), null;
            } else
              2 * Pt() - u.renderingStartTime > pl && s !== 536870912 && (r.flags |= 128, p = !0, os(u, !1), r.lanes = 4194304);
          u.isBackwards ? (g.sibling = r.child, r.child = g) : (n = u.last, n !== null ? n.sibling = g : r.child = g, u.last = g);
        }
        return u.tail !== null ? (n = u.tail, u.rendering = n, u.tail = n.sibling, u.renderingStartTime = Pt(), n.sibling = null, s = pt.current, v(
          pt,
          p ? s & 1 | 2 : s & 1
        ), Ge && Kn(r, u.treeForkCount), n) : (st(r), null);
      case 22:
      case 23:
        return on(r), Cc(), u = r.memoizedState !== null, n !== null ? n.memoizedState !== null !== u && (r.flags |= 8192) : u && (r.flags |= 8192), u ? (s & 536870912) !== 0 && (r.flags & 128) === 0 && (st(r), r.subtreeFlags & 6 && (r.flags |= 8192)) : st(r), s = r.updateQueue, s !== null && ol(r, s.retryQueue), s = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (s = n.memoizedState.cachePool.pool), u = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (u = r.memoizedState.cachePool.pool), u !== s && (r.flags |= 2048), n !== null && te(ar), null;
      case 24:
        return s = null, n !== null && (s = n.memoizedState.cache), r.memoizedState.cache !== s && (r.flags |= 2048), Qn(gt), st(r), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(i(156, r.tag));
  }
  function _v(n, r) {
    switch (pc(r), r.tag) {
      case 1:
        return n = r.flags, n & 65536 ? (r.flags = n & -65537 | 128, r) : null;
      case 3:
        return Qn(gt), Ve(), n = r.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (r.flags = n & -65537 | 128, r) : null;
      case 26:
      case 27:
      case 5:
        return vn(r), null;
      case 31:
        if (r.memoizedState !== null) {
          if (on(r), r.alternate === null)
            throw Error(i(340));
          er();
        }
        return n = r.flags, n & 65536 ? (r.flags = n & -65537 | 128, r) : null;
      case 13:
        if (on(r), n = r.memoizedState, n !== null && n.dehydrated !== null) {
          if (r.alternate === null)
            throw Error(i(340));
          er();
        }
        return n = r.flags, n & 65536 ? (r.flags = n & -65537 | 128, r) : null;
      case 19:
        return te(pt), null;
      case 4:
        return Ve(), null;
      case 10:
        return Qn(r.type), null;
      case 22:
      case 23:
        return on(r), Cc(), n !== null && te(ar), n = r.flags, n & 65536 ? (r.flags = n & -65537 | 128, r) : null;
      case 24:
        return Qn(gt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function oT(n, r) {
    switch (pc(r), r.tag) {
      case 3:
        Qn(gt), Ve();
        break;
      case 26:
      case 27:
      case 5:
        vn(r);
        break;
      case 4:
        Ve();
        break;
      case 31:
        r.memoizedState !== null && on(r);
        break;
      case 13:
        on(r);
        break;
      case 19:
        te(pt);
        break;
      case 10:
        Qn(r.type);
        break;
      case 22:
      case 23:
        on(r), Cc(), n !== null && te(ar);
        break;
      case 24:
        Qn(gt);
    }
  }
  function ls(n, r) {
    try {
      var s = r.updateQueue, u = s !== null ? s.lastEffect : null;
      if (u !== null) {
        var p = u.next;
        s = p;
        do {
          if ((s.tag & n) === n) {
            u = void 0;
            var g = s.create, y = s.inst;
            u = g(), y.destroy = u;
          }
          s = s.next;
        } while (s !== p);
      }
    } catch (A) {
      Ke(r, r.return, A);
    }
  }
  function va(n, r, s) {
    try {
      var u = r.updateQueue, p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var g = p.next;
        u = g;
        do {
          if ((u.tag & n) === n) {
            var y = u.inst, A = y.destroy;
            if (A !== void 0) {
              y.destroy = void 0, p = r;
              var P = s, X = A;
              try {
                X();
              } catch (re) {
                Ke(
                  p,
                  P,
                  re
                );
              }
            }
          }
          u = u.next;
        } while (u !== g);
      }
    } catch (re) {
      Ke(r, r.return, re);
    }
  }
  function lT(n) {
    var r = n.updateQueue;
    if (r !== null) {
      var s = n.stateNode;
      try {
        Q0(r, s);
      } catch (u) {
        Ke(n, n.return, u);
      }
    }
  }
  function uT(n, r, s) {
    s.props = lr(
      n.type,
      n.memoizedProps
    ), s.state = n.memoizedState;
    try {
      s.componentWillUnmount();
    } catch (u) {
      Ke(n, r, u);
    }
  }
  function us(n, r) {
    try {
      var s = n.ref;
      if (s !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var u = n.stateNode;
            break;
          case 30:
            u = n.stateNode;
            break;
          default:
            u = n.stateNode;
        }
        typeof s == "function" ? n.refCleanup = s(u) : s.current = u;
      }
    } catch (p) {
      Ke(n, r, p);
    }
  }
  function Bn(n, r) {
    var s = n.ref, u = n.refCleanup;
    if (s !== null)
      if (typeof u == "function")
        try {
          u();
        } catch (p) {
          Ke(n, r, p);
        } finally {
          n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null);
        }
      else if (typeof s == "function")
        try {
          s(null);
        } catch (p) {
          Ke(n, r, p);
        }
      else s.current = null;
  }
  function cT(n) {
    var r = n.type, s = n.memoizedProps, u = n.stateNode;
    try {
      e: switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          s.autoFocus && u.focus();
          break e;
        case "img":
          s.src ? u.src = s.src : s.srcSet && (u.srcset = s.srcSet);
      }
    } catch (p) {
      Ke(n, n.return, p);
    }
  }
  function id(n, r, s) {
    try {
      var u = n.stateNode;
      $v(u, n.type, s, r), u[qt] = r;
    } catch (p) {
      Ke(n, n.return, p);
    }
  }
  function dT(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && La(n.type) || n.tag === 4;
  }
  function sd(n) {
    e: for (; ; ) {
      for (; n.sibling === null; ) {
        if (n.return === null || dT(n.return)) return null;
        n = n.return;
      }
      for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
        if (n.tag === 27 && La(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue e;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2)) return n.stateNode;
    }
  }
  function od(n, r, s) {
    var u = n.tag;
    if (u === 5 || u === 6)
      n = n.stateNode, r ? (s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s).insertBefore(n, r) : (r = s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, r.appendChild(n), s = s._reactRootContainer, s != null || r.onclick !== null || (r.onclick = Vn));
    else if (u !== 4 && (u === 27 && La(n.type) && (s = n.stateNode, r = null), n = n.child, n !== null))
      for (od(n, r, s), n = n.sibling; n !== null; )
        od(n, r, s), n = n.sibling;
  }
  function ll(n, r, s) {
    var u = n.tag;
    if (u === 5 || u === 6)
      n = n.stateNode, r ? s.insertBefore(n, r) : s.appendChild(n);
    else if (u !== 4 && (u === 27 && La(n.type) && (s = n.stateNode), n = n.child, n !== null))
      for (ll(n, r, s), n = n.sibling; n !== null; )
        ll(n, r, s), n = n.sibling;
  }
  function pT(n) {
    var r = n.stateNode, s = n.memoizedProps;
    try {
      for (var u = n.type, p = r.attributes; p.length; )
        r.removeAttributeNode(p[0]);
      Ot(r, u, s), r[Ct] = n, r[qt] = s;
    } catch (g) {
      Ke(n, n.return, g);
    }
  }
  var aa = !1, Et = !1, ld = !1, fT = typeof WeakSet == "function" ? WeakSet : Set, At = null;
  function Av(n, r) {
    if (n = n.containerInfo, kd = kl, n = R0(n), tc(n)) {
      if ("selectionStart" in n)
        var s = {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      else
        e: {
          s = (s = n.ownerDocument) && s.defaultView || window;
          var u = s.getSelection && s.getSelection();
          if (u && u.rangeCount !== 0) {
            s = u.anchorNode;
            var p = u.anchorOffset, g = u.focusNode;
            u = u.focusOffset;
            try {
              s.nodeType, g.nodeType;
            } catch {
              s = null;
              break e;
            }
            var y = 0, A = -1, P = -1, X = 0, re = 0, le = n, Z = null;
            t: for (; ; ) {
              for (var J; le !== s || p !== 0 && le.nodeType !== 3 || (A = y + p), le !== g || u !== 0 && le.nodeType !== 3 || (P = y + u), le.nodeType === 3 && (y += le.nodeValue.length), (J = le.firstChild) !== null; )
                Z = le, le = J;
              for (; ; ) {
                if (le === n) break t;
                if (Z === s && ++X === p && (A = y), Z === g && ++re === u && (P = y), (J = le.nextSibling) !== null) break;
                le = Z, Z = le.parentNode;
              }
              le = J;
            }
            s = A === -1 || P === -1 ? null : { start: A, end: P };
          } else s = null;
        }
      s = s || { start: 0, end: 0 };
    } else s = null;
    for (Id = { focusedElem: n, selectionRange: s }, kl = !1, At = r; At !== null; )
      if (r = At, n = r.child, (r.subtreeFlags & 1028) !== 0 && n !== null)
        n.return = r, At = n;
      else
        for (; At !== null; ) {
          switch (r = At, g = r.alternate, n = r.flags, r.tag) {
            case 0:
              if ((n & 4) !== 0 && (n = r.updateQueue, n = n !== null ? n.events : null, n !== null))
                for (s = 0; s < n.length; s++)
                  p = n[s], p.ref.impl = p.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((n & 1024) !== 0 && g !== null) {
                n = void 0, s = r, p = g.memoizedProps, g = g.memoizedState, u = s.stateNode;
                try {
                  var Te = lr(
                    s.type,
                    p
                  );
                  n = u.getSnapshotBeforeUpdate(
                    Te,
                    g
                  ), u.__reactInternalSnapshotBeforeUpdate = n;
                } catch (Ce) {
                  Ke(
                    s,
                    s.return,
                    Ce
                  );
                }
              }
              break;
            case 3:
              if ((n & 1024) !== 0) {
                if (n = r.stateNode.containerInfo, s = n.nodeType, s === 9)
                  Ld(n);
                else if (s === 1)
                  switch (n.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Ld(n);
                      break;
                    default:
                      n.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((n & 1024) !== 0) throw Error(i(163));
          }
          if (n = r.sibling, n !== null) {
            n.return = r.return, At = n;
            break;
          }
          At = r.return;
        }
  }
  function mT(n, r, s) {
    var u = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        ia(n, s), u & 4 && ls(5, s);
        break;
      case 1:
        if (ia(n, s), u & 4)
          if (n = s.stateNode, r === null)
            try {
              n.componentDidMount();
            } catch (y) {
              Ke(s, s.return, y);
            }
          else {
            var p = lr(
              s.type,
              r.memoizedProps
            );
            r = r.memoizedState;
            try {
              n.componentDidUpdate(
                p,
                r,
                n.__reactInternalSnapshotBeforeUpdate
              );
            } catch (y) {
              Ke(
                s,
                s.return,
                y
              );
            }
          }
        u & 64 && lT(s), u & 512 && us(s, s.return);
        break;
      case 3:
        if (ia(n, s), u & 64 && (n = s.updateQueue, n !== null)) {
          if (r = null, s.child !== null)
            switch (s.child.tag) {
              case 27:
              case 5:
                r = s.child.stateNode;
                break;
              case 1:
                r = s.child.stateNode;
            }
          try {
            Q0(n, r);
          } catch (y) {
            Ke(s, s.return, y);
          }
        }
        break;
      case 27:
        r === null && u & 4 && pT(s);
      case 26:
      case 5:
        ia(n, s), r === null && u & 4 && cT(s), u & 512 && us(s, s.return);
        break;
      case 12:
        ia(n, s);
        break;
      case 31:
        ia(n, s), u & 4 && bT(n, s);
        break;
      case 13:
        ia(n, s), u & 4 && ET(n, s), u & 64 && (n = s.memoizedState, n !== null && (n = n.dehydrated, n !== null && (s = xv.bind(
          null,
          s
        ), Qv(n, s))));
        break;
      case 22:
        if (u = s.memoizedState !== null || aa, !u) {
          r = r !== null && r.memoizedState !== null || Et, p = aa;
          var g = Et;
          aa = u, (Et = r) && !g ? sa(
            n,
            s,
            (s.subtreeFlags & 8772) !== 0
          ) : ia(n, s), aa = p, Et = g;
        }
        break;
      case 30:
        break;
      default:
        ia(n, s);
    }
  }
  function gT(n) {
    var r = n.alternate;
    r !== null && (n.alternate = null, gT(r)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (r = n.stateNode, r !== null && Fu(r)), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
  }
  var ot = null, Vt = !1;
  function ra(n, r, s) {
    for (s = s.child; s !== null; )
      hT(n, r, s), s = s.sibling;
  }
  function hT(n, r, s) {
    if (Tt && typeof Tt.onCommitFiberUnmount == "function")
      try {
        Tt.onCommitFiberUnmount(Ht, s);
      } catch {
      }
    switch (s.tag) {
      case 26:
        Et || Bn(s, r), ra(
          n,
          r,
          s
        ), s.memoizedState ? s.memoizedState.count-- : s.stateNode && (s = s.stateNode, s.parentNode.removeChild(s));
        break;
      case 27:
        Et || Bn(s, r);
        var u = ot, p = Vt;
        La(s.type) && (ot = s.stateNode, Vt = !1), ra(
          n,
          r,
          s
        ), Es(s.stateNode), ot = u, Vt = p;
        break;
      case 5:
        Et || Bn(s, r);
      case 6:
        if (u = ot, p = Vt, ot = null, ra(
          n,
          r,
          s
        ), ot = u, Vt = p, ot !== null)
          if (Vt)
            try {
              (ot.nodeType === 9 ? ot.body : ot.nodeName === "HTML" ? ot.ownerDocument.body : ot).removeChild(s.stateNode);
            } catch (g) {
              Ke(
                s,
                r,
                g
              );
            }
          else
            try {
              ot.removeChild(s.stateNode);
            } catch (g) {
              Ke(
                s,
                r,
                g
              );
            }
        break;
      case 18:
        ot !== null && (Vt ? (n = ot, lS(
          n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n,
          s.stateNode
        ), ui(n)) : lS(ot, s.stateNode));
        break;
      case 4:
        u = ot, p = Vt, ot = s.stateNode.containerInfo, Vt = !0, ra(
          n,
          r,
          s
        ), ot = u, Vt = p;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        va(2, s, r), Et || va(4, s, r), ra(
          n,
          r,
          s
        );
        break;
      case 1:
        Et || (Bn(s, r), u = s.stateNode, typeof u.componentWillUnmount == "function" && uT(
          s,
          r,
          u
        )), ra(
          n,
          r,
          s
        );
        break;
      case 21:
        ra(
          n,
          r,
          s
        );
        break;
      case 22:
        Et = (u = Et) || s.memoizedState !== null, ra(
          n,
          r,
          s
        ), Et = u;
        break;
      default:
        ra(
          n,
          r,
          s
        );
    }
  }
  function bT(n, r) {
    if (r.memoizedState === null && (n = r.alternate, n !== null && (n = n.memoizedState, n !== null))) {
      n = n.dehydrated;
      try {
        ui(n);
      } catch (s) {
        Ke(r, r.return, s);
      }
    }
  }
  function ET(n, r) {
    if (r.memoizedState === null && (n = r.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null))))
      try {
        ui(n);
      } catch (s) {
        Ke(r, r.return, s);
      }
  }
  function Nv(n) {
    switch (n.tag) {
      case 31:
      case 13:
      case 19:
        var r = n.stateNode;
        return r === null && (r = n.stateNode = new fT()), r;
      case 22:
        return n = n.stateNode, r = n._retryCache, r === null && (r = n._retryCache = new fT()), r;
      default:
        throw Error(i(435, n.tag));
    }
  }
  function ul(n, r) {
    var s = Nv(n);
    r.forEach(function(u) {
      if (!s.has(u)) {
        s.add(u);
        var p = Lv.bind(null, n, u);
        u.then(p, p);
      }
    });
  }
  function Wt(n, r) {
    var s = r.deletions;
    if (s !== null)
      for (var u = 0; u < s.length; u++) {
        var p = s[u], g = n, y = r, A = y;
        e: for (; A !== null; ) {
          switch (A.tag) {
            case 27:
              if (La(A.type)) {
                ot = A.stateNode, Vt = !1;
                break e;
              }
              break;
            case 5:
              ot = A.stateNode, Vt = !1;
              break e;
            case 3:
            case 4:
              ot = A.stateNode.containerInfo, Vt = !0;
              break e;
          }
          A = A.return;
        }
        if (ot === null) throw Error(i(160));
        hT(g, y, p), ot = null, Vt = !1, g = p.alternate, g !== null && (g.return = null), p.return = null;
      }
    if (r.subtreeFlags & 13886)
      for (r = r.child; r !== null; )
        yT(r, n), r = r.sibling;
  }
  var kn = null;
  function yT(n, r) {
    var s = n.alternate, u = n.flags;
    switch (n.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Wt(r, n), Xt(n), u & 4 && (va(3, n, n.return), ls(3, n), va(5, n, n.return));
        break;
      case 1:
        Wt(r, n), Xt(n), u & 512 && (Et || s === null || Bn(s, s.return)), u & 64 && aa && (n = n.updateQueue, n !== null && (u = n.callbacks, u !== null && (s = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = s === null ? u : s.concat(u))));
        break;
      case 26:
        var p = kn;
        if (Wt(r, n), Xt(n), u & 512 && (Et || s === null || Bn(s, s.return)), u & 4) {
          var g = s !== null ? s.memoizedState : null;
          if (u = n.memoizedState, s === null)
            if (u === null)
              if (n.stateNode === null) {
                e: {
                  u = n.type, s = n.memoizedProps, p = p.ownerDocument || p;
                  t: switch (u) {
                    case "title":
                      g = p.getElementsByTagName("title")[0], (!g || g[Ui] || g[Ct] || g.namespaceURI === "http://www.w3.org/2000/svg" || g.hasAttribute("itemprop")) && (g = p.createElement(u), p.head.insertBefore(
                        g,
                        p.querySelector("head > title")
                      )), Ot(g, u, s), g[Ct] = n, _t(g), u = g;
                      break e;
                    case "link":
                      var y = yS(
                        "link",
                        "href",
                        p
                      ).get(u + (s.href || ""));
                      if (y) {
                        for (var A = 0; A < y.length; A++)
                          if (g = y[A], g.getAttribute("href") === (s.href == null || s.href === "" ? null : s.href) && g.getAttribute("rel") === (s.rel == null ? null : s.rel) && g.getAttribute("title") === (s.title == null ? null : s.title) && g.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
                            y.splice(A, 1);
                            break t;
                          }
                      }
                      g = p.createElement(u), Ot(g, u, s), p.head.appendChild(g);
                      break;
                    case "meta":
                      if (y = yS(
                        "meta",
                        "content",
                        p
                      ).get(u + (s.content || ""))) {
                        for (A = 0; A < y.length; A++)
                          if (g = y[A], g.getAttribute("content") === (s.content == null ? null : "" + s.content) && g.getAttribute("name") === (s.name == null ? null : s.name) && g.getAttribute("property") === (s.property == null ? null : s.property) && g.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && g.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
                            y.splice(A, 1);
                            break t;
                          }
                      }
                      g = p.createElement(u), Ot(g, u, s), p.head.appendChild(g);
                      break;
                    default:
                      throw Error(i(468, u));
                  }
                  g[Ct] = n, _t(g), u = g;
                }
                n.stateNode = u;
              } else
                TS(
                  p,
                  n.type,
                  n.stateNode
                );
            else
              n.stateNode = ES(
                p,
                u,
                n.memoizedProps
              );
          else
            g !== u ? (g === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : g.count--, u === null ? TS(
              p,
              n.type,
              n.stateNode
            ) : ES(
              p,
              u,
              n.memoizedProps
            )) : u === null && n.stateNode !== null && id(
              n,
              n.memoizedProps,
              s.memoizedProps
            );
        }
        break;
      case 27:
        Wt(r, n), Xt(n), u & 512 && (Et || s === null || Bn(s, s.return)), s !== null && u & 4 && id(
          n,
          n.memoizedProps,
          s.memoizedProps
        );
        break;
      case 5:
        if (Wt(r, n), Xt(n), u & 512 && (Et || s === null || Bn(s, s.return)), n.flags & 32) {
          p = n.stateNode;
          try {
            xr(p, "");
          } catch (Te) {
            Ke(n, n.return, Te);
          }
        }
        u & 4 && n.stateNode != null && (p = n.memoizedProps, id(
          n,
          p,
          s !== null ? s.memoizedProps : p
        )), u & 1024 && (ld = !0);
        break;
      case 6:
        if (Wt(r, n), Xt(n), u & 4) {
          if (n.stateNode === null)
            throw Error(i(162));
          u = n.memoizedProps, s = n.stateNode;
          try {
            s.nodeValue = u;
          } catch (Te) {
            Ke(n, n.return, Te);
          }
        }
        break;
      case 3:
        if (Rl = null, p = kn, kn = Al(r.containerInfo), Wt(r, n), kn = p, Xt(n), u & 4 && s !== null && s.memoizedState.isDehydrated)
          try {
            ui(r.containerInfo);
          } catch (Te) {
            Ke(n, n.return, Te);
          }
        ld && (ld = !1, TT(n));
        break;
      case 4:
        u = kn, kn = Al(
          n.stateNode.containerInfo
        ), Wt(r, n), Xt(n), kn = u;
        break;
      case 12:
        Wt(r, n), Xt(n);
        break;
      case 31:
        Wt(r, n), Xt(n), u & 4 && (u = n.updateQueue, u !== null && (n.updateQueue = null, ul(n, u)));
        break;
      case 13:
        Wt(r, n), Xt(n), n.child.flags & 8192 && n.memoizedState !== null != (s !== null && s.memoizedState !== null) && (dl = Pt()), u & 4 && (u = n.updateQueue, u !== null && (n.updateQueue = null, ul(n, u)));
        break;
      case 22:
        p = n.memoizedState !== null;
        var P = s !== null && s.memoizedState !== null, X = aa, re = Et;
        if (aa = X || p, Et = re || P, Wt(r, n), Et = re, aa = X, Xt(n), u & 8192)
          e: for (r = n.stateNode, r._visibility = p ? r._visibility & -2 : r._visibility | 1, p && (s === null || P || aa || Et || ur(n)), s = null, r = n; ; ) {
            if (r.tag === 5 || r.tag === 26) {
              if (s === null) {
                P = s = r;
                try {
                  if (g = P.stateNode, p)
                    y = g.style, typeof y.setProperty == "function" ? y.setProperty("display", "none", "important") : y.display = "none";
                  else {
                    A = P.stateNode;
                    var le = P.memoizedProps.style, Z = le != null && le.hasOwnProperty("display") ? le.display : null;
                    A.style.display = Z == null || typeof Z == "boolean" ? "" : ("" + Z).trim();
                  }
                } catch (Te) {
                  Ke(P, P.return, Te);
                }
              }
            } else if (r.tag === 6) {
              if (s === null) {
                P = r;
                try {
                  P.stateNode.nodeValue = p ? "" : P.memoizedProps;
                } catch (Te) {
                  Ke(P, P.return, Te);
                }
              }
            } else if (r.tag === 18) {
              if (s === null) {
                P = r;
                try {
                  var J = P.stateNode;
                  p ? uS(J, !0) : uS(P.stateNode, !1);
                } catch (Te) {
                  Ke(P, P.return, Te);
                }
              }
            } else if ((r.tag !== 22 && r.tag !== 23 || r.memoizedState === null || r === n) && r.child !== null) {
              r.child.return = r, r = r.child;
              continue;
            }
            if (r === n) break e;
            for (; r.sibling === null; ) {
              if (r.return === null || r.return === n) break e;
              s === r && (s = null), r = r.return;
            }
            s === r && (s = null), r.sibling.return = r.return, r = r.sibling;
          }
        u & 4 && (u = n.updateQueue, u !== null && (s = u.retryQueue, s !== null && (u.retryQueue = null, ul(n, s))));
        break;
      case 19:
        Wt(r, n), Xt(n), u & 4 && (u = n.updateQueue, u !== null && (n.updateQueue = null, ul(n, u)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Wt(r, n), Xt(n);
    }
  }
  function Xt(n) {
    var r = n.flags;
    if (r & 2) {
      try {
        for (var s, u = n.return; u !== null; ) {
          if (dT(u)) {
            s = u;
            break;
          }
          u = u.return;
        }
        if (s == null) throw Error(i(160));
        switch (s.tag) {
          case 27:
            var p = s.stateNode, g = sd(n);
            ll(n, g, p);
            break;
          case 5:
            var y = s.stateNode;
            s.flags & 32 && (xr(y, ""), s.flags &= -33);
            var A = sd(n);
            ll(n, A, y);
            break;
          case 3:
          case 4:
            var P = s.stateNode.containerInfo, X = sd(n);
            od(
              n,
              X,
              P
            );
            break;
          default:
            throw Error(i(161));
        }
      } catch (re) {
        Ke(n, n.return, re);
      }
      n.flags &= -3;
    }
    r & 4096 && (n.flags &= -4097);
  }
  function TT(n) {
    if (n.subtreeFlags & 1024)
      for (n = n.child; n !== null; ) {
        var r = n;
        TT(r), r.tag === 5 && r.flags & 1024 && r.stateNode.reset(), n = n.sibling;
      }
  }
  function ia(n, r) {
    if (r.subtreeFlags & 8772)
      for (r = r.child; r !== null; )
        mT(n, r.alternate, r), r = r.sibling;
  }
  function ur(n) {
    for (n = n.child; n !== null; ) {
      var r = n;
      switch (r.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          va(4, r, r.return), ur(r);
          break;
        case 1:
          Bn(r, r.return);
          var s = r.stateNode;
          typeof s.componentWillUnmount == "function" && uT(
            r,
            r.return,
            s
          ), ur(r);
          break;
        case 27:
          Es(r.stateNode);
        case 26:
        case 5:
          Bn(r, r.return), ur(r);
          break;
        case 22:
          r.memoizedState === null && ur(r);
          break;
        case 30:
          ur(r);
          break;
        default:
          ur(r);
      }
      n = n.sibling;
    }
  }
  function sa(n, r, s) {
    for (s = s && (r.subtreeFlags & 8772) !== 0, r = r.child; r !== null; ) {
      var u = r.alternate, p = n, g = r, y = g.flags;
      switch (g.tag) {
        case 0:
        case 11:
        case 15:
          sa(
            p,
            g,
            s
          ), ls(4, g);
          break;
        case 1:
          if (sa(
            p,
            g,
            s
          ), u = g, p = u.stateNode, typeof p.componentDidMount == "function")
            try {
              p.componentDidMount();
            } catch (X) {
              Ke(u, u.return, X);
            }
          if (u = g, p = u.updateQueue, p !== null) {
            var A = u.stateNode;
            try {
              var P = p.shared.hiddenCallbacks;
              if (P !== null)
                for (p.shared.hiddenCallbacks = null, p = 0; p < P.length; p++)
                  Z0(P[p], A);
            } catch (X) {
              Ke(u, u.return, X);
            }
          }
          s && y & 64 && lT(g), us(g, g.return);
          break;
        case 27:
          pT(g);
        case 26:
        case 5:
          sa(
            p,
            g,
            s
          ), s && u === null && y & 4 && cT(g), us(g, g.return);
          break;
        case 12:
          sa(
            p,
            g,
            s
          );
          break;
        case 31:
          sa(
            p,
            g,
            s
          ), s && y & 4 && bT(p, g);
          break;
        case 13:
          sa(
            p,
            g,
            s
          ), s && y & 4 && ET(p, g);
          break;
        case 22:
          g.memoizedState === null && sa(
            p,
            g,
            s
          ), us(g, g.return);
          break;
        case 30:
          break;
        default:
          sa(
            p,
            g,
            s
          );
      }
      r = r.sibling;
    }
  }
  function ud(n, r) {
    var s = null;
    n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (s = n.memoizedState.cachePool.pool), n = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (n = r.memoizedState.cachePool.pool), n !== s && (n != null && n.refCount++, s != null && Xi(s));
  }
  function cd(n, r) {
    n = null, r.alternate !== null && (n = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== n && (r.refCount++, n != null && Xi(n));
  }
  function In(n, r, s, u) {
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        ST(
          n,
          r,
          s,
          u
        ), r = r.sibling;
  }
  function ST(n, r, s, u) {
    var p = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        In(
          n,
          r,
          s,
          u
        ), p & 2048 && ls(9, r);
        break;
      case 1:
        In(
          n,
          r,
          s,
          u
        );
        break;
      case 3:
        In(
          n,
          r,
          s,
          u
        ), p & 2048 && (n = null, r.alternate !== null && (n = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== n && (r.refCount++, n != null && Xi(n)));
        break;
      case 12:
        if (p & 2048) {
          In(
            n,
            r,
            s,
            u
          ), n = r.stateNode;
          try {
            var g = r.memoizedProps, y = g.id, A = g.onPostCommit;
            typeof A == "function" && A(
              y,
              r.alternate === null ? "mount" : "update",
              n.passiveEffectDuration,
              -0
            );
          } catch (P) {
            Ke(r, r.return, P);
          }
        } else
          In(
            n,
            r,
            s,
            u
          );
        break;
      case 31:
        In(
          n,
          r,
          s,
          u
        );
        break;
      case 13:
        In(
          n,
          r,
          s,
          u
        );
        break;
      case 23:
        break;
      case 22:
        g = r.stateNode, y = r.alternate, r.memoizedState !== null ? g._visibility & 2 ? In(
          n,
          r,
          s,
          u
        ) : cs(n, r) : g._visibility & 2 ? In(
          n,
          r,
          s,
          u
        ) : (g._visibility |= 2, Qr(
          n,
          r,
          s,
          u,
          (r.subtreeFlags & 10256) !== 0 || !1
        )), p & 2048 && ud(y, r);
        break;
      case 24:
        In(
          n,
          r,
          s,
          u
        ), p & 2048 && cd(r.alternate, r);
        break;
      default:
        In(
          n,
          r,
          s,
          u
        );
    }
  }
  function Qr(n, r, s, u, p) {
    for (p = p && ((r.subtreeFlags & 10256) !== 0 || !1), r = r.child; r !== null; ) {
      var g = n, y = r, A = s, P = u, X = y.flags;
      switch (y.tag) {
        case 0:
        case 11:
        case 15:
          Qr(
            g,
            y,
            A,
            P,
            p
          ), ls(8, y);
          break;
        case 23:
          break;
        case 22:
          var re = y.stateNode;
          y.memoizedState !== null ? re._visibility & 2 ? Qr(
            g,
            y,
            A,
            P,
            p
          ) : cs(
            g,
            y
          ) : (re._visibility |= 2, Qr(
            g,
            y,
            A,
            P,
            p
          )), p && X & 2048 && ud(
            y.alternate,
            y
          );
          break;
        case 24:
          Qr(
            g,
            y,
            A,
            P,
            p
          ), p && X & 2048 && cd(y.alternate, y);
          break;
        default:
          Qr(
            g,
            y,
            A,
            P,
            p
          );
      }
      r = r.sibling;
    }
  }
  function cs(n, r) {
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; ) {
        var s = n, u = r, p = u.flags;
        switch (u.tag) {
          case 22:
            cs(s, u), p & 2048 && ud(
              u.alternate,
              u
            );
            break;
          case 24:
            cs(s, u), p & 2048 && cd(u.alternate, u);
            break;
          default:
            cs(s, u);
        }
        r = r.sibling;
      }
  }
  var ds = 8192;
  function Jr(n, r, s) {
    if (n.subtreeFlags & ds)
      for (n = n.child; n !== null; )
        _T(
          n,
          r,
          s
        ), n = n.sibling;
  }
  function _T(n, r, s) {
    switch (n.tag) {
      case 26:
        Jr(
          n,
          r,
          s
        ), n.flags & ds && n.memoizedState !== null && cC(
          s,
          kn,
          n.memoizedState,
          n.memoizedProps
        );
        break;
      case 5:
        Jr(
          n,
          r,
          s
        );
        break;
      case 3:
      case 4:
        var u = kn;
        kn = Al(n.stateNode.containerInfo), Jr(
          n,
          r,
          s
        ), kn = u;
        break;
      case 22:
        n.memoizedState === null && (u = n.alternate, u !== null && u.memoizedState !== null ? (u = ds, ds = 16777216, Jr(
          n,
          r,
          s
        ), ds = u) : Jr(
          n,
          r,
          s
        ));
        break;
      default:
        Jr(
          n,
          r,
          s
        );
    }
  }
  function AT(n) {
    var r = n.alternate;
    if (r !== null && (n = r.child, n !== null)) {
      r.child = null;
      do
        r = n.sibling, n.sibling = null, n = r;
      while (n !== null);
    }
  }
  function ps(n) {
    var r = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (r !== null)
        for (var s = 0; s < r.length; s++) {
          var u = r[s];
          At = u, RT(
            u,
            n
          );
        }
      AT(n);
    }
    if (n.subtreeFlags & 10256)
      for (n = n.child; n !== null; )
        NT(n), n = n.sibling;
  }
  function NT(n) {
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        ps(n), n.flags & 2048 && va(9, n, n.return);
        break;
      case 3:
        ps(n);
        break;
      case 12:
        ps(n);
        break;
      case 22:
        var r = n.stateNode;
        n.memoizedState !== null && r._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (r._visibility &= -3, cl(n)) : ps(n);
        break;
      default:
        ps(n);
    }
  }
  function cl(n) {
    var r = n.deletions;
    if ((n.flags & 16) !== 0) {
      if (r !== null)
        for (var s = 0; s < r.length; s++) {
          var u = r[s];
          At = u, RT(
            u,
            n
          );
        }
      AT(n);
    }
    for (n = n.child; n !== null; ) {
      switch (r = n, r.tag) {
        case 0:
        case 11:
        case 15:
          va(8, r, r.return), cl(r);
          break;
        case 22:
          s = r.stateNode, s._visibility & 2 && (s._visibility &= -3, cl(r));
          break;
        default:
          cl(r);
      }
      n = n.sibling;
    }
  }
  function RT(n, r) {
    for (; At !== null; ) {
      var s = At;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          va(8, s, r);
          break;
        case 23:
        case 22:
          if (s.memoizedState !== null && s.memoizedState.cachePool !== null) {
            var u = s.memoizedState.cachePool.pool;
            u != null && u.refCount++;
          }
          break;
        case 24:
          Xi(s.memoizedState.cache);
      }
      if (u = s.child, u !== null) u.return = s, At = u;
      else
        e: for (s = n; At !== null; ) {
          u = At;
          var p = u.sibling, g = u.return;
          if (gT(u), u === s) {
            At = null;
            break e;
          }
          if (p !== null) {
            p.return = g, At = p;
            break e;
          }
          At = g;
        }
    }
  }
  var Rv = {
    getCacheForType: function(n) {
      var r = kt(gt), s = r.data.get(n);
      return s === void 0 && (s = n(), r.data.set(n, s)), s;
    },
    cacheSignal: function() {
      return kt(gt).controller.signal;
    }
  }, vv = typeof WeakMap == "function" ? WeakMap : Map, Ye = 0, nt = null, Ue = null, Pe = 0, Xe = 0, ln = null, Ca = !1, ei = !1, dd = !1, oa = 0, dt = 0, wa = 0, cr = 0, pd = 0, un = 0, ti = 0, fs = null, Kt = null, fd = !1, dl = 0, vT = 0, pl = 1 / 0, fl = null, ka = null, St = 0, Ia = null, ni = null, la = 0, md = 0, gd = null, CT = null, ms = 0, hd = null;
  function cn() {
    return (Ye & 2) !== 0 && Pe !== 0 ? Pe & -Pe : j.T !== null ? _d() : jE();
  }
  function wT() {
    if (un === 0)
      if ((Pe & 536870912) === 0 || Ge) {
        var n = So;
        So <<= 1, (So & 3932160) === 0 && (So = 262144), un = n;
      } else un = 536870912;
    return n = sn.current, n !== null && (n.flags |= 32), un;
  }
  function Zt(n, r, s) {
    (n === nt && (Xe === 2 || Xe === 9) || n.cancelPendingCommit !== null) && (ai(n, 0), Oa(
      n,
      Pe,
      un,
      !1
    )), Mi(n, s), ((Ye & 2) === 0 || n !== nt) && (n === nt && ((Ye & 2) === 0 && (cr |= s), dt === 4 && Oa(
      n,
      Pe,
      un,
      !1
    )), Fn(n));
  }
  function kT(n, r, s) {
    if ((Ye & 6) !== 0) throw Error(i(327));
    var u = !s && (r & 127) === 0 && (r & n.expiredLanes) === 0 || Di(n, r), p = u ? kv(n, r) : Ed(n, r, !0), g = u;
    do {
      if (p === 0) {
        ei && !u && Oa(n, r, 0, !1);
        break;
      } else {
        if (s = n.current.alternate, g && !Cv(s)) {
          p = Ed(n, r, !1), g = !1;
          continue;
        }
        if (p === 2) {
          if (g = r, n.errorRecoveryDisabledLanes & g)
            var y = 0;
          else
            y = n.pendingLanes & -536870913, y = y !== 0 ? y : y & 536870912 ? 536870912 : 0;
          if (y !== 0) {
            r = y;
            e: {
              var A = n;
              p = fs;
              var P = A.current.memoizedState.isDehydrated;
              if (P && (ai(A, y).flags |= 256), y = Ed(
                A,
                y,
                !1
              ), y !== 2) {
                if (dd && !P) {
                  A.errorRecoveryDisabledLanes |= g, cr |= g, p = 4;
                  break e;
                }
                g = Kt, Kt = p, g !== null && (Kt === null ? Kt = g : Kt.push.apply(
                  Kt,
                  g
                ));
              }
              p = y;
            }
            if (g = !1, p !== 2) continue;
          }
        }
        if (p === 1) {
          ai(n, 0), Oa(n, r, 0, !0);
          break;
        }
        e: {
          switch (u = n, g = p, g) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((r & 4194048) !== r) break;
            case 6:
              Oa(
                u,
                r,
                un,
                !Ca
              );
              break e;
            case 2:
              Kt = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if ((r & 62914560) === r && (p = dl + 300 - Pt(), 10 < p)) {
            if (Oa(
              u,
              r,
              un,
              !Ca
            ), Ao(u, 0, !0) !== 0) break e;
            la = r, u.timeoutHandle = sS(
              IT.bind(
                null,
                u,
                s,
                Kt,
                fl,
                fd,
                r,
                un,
                cr,
                ti,
                Ca,
                g,
                "Throttled",
                -0,
                0
              ),
              p
            );
            break e;
          }
          IT(
            u,
            s,
            Kt,
            fl,
            fd,
            r,
            un,
            cr,
            ti,
            Ca,
            g,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Fn(n);
  }
  function IT(n, r, s, u, p, g, y, A, P, X, re, le, Z, J) {
    if (n.timeoutHandle = -1, le = r.subtreeFlags, le & 8192 || (le & 16785408) === 16785408) {
      le = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: Vn
      }, _T(
        r,
        g,
        le
      );
      var Te = (g & 62914560) === g ? dl - Pt() : (g & 4194048) === g ? vT - Pt() : 0;
      if (Te = dC(
        le,
        Te
      ), Te !== null) {
        la = g, n.cancelPendingCommit = Te(
          FT.bind(
            null,
            n,
            r,
            g,
            s,
            u,
            p,
            y,
            A,
            P,
            re,
            le,
            null,
            Z,
            J
          )
        ), Oa(n, g, y, !X);
        return;
      }
    }
    FT(
      n,
      r,
      g,
      s,
      u,
      p,
      y,
      A,
      P
    );
  }
  function Cv(n) {
    for (var r = n; ; ) {
      var s = r.tag;
      if ((s === 0 || s === 11 || s === 15) && r.flags & 16384 && (s = r.updateQueue, s !== null && (s = s.stores, s !== null)))
        for (var u = 0; u < s.length; u++) {
          var p = s[u], g = p.getSnapshot;
          p = p.value;
          try {
            if (!an(g(), p)) return !1;
          } catch {
            return !1;
          }
        }
      if (s = r.child, r.subtreeFlags & 16384 && s !== null)
        s.return = r, r = s;
      else {
        if (r === n) break;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === n) return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
    }
    return !0;
  }
  function Oa(n, r, s, u) {
    r &= ~pd, r &= ~cr, n.suspendedLanes |= r, n.pingedLanes &= ~r, u && (n.warmLanes |= r), u = n.expirationTimes;
    for (var p = r; 0 < p; ) {
      var g = 31 - tt(p), y = 1 << g;
      u[g] = -1, p &= ~y;
    }
    s !== 0 && HE(n, s, r);
  }
  function ml() {
    return (Ye & 6) === 0 ? (gs(0), !1) : !0;
  }
  function bd() {
    if (Ue !== null) {
      if (Xe === 0)
        var n = Ue.return;
      else
        n = Ue, Zn = tr = null, Lc(n), Vr = null, Zi = 0, n = Ue;
      for (; n !== null; )
        oT(n.alternate, n), n = n.return;
      Ue = null;
    }
  }
  function ai(n, r) {
    var s = n.timeoutHandle;
    s !== -1 && (n.timeoutHandle = -1, Vv(s)), s = n.cancelPendingCommit, s !== null && (n.cancelPendingCommit = null, s()), la = 0, bd(), nt = n, Ue = s = Xn(n.current, null), Pe = r, Xe = 0, ln = null, Ca = !1, ei = Di(n, r), dd = !1, ti = un = pd = cr = wa = dt = 0, Kt = fs = null, fd = !1, (r & 8) !== 0 && (r |= r & 32);
    var u = n.entangledLanes;
    if (u !== 0)
      for (n = n.entanglements, u &= r; 0 < u; ) {
        var p = 31 - tt(u), g = 1 << p;
        r |= n[p], u &= ~g;
      }
    return oa = r, Mo(), s;
  }
  function OT(n, r) {
    Ie = null, j.H = is, r === Yr || r === jo ? (r = V0(), Xe = 3) : r === Sc ? (r = V0(), Xe = 4) : Xe = r === Xc ? 8 : r !== null && typeof r == "object" && typeof r.then == "function" ? 6 : 1, ln = r, Ue === null && (dt = 1, al(
      n,
      hn(r, n.current)
    ));
  }
  function xT() {
    var n = sn.current;
    return n === null ? !0 : (Pe & 4194048) === Pe ? Tn === null : (Pe & 62914560) === Pe || (Pe & 536870912) !== 0 ? n === Tn : !1;
  }
  function LT() {
    var n = j.H;
    return j.H = is, n === null ? is : n;
  }
  function DT() {
    var n = j.A;
    return j.A = Rv, n;
  }
  function gl() {
    dt = 4, Ca || (Pe & 4194048) !== Pe && sn.current !== null || (ei = !0), (wa & 134217727) === 0 && (cr & 134217727) === 0 || nt === null || Oa(
      nt,
      Pe,
      un,
      !1
    );
  }
  function Ed(n, r, s) {
    var u = Ye;
    Ye |= 2;
    var p = LT(), g = DT();
    (nt !== n || Pe !== r) && (fl = null, ai(n, r)), r = !1;
    var y = dt;
    e: do
      try {
        if (Xe !== 0 && Ue !== null) {
          var A = Ue, P = ln;
          switch (Xe) {
            case 8:
              bd(), y = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              sn.current === null && (r = !0);
              var X = Xe;
              if (Xe = 0, ln = null, ri(n, A, P, X), s && ei) {
                y = 0;
                break e;
              }
              break;
            default:
              X = Xe, Xe = 0, ln = null, ri(n, A, P, X);
          }
        }
        wv(), y = dt;
        break;
      } catch (re) {
        OT(n, re);
      }
    while (!0);
    return r && n.shellSuspendCounter++, Zn = tr = null, Ye = u, j.H = p, j.A = g, Ue === null && (nt = null, Pe = 0, Mo()), y;
  }
  function wv() {
    for (; Ue !== null; ) MT(Ue);
  }
  function kv(n, r) {
    var s = Ye;
    Ye |= 2;
    var u = LT(), p = DT();
    nt !== n || Pe !== r ? (fl = null, pl = Pt() + 500, ai(n, r)) : ei = Di(
      n,
      r
    );
    e: do
      try {
        if (Xe !== 0 && Ue !== null) {
          r = Ue;
          var g = ln;
          t: switch (Xe) {
            case 1:
              Xe = 0, ln = null, ri(n, r, g, 1);
              break;
            case 2:
            case 9:
              if (q0(g)) {
                Xe = 0, ln = null, UT(r);
                break;
              }
              r = function() {
                Xe !== 2 && Xe !== 9 || nt !== n || (Xe = 7), Fn(n);
              }, g.then(r, r);
              break e;
            case 3:
              Xe = 7;
              break e;
            case 4:
              Xe = 5;
              break e;
            case 7:
              q0(g) ? (Xe = 0, ln = null, UT(r)) : (Xe = 0, ln = null, ri(n, r, g, 7));
              break;
            case 5:
              var y = null;
              switch (Ue.tag) {
                case 26:
                  y = Ue.memoizedState;
                case 5:
                case 27:
                  var A = Ue;
                  if (y ? SS(y) : A.stateNode.complete) {
                    Xe = 0, ln = null;
                    var P = A.sibling;
                    if (P !== null) Ue = P;
                    else {
                      var X = A.return;
                      X !== null ? (Ue = X, hl(X)) : Ue = null;
                    }
                    break t;
                  }
              }
              Xe = 0, ln = null, ri(n, r, g, 5);
              break;
            case 6:
              Xe = 0, ln = null, ri(n, r, g, 6);
              break;
            case 8:
              bd(), dt = 6;
              break e;
            default:
              throw Error(i(462));
          }
        }
        Iv();
        break;
      } catch (re) {
        OT(n, re);
      }
    while (!0);
    return Zn = tr = null, j.H = u, j.A = p, Ye = s, Ue !== null ? 0 : (nt = null, Pe = 0, Mo(), dt);
  }
  function Iv() {
    for (; Ue !== null && !Ou(); )
      MT(Ue);
  }
  function MT(n) {
    var r = iT(n.alternate, n, oa);
    n.memoizedProps = n.pendingProps, r === null ? hl(n) : Ue = r;
  }
  function UT(n) {
    var r = n, s = r.alternate;
    switch (r.tag) {
      case 15:
      case 0:
        r = Jy(
          s,
          r,
          r.pendingProps,
          r.type,
          void 0,
          Pe
        );
        break;
      case 11:
        r = Jy(
          s,
          r,
          r.pendingProps,
          r.type.render,
          r.ref,
          Pe
        );
        break;
      case 5:
        Lc(r);
      default:
        oT(s, r), r = Ue = D0(r, oa), r = iT(s, r, oa);
    }
    n.memoizedProps = n.pendingProps, r === null ? hl(n) : Ue = r;
  }
  function ri(n, r, s, u) {
    Zn = tr = null, Lc(r), Vr = null, Zi = 0;
    var p = r.return;
    try {
      if (Ev(
        n,
        p,
        r,
        s,
        Pe
      )) {
        dt = 1, al(
          n,
          hn(s, n.current)
        ), Ue = null;
        return;
      }
    } catch (g) {
      if (p !== null) throw Ue = p, g;
      dt = 1, al(
        n,
        hn(s, n.current)
      ), Ue = null;
      return;
    }
    r.flags & 32768 ? (Ge || u === 1 ? n = !0 : ei || (Pe & 536870912) !== 0 ? n = !1 : (Ca = n = !0, (u === 2 || u === 9 || u === 3 || u === 6) && (u = sn.current, u !== null && u.tag === 13 && (u.flags |= 16384))), BT(r, n)) : hl(r);
  }
  function hl(n) {
    var r = n;
    do {
      if ((r.flags & 32768) !== 0) {
        BT(
          r,
          Ca
        );
        return;
      }
      n = r.return;
      var s = Sv(
        r.alternate,
        r,
        oa
      );
      if (s !== null) {
        Ue = s;
        return;
      }
      if (r = r.sibling, r !== null) {
        Ue = r;
        return;
      }
      Ue = r = n;
    } while (r !== null);
    dt === 0 && (dt = 5);
  }
  function BT(n, r) {
    do {
      var s = _v(n.alternate, n);
      if (s !== null) {
        s.flags &= 32767, Ue = s;
        return;
      }
      if (s = n.return, s !== null && (s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null), !r && (n = n.sibling, n !== null)) {
        Ue = n;
        return;
      }
      Ue = n = s;
    } while (n !== null);
    dt = 6, Ue = null;
  }
  function FT(n, r, s, u, p, g, y, A, P) {
    n.cancelPendingCommit = null;
    do
      bl();
    while (St !== 0);
    if ((Ye & 6) !== 0) throw Error(i(327));
    if (r !== null) {
      if (r === n.current) throw Error(i(177));
      if (g = r.lanes | r.childLanes, g |= sc, uR(
        n,
        s,
        g,
        y,
        A,
        P
      ), n === nt && (Ue = nt = null, Pe = 0), ni = r, Ia = n, la = s, md = g, gd = p, CT = u, (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, Dv(we, function() {
        return jT(), null;
      })) : (n.callbackNode = null, n.callbackPriority = 0), u = (r.flags & 13878) !== 0, (r.subtreeFlags & 13878) !== 0 || u) {
        u = j.T, j.T = null, p = se.p, se.p = 2, y = Ye, Ye |= 4;
        try {
          Av(n, r, s);
        } finally {
          Ye = y, se.p = p, j.T = u;
        }
      }
      St = 1, PT(), HT(), zT();
    }
  }
  function PT() {
    if (St === 1) {
      St = 0;
      var n = Ia, r = ni, s = (r.flags & 13878) !== 0;
      if ((r.subtreeFlags & 13878) !== 0 || s) {
        s = j.T, j.T = null;
        var u = se.p;
        se.p = 2;
        var p = Ye;
        Ye |= 4;
        try {
          yT(r, n);
          var g = Id, y = R0(n.containerInfo), A = g.focusedElem, P = g.selectionRange;
          if (y !== A && A && A.ownerDocument && N0(
            A.ownerDocument.documentElement,
            A
          )) {
            if (P !== null && tc(A)) {
              var X = P.start, re = P.end;
              if (re === void 0 && (re = X), "selectionStart" in A)
                A.selectionStart = X, A.selectionEnd = Math.min(
                  re,
                  A.value.length
                );
              else {
                var le = A.ownerDocument || document, Z = le && le.defaultView || window;
                if (Z.getSelection) {
                  var J = Z.getSelection(), Te = A.textContent.length, Ce = Math.min(P.start, Te), et = P.end === void 0 ? Ce : Math.min(P.end, Te);
                  !J.extend && Ce > et && (y = et, et = Ce, Ce = y);
                  var $ = A0(
                    A,
                    Ce
                  ), H = A0(
                    A,
                    et
                  );
                  if ($ && H && (J.rangeCount !== 1 || J.anchorNode !== $.node || J.anchorOffset !== $.offset || J.focusNode !== H.node || J.focusOffset !== H.offset)) {
                    var W = le.createRange();
                    W.setStart($.node, $.offset), J.removeAllRanges(), Ce > et ? (J.addRange(W), J.extend(H.node, H.offset)) : (W.setEnd(H.node, H.offset), J.addRange(W));
                  }
                }
              }
            }
            for (le = [], J = A; J = J.parentNode; )
              J.nodeType === 1 && le.push({
                element: J,
                left: J.scrollLeft,
                top: J.scrollTop
              });
            for (typeof A.focus == "function" && A.focus(), A = 0; A < le.length; A++) {
              var oe = le[A];
              oe.element.scrollLeft = oe.left, oe.element.scrollTop = oe.top;
            }
          }
          kl = !!kd, Id = kd = null;
        } finally {
          Ye = p, se.p = u, j.T = s;
        }
      }
      n.current = r, St = 2;
    }
  }
  function HT() {
    if (St === 2) {
      St = 0;
      var n = Ia, r = ni, s = (r.flags & 8772) !== 0;
      if ((r.subtreeFlags & 8772) !== 0 || s) {
        s = j.T, j.T = null;
        var u = se.p;
        se.p = 2;
        var p = Ye;
        Ye |= 4;
        try {
          mT(n, r.alternate, r);
        } finally {
          Ye = p, se.p = u, j.T = s;
        }
      }
      St = 3;
    }
  }
  function zT() {
    if (St === 4 || St === 3) {
      St = 0, xu();
      var n = Ia, r = ni, s = la, u = CT;
      (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? St = 5 : (St = 0, ni = Ia = null, GT(n, n.pendingLanes));
      var p = n.pendingLanes;
      if (p === 0 && (ka = null), Uu(s), r = r.stateNode, Tt && typeof Tt.onCommitFiberRoot == "function")
        try {
          Tt.onCommitFiberRoot(
            Ht,
            r,
            void 0,
            (r.current.flags & 128) === 128
          );
        } catch {
        }
      if (u !== null) {
        r = j.T, p = se.p, se.p = 2, j.T = null;
        try {
          for (var g = n.onRecoverableError, y = 0; y < u.length; y++) {
            var A = u[y];
            g(A.value, {
              componentStack: A.stack
            });
          }
        } finally {
          j.T = r, se.p = p;
        }
      }
      (la & 3) !== 0 && bl(), Fn(n), p = n.pendingLanes, (s & 261930) !== 0 && (p & 42) !== 0 ? n === hd ? ms++ : (ms = 0, hd = n) : ms = 0, gs(0);
    }
  }
  function GT(n, r) {
    (n.pooledCacheLanes &= r) === 0 && (r = n.pooledCache, r != null && (n.pooledCache = null, Xi(r)));
  }
  function bl() {
    return PT(), HT(), zT(), jT();
  }
  function jT() {
    if (St !== 5) return !1;
    var n = Ia, r = md;
    md = 0;
    var s = Uu(la), u = j.T, p = se.p;
    try {
      se.p = 32 > s ? 32 : s, j.T = null, s = gd, gd = null;
      var g = Ia, y = la;
      if (St = 0, ni = Ia = null, la = 0, (Ye & 6) !== 0) throw Error(i(331));
      var A = Ye;
      if (Ye |= 4, NT(g.current), ST(
        g,
        g.current,
        y,
        s
      ), Ye = A, gs(0, !1), Tt && typeof Tt.onPostCommitFiberRoot == "function")
        try {
          Tt.onPostCommitFiberRoot(Ht, g);
        } catch {
        }
      return !0;
    } finally {
      se.p = p, j.T = u, GT(n, r);
    }
  }
  function $T(n, r, s) {
    r = hn(s, r), r = Wc(n.stateNode, r, 2), n = Aa(n, r, 2), n !== null && (Mi(n, 2), Fn(n));
  }
  function Ke(n, r, s) {
    if (n.tag === 3)
      $T(n, n, s);
    else
      for (; r !== null; ) {
        if (r.tag === 3) {
          $T(
            r,
            n,
            s
          );
          break;
        } else if (r.tag === 1) {
          var u = r.stateNode;
          if (typeof r.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (ka === null || !ka.has(u))) {
            n = hn(s, n), s = qy(2), u = Aa(r, s, 2), u !== null && (Yy(
              s,
              u,
              r,
              n
            ), Mi(u, 2), Fn(u));
            break;
          }
        }
        r = r.return;
      }
  }
  function yd(n, r, s) {
    var u = n.pingCache;
    if (u === null) {
      u = n.pingCache = new vv();
      var p = /* @__PURE__ */ new Set();
      u.set(r, p);
    } else
      p = u.get(r), p === void 0 && (p = /* @__PURE__ */ new Set(), u.set(r, p));
    p.has(s) || (dd = !0, p.add(s), n = Ov.bind(null, n, r, s), r.then(n, n));
  }
  function Ov(n, r, s) {
    var u = n.pingCache;
    u !== null && u.delete(r), n.pingedLanes |= n.suspendedLanes & s, n.warmLanes &= ~s, nt === n && (Pe & s) === s && (dt === 4 || dt === 3 && (Pe & 62914560) === Pe && 300 > Pt() - dl ? (Ye & 2) === 0 && ai(n, 0) : pd |= s, ti === Pe && (ti = 0)), Fn(n);
  }
  function qT(n, r) {
    r === 0 && (r = PE()), n = Qa(n, r), n !== null && (Mi(n, r), Fn(n));
  }
  function xv(n) {
    var r = n.memoizedState, s = 0;
    r !== null && (s = r.retryLane), qT(n, s);
  }
  function Lv(n, r) {
    var s = 0;
    switch (n.tag) {
      case 31:
      case 13:
        var u = n.stateNode, p = n.memoizedState;
        p !== null && (s = p.retryLane);
        break;
      case 19:
        u = n.stateNode;
        break;
      case 22:
        u = n.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    u !== null && u.delete(r), qT(n, s);
  }
  function Dv(n, r) {
    return Rr(n, r);
  }
  var El = null, ii = null, Td = !1, yl = !1, Sd = !1, xa = 0;
  function Fn(n) {
    n !== ii && n.next === null && (ii === null ? El = ii = n : ii = ii.next = n), yl = !0, Td || (Td = !0, Uv());
  }
  function gs(n, r) {
    if (!Sd && yl) {
      Sd = !0;
      do
        for (var s = !1, u = El; u !== null; ) {
          if (n !== 0) {
            var p = u.pendingLanes;
            if (p === 0) var g = 0;
            else {
              var y = u.suspendedLanes, A = u.pingedLanes;
              g = (1 << 31 - tt(42 | n) + 1) - 1, g &= p & ~(y & ~A), g = g & 201326741 ? g & 201326741 | 1 : g ? g | 2 : 0;
            }
            g !== 0 && (s = !0, XT(u, g));
          } else
            g = Pe, g = Ao(
              u,
              u === nt ? g : 0,
              u.cancelPendingCommit !== null || u.timeoutHandle !== -1
            ), (g & 3) === 0 || Di(u, g) || (s = !0, XT(u, g));
          u = u.next;
        }
      while (s);
      Sd = !1;
    }
  }
  function Mv() {
    YT();
  }
  function YT() {
    yl = Td = !1;
    var n = 0;
    xa !== 0 && Yv() && (n = xa);
    for (var r = Pt(), s = null, u = El; u !== null; ) {
      var p = u.next, g = VT(u, r);
      g === 0 ? (u.next = null, s === null ? El = p : s.next = p, p === null && (ii = s)) : (s = u, (n !== 0 || (g & 3) !== 0) && (yl = !0)), u = p;
    }
    St !== 0 && St !== 5 || gs(n), xa !== 0 && (xa = 0);
  }
  function VT(n, r) {
    for (var s = n.suspendedLanes, u = n.pingedLanes, p = n.expirationTimes, g = n.pendingLanes & -62914561; 0 < g; ) {
      var y = 31 - tt(g), A = 1 << y, P = p[y];
      P === -1 ? ((A & s) === 0 || (A & u) !== 0) && (p[y] = lR(A, r)) : P <= r && (n.expiredLanes |= A), g &= ~A;
    }
    if (r = nt, s = Pe, s = Ao(
      n,
      n === r ? s : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), u = n.callbackNode, s === 0 || n === r && (Xe === 2 || Xe === 9) || n.cancelPendingCommit !== null)
      return u !== null && u !== null && Li(u), n.callbackNode = null, n.callbackPriority = 0;
    if ((s & 3) === 0 || Di(n, s)) {
      if (r = s & -s, r === n.callbackPriority) return r;
      switch (u !== null && Li(u), Uu(s)) {
        case 2:
        case 8:
          s = be;
          break;
        case 32:
          s = we;
          break;
        case 268435456:
          s = We;
          break;
        default:
          s = we;
      }
      return u = WT.bind(null, n), s = Rr(s, u), n.callbackPriority = r, n.callbackNode = s, r;
    }
    return u !== null && u !== null && Li(u), n.callbackPriority = 2, n.callbackNode = null, 2;
  }
  function WT(n, r) {
    if (St !== 0 && St !== 5)
      return n.callbackNode = null, n.callbackPriority = 0, null;
    var s = n.callbackNode;
    if (bl() && n.callbackNode !== s)
      return null;
    var u = Pe;
    return u = Ao(
      n,
      n === nt ? u : 0,
      n.cancelPendingCommit !== null || n.timeoutHandle !== -1
    ), u === 0 ? null : (kT(n, u, r), VT(n, Pt()), n.callbackNode != null && n.callbackNode === s ? WT.bind(null, n) : null);
  }
  function XT(n, r) {
    if (bl()) return null;
    kT(n, r, !0);
  }
  function Uv() {
    Wv(function() {
      (Ye & 6) !== 0 ? Rr(
        ie,
        Mv
      ) : YT();
    });
  }
  function _d() {
    if (xa === 0) {
      var n = $r;
      n === 0 && (n = To, To <<= 1, (To & 261888) === 0 && (To = 256)), xa = n;
    }
    return xa;
  }
  function KT(n) {
    return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Co("" + n);
  }
  function ZT(n, r) {
    var s = r.ownerDocument.createElement("input");
    return s.name = r.name, s.value = r.value, n.id && s.setAttribute("form", n.id), r.parentNode.insertBefore(s, r), n = new FormData(n), s.parentNode.removeChild(s), n;
  }
  function Bv(n, r, s, u, p) {
    if (r === "submit" && s && s.stateNode === p) {
      var g = KT(
        (p[qt] || null).action
      ), y = u.submitter;
      y && (r = (r = y[qt] || null) ? KT(r.formAction) : y.getAttribute("formAction"), r !== null && (g = r, y = null));
      var A = new Oo(
        "action",
        "action",
        null,
        u,
        p
      );
      n.push({
        event: A,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (u.defaultPrevented) {
                if (xa !== 0) {
                  var P = y ? ZT(p, y) : new FormData(p);
                  Gc(
                    s,
                    {
                      pending: !0,
                      data: P,
                      method: p.method,
                      action: g
                    },
                    null,
                    P
                  );
                }
              } else
                typeof g == "function" && (A.preventDefault(), P = y ? ZT(p, y) : new FormData(p), Gc(
                  s,
                  {
                    pending: !0,
                    data: P,
                    method: p.method,
                    action: g
                  },
                  g,
                  P
                ));
            },
            currentTarget: p
          }
        ]
      });
    }
  }
  for (var Ad = 0; Ad < ic.length; Ad++) {
    var Nd = ic[Ad], Fv = Nd.toLowerCase(), Pv = Nd[0].toUpperCase() + Nd.slice(1);
    wn(
      Fv,
      "on" + Pv
    );
  }
  wn(w0, "onAnimationEnd"), wn(k0, "onAnimationIteration"), wn(I0, "onAnimationStart"), wn("dblclick", "onDoubleClick"), wn("focusin", "onFocus"), wn("focusout", "onBlur"), wn(tv, "onTransitionRun"), wn(nv, "onTransitionStart"), wn(av, "onTransitionCancel"), wn(O0, "onTransitionEnd"), Ir("onMouseEnter", ["mouseout", "mouseover"]), Ir("onMouseLeave", ["mouseout", "mouseover"]), Ir("onPointerEnter", ["pointerout", "pointerover"]), Ir("onPointerLeave", ["pointerout", "pointerover"]), Wa(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Wa(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Wa("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Wa(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Wa(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Wa(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var hs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), Hv = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(hs)
  );
  function QT(n, r) {
    r = (r & 4) !== 0;
    for (var s = 0; s < n.length; s++) {
      var u = n[s], p = u.event;
      u = u.listeners;
      e: {
        var g = void 0;
        if (r)
          for (var y = u.length - 1; 0 <= y; y--) {
            var A = u[y], P = A.instance, X = A.currentTarget;
            if (A = A.listener, P !== g && p.isPropagationStopped())
              break e;
            g = A, p.currentTarget = X;
            try {
              g(p);
            } catch (re) {
              Do(re);
            }
            p.currentTarget = null, g = P;
          }
        else
          for (y = 0; y < u.length; y++) {
            if (A = u[y], P = A.instance, X = A.currentTarget, A = A.listener, P !== g && p.isPropagationStopped())
              break e;
            g = A, p.currentTarget = X;
            try {
              g(p);
            } catch (re) {
              Do(re);
            }
            p.currentTarget = null, g = P;
          }
      }
    }
  }
  function Be(n, r) {
    var s = r[Bu];
    s === void 0 && (s = r[Bu] = /* @__PURE__ */ new Set());
    var u = n + "__bubble";
    s.has(u) || (JT(r, n, 2, !1), s.add(u));
  }
  function Rd(n, r, s) {
    var u = 0;
    r && (u |= 4), JT(
      s,
      n,
      u,
      r
    );
  }
  var Tl = "_reactListening" + Math.random().toString(36).slice(2);
  function vd(n) {
    if (!n[Tl]) {
      n[Tl] = !0, YE.forEach(function(s) {
        s !== "selectionchange" && (Hv.has(s) || Rd(s, !1, n), Rd(s, !0, n));
      });
      var r = n.nodeType === 9 ? n : n.ownerDocument;
      r === null || r[Tl] || (r[Tl] = !0, Rd("selectionchange", !1, r));
    }
  }
  function JT(n, r, s, u) {
    switch (wS(r)) {
      case 2:
        var p = mC;
        break;
      case 8:
        p = gC;
        break;
      default:
        p = zd;
    }
    s = p.bind(
      null,
      r,
      s,
      n
    ), p = void 0, !Yu || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (p = !0), u ? p !== void 0 ? n.addEventListener(r, s, {
      capture: !0,
      passive: p
    }) : n.addEventListener(r, s, !0) : p !== void 0 ? n.addEventListener(r, s, {
      passive: p
    }) : n.addEventListener(r, s, !1);
  }
  function Cd(n, r, s, u, p) {
    var g = u;
    if ((r & 1) === 0 && (r & 2) === 0 && u !== null)
      e: for (; ; ) {
        if (u === null) return;
        var y = u.tag;
        if (y === 3 || y === 4) {
          var A = u.stateNode.containerInfo;
          if (A === p) break;
          if (y === 4)
            for (y = u.return; y !== null; ) {
              var P = y.tag;
              if ((P === 3 || P === 4) && y.stateNode.containerInfo === p)
                return;
              y = y.return;
            }
          for (; A !== null; ) {
            if (y = Cr(A), y === null) return;
            if (P = y.tag, P === 5 || P === 6 || P === 26 || P === 27) {
              u = g = y;
              continue e;
            }
            A = A.parentNode;
          }
        }
        u = u.return;
      }
    r0(function() {
      var X = g, re = $u(s), le = [];
      e: {
        var Z = x0.get(n);
        if (Z !== void 0) {
          var J = Oo, Te = n;
          switch (n) {
            case "keypress":
              if (ko(s) === 0) break e;
            case "keydown":
            case "keyup":
              J = LR;
              break;
            case "focusin":
              Te = "focus", J = Ku;
              break;
            case "focusout":
              Te = "blur", J = Ku;
              break;
            case "beforeblur":
            case "afterblur":
              J = Ku;
              break;
            case "click":
              if (s.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              J = o0;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              J = SR;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              J = UR;
              break;
            case w0:
            case k0:
            case I0:
              J = NR;
              break;
            case O0:
              J = FR;
              break;
            case "scroll":
            case "scrollend":
              J = yR;
              break;
            case "wheel":
              J = HR;
              break;
            case "copy":
            case "cut":
            case "paste":
              J = vR;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              J = u0;
              break;
            case "toggle":
            case "beforetoggle":
              J = GR;
          }
          var Ce = (r & 4) !== 0, et = !Ce && (n === "scroll" || n === "scrollend"), $ = Ce ? Z !== null ? Z + "Capture" : null : Z;
          Ce = [];
          for (var H = X, W; H !== null; ) {
            var oe = H;
            if (W = oe.stateNode, oe = oe.tag, oe !== 5 && oe !== 26 && oe !== 27 || W === null || $ === null || (oe = Fi(H, $), oe != null && Ce.push(
              bs(H, oe, W)
            )), et) break;
            H = H.return;
          }
          0 < Ce.length && (Z = new J(
            Z,
            Te,
            null,
            s,
            re
          ), le.push({ event: Z, listeners: Ce }));
        }
      }
      if ((r & 7) === 0) {
        e: {
          if (Z = n === "mouseover" || n === "pointerover", J = n === "mouseout" || n === "pointerout", Z && s !== ju && (Te = s.relatedTarget || s.fromElement) && (Cr(Te) || Te[vr]))
            break e;
          if ((J || Z) && (Z = re.window === re ? re : (Z = re.ownerDocument) ? Z.defaultView || Z.parentWindow : window, J ? (Te = s.relatedTarget || s.toElement, J = X, Te = Te ? Cr(Te) : null, Te !== null && (et = l(Te), Ce = Te.tag, Te !== et || Ce !== 5 && Ce !== 27 && Ce !== 6) && (Te = null)) : (J = null, Te = X), J !== Te)) {
            if (Ce = o0, oe = "onMouseLeave", $ = "onMouseEnter", H = "mouse", (n === "pointerout" || n === "pointerover") && (Ce = u0, oe = "onPointerLeave", $ = "onPointerEnter", H = "pointer"), et = J == null ? Z : Bi(J), W = Te == null ? Z : Bi(Te), Z = new Ce(
              oe,
              H + "leave",
              J,
              s,
              re
            ), Z.target = et, Z.relatedTarget = W, oe = null, Cr(re) === X && (Ce = new Ce(
              $,
              H + "enter",
              Te,
              s,
              re
            ), Ce.target = W, Ce.relatedTarget = et, oe = Ce), et = oe, J && Te)
              t: {
                for (Ce = zv, $ = J, H = Te, W = 0, oe = $; oe; oe = Ce(oe))
                  W++;
                oe = 0;
                for (var Ae = H; Ae; Ae = Ce(Ae))
                  oe++;
                for (; 0 < W - oe; )
                  $ = Ce($), W--;
                for (; 0 < oe - W; )
                  H = Ce(H), oe--;
                for (; W--; ) {
                  if ($ === H || H !== null && $ === H.alternate) {
                    Ce = $;
                    break t;
                  }
                  $ = Ce($), H = Ce(H);
                }
                Ce = null;
              }
            else Ce = null;
            J !== null && eS(
              le,
              Z,
              J,
              Ce,
              !1
            ), Te !== null && et !== null && eS(
              le,
              et,
              Te,
              Ce,
              !0
            );
          }
        }
        e: {
          if (Z = X ? Bi(X) : window, J = Z.nodeName && Z.nodeName.toLowerCase(), J === "select" || J === "input" && Z.type === "file")
            var $e = b0;
          else if (g0(Z))
            if (E0)
              $e = QR;
            else {
              $e = KR;
              var Se = XR;
            }
          else
            J = Z.nodeName, !J || J.toLowerCase() !== "input" || Z.type !== "checkbox" && Z.type !== "radio" ? X && Gu(X.elementType) && ($e = b0) : $e = ZR;
          if ($e && ($e = $e(n, X))) {
            h0(
              le,
              $e,
              s,
              re
            );
            break e;
          }
          Se && Se(n, Z, X), n === "focusout" && X && Z.type === "number" && X.memoizedProps.value != null && zu(Z, "number", Z.value);
        }
        switch (Se = X ? Bi(X) : window, n) {
          case "focusin":
            (g0(Se) || Se.contentEditable === "true") && (Ur = Se, nc = X, Yi = null);
            break;
          case "focusout":
            Yi = nc = Ur = null;
            break;
          case "mousedown":
            ac = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ac = !1, v0(le, s, re);
            break;
          case "selectionchange":
            if (ev) break;
          case "keydown":
          case "keyup":
            v0(le, s, re);
        }
        var Oe;
        if (Qu)
          e: {
            switch (n) {
              case "compositionstart":
                var He = "onCompositionStart";
                break e;
              case "compositionend":
                He = "onCompositionEnd";
                break e;
              case "compositionupdate":
                He = "onCompositionUpdate";
                break e;
            }
            He = void 0;
          }
        else
          Mr ? f0(n, s) && (He = "onCompositionEnd") : n === "keydown" && s.keyCode === 229 && (He = "onCompositionStart");
        He && (c0 && s.locale !== "ko" && (Mr || He !== "onCompositionStart" ? He === "onCompositionEnd" && Mr && (Oe = i0()) : (ha = re, Vu = "value" in ha ? ha.value : ha.textContent, Mr = !0)), Se = Sl(X, He), 0 < Se.length && (He = new l0(
          He,
          n,
          null,
          s,
          re
        ), le.push({ event: He, listeners: Se }), Oe ? He.data = Oe : (Oe = m0(s), Oe !== null && (He.data = Oe)))), (Oe = $R ? qR(n, s) : YR(n, s)) && (He = Sl(X, "onBeforeInput"), 0 < He.length && (Se = new l0(
          "onBeforeInput",
          "beforeinput",
          null,
          s,
          re
        ), le.push({
          event: Se,
          listeners: He
        }), Se.data = Oe)), Bv(
          le,
          n,
          X,
          s,
          re
        );
      }
      QT(le, r);
    });
  }
  function bs(n, r, s) {
    return {
      instance: n,
      listener: r,
      currentTarget: s
    };
  }
  function Sl(n, r) {
    for (var s = r + "Capture", u = []; n !== null; ) {
      var p = n, g = p.stateNode;
      if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || g === null || (p = Fi(n, s), p != null && u.unshift(
        bs(n, p, g)
      ), p = Fi(n, r), p != null && u.push(
        bs(n, p, g)
      )), n.tag === 3) return u;
      n = n.return;
    }
    return [];
  }
  function zv(n) {
    if (n === null) return null;
    do
      n = n.return;
    while (n && n.tag !== 5 && n.tag !== 27);
    return n || null;
  }
  function eS(n, r, s, u, p) {
    for (var g = r._reactName, y = []; s !== null && s !== u; ) {
      var A = s, P = A.alternate, X = A.stateNode;
      if (A = A.tag, P !== null && P === u) break;
      A !== 5 && A !== 26 && A !== 27 || X === null || (P = X, p ? (X = Fi(s, g), X != null && y.unshift(
        bs(s, X, P)
      )) : p || (X = Fi(s, g), X != null && y.push(
        bs(s, X, P)
      ))), s = s.return;
    }
    y.length !== 0 && n.push({ event: r, listeners: y });
  }
  var Gv = /\r\n?/g, jv = /\u0000|\uFFFD/g;
  function tS(n) {
    return (typeof n == "string" ? n : "" + n).replace(Gv, `
`).replace(jv, "");
  }
  function nS(n, r) {
    return r = tS(r), tS(n) === r;
  }
  function Je(n, r, s, u, p, g) {
    switch (s) {
      case "children":
        typeof u == "string" ? r === "body" || r === "textarea" && u === "" || xr(n, u) : (typeof u == "number" || typeof u == "bigint") && r !== "body" && xr(n, "" + u);
        break;
      case "className":
        Ro(n, "class", u);
        break;
      case "tabIndex":
        Ro(n, "tabindex", u);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Ro(n, s, u);
        break;
      case "style":
        n0(n, u, g);
        break;
      case "data":
        if (r !== "object") {
          Ro(n, "data", u);
          break;
        }
      case "src":
      case "href":
        if (u === "" && (r !== "a" || s !== "href")) {
          n.removeAttribute(s);
          break;
        }
        if (u == null || typeof u == "function" || typeof u == "symbol" || typeof u == "boolean") {
          n.removeAttribute(s);
          break;
        }
        u = Co("" + u), n.setAttribute(s, u);
        break;
      case "action":
      case "formAction":
        if (typeof u == "function") {
          n.setAttribute(
            s,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof g == "function" && (s === "formAction" ? (r !== "input" && Je(n, r, "name", p.name, p, null), Je(
            n,
            r,
            "formEncType",
            p.formEncType,
            p,
            null
          ), Je(
            n,
            r,
            "formMethod",
            p.formMethod,
            p,
            null
          ), Je(
            n,
            r,
            "formTarget",
            p.formTarget,
            p,
            null
          )) : (Je(n, r, "encType", p.encType, p, null), Je(n, r, "method", p.method, p, null), Je(n, r, "target", p.target, p, null)));
        if (u == null || typeof u == "symbol" || typeof u == "boolean") {
          n.removeAttribute(s);
          break;
        }
        u = Co("" + u), n.setAttribute(s, u);
        break;
      case "onClick":
        u != null && (n.onclick = Vn);
        break;
      case "onScroll":
        u != null && Be("scroll", n);
        break;
      case "onScrollEnd":
        u != null && Be("scrollend", n);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(i(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(i(60));
            n.innerHTML = s;
          }
        }
        break;
      case "multiple":
        n.multiple = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "muted":
        n.muted = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (u == null || typeof u == "function" || typeof u == "boolean" || typeof u == "symbol") {
          n.removeAttribute("xlink:href");
          break;
        }
        s = Co("" + u), n.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          s
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        u != null && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(s, "" + u) : n.removeAttribute(s);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        u && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(s, "") : n.removeAttribute(s);
        break;
      case "capture":
      case "download":
        u === !0 ? n.setAttribute(s, "") : u !== !1 && u != null && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(s, u) : n.removeAttribute(s);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        u != null && typeof u != "function" && typeof u != "symbol" && !isNaN(u) && 1 <= u ? n.setAttribute(s, u) : n.removeAttribute(s);
        break;
      case "rowSpan":
      case "start":
        u == null || typeof u == "function" || typeof u == "symbol" || isNaN(u) ? n.removeAttribute(s) : n.setAttribute(s, u);
        break;
      case "popover":
        Be("beforetoggle", n), Be("toggle", n), No(n, "popover", u);
        break;
      case "xlinkActuate":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          u
        );
        break;
      case "xlinkArcrole":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          u
        );
        break;
      case "xlinkRole":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          u
        );
        break;
      case "xlinkShow":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          u
        );
        break;
      case "xlinkTitle":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          u
        );
        break;
      case "xlinkType":
        Yn(
          n,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          u
        );
        break;
      case "xmlBase":
        Yn(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          u
        );
        break;
      case "xmlLang":
        Yn(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          u
        );
        break;
      case "xmlSpace":
        Yn(
          n,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          u
        );
        break;
      case "is":
        No(n, "is", u);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (s = bR.get(s) || s, No(n, s, u));
    }
  }
  function wd(n, r, s, u, p, g) {
    switch (s) {
      case "style":
        n0(n, u, g);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(i(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(i(60));
            n.innerHTML = s;
          }
        }
        break;
      case "children":
        typeof u == "string" ? xr(n, u) : (typeof u == "number" || typeof u == "bigint") && xr(n, "" + u);
        break;
      case "onScroll":
        u != null && Be("scroll", n);
        break;
      case "onScrollEnd":
        u != null && Be("scrollend", n);
        break;
      case "onClick":
        u != null && (n.onclick = Vn);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!VE.hasOwnProperty(s))
          e: {
            if (s[0] === "o" && s[1] === "n" && (p = s.endsWith("Capture"), r = s.slice(2, p ? s.length - 7 : void 0), g = n[qt] || null, g = g != null ? g[s] : null, typeof g == "function" && n.removeEventListener(r, g, p), typeof u == "function")) {
              typeof g != "function" && g !== null && (s in n ? n[s] = null : n.hasAttribute(s) && n.removeAttribute(s)), n.addEventListener(r, u, p);
              break e;
            }
            s in n ? n[s] = u : u === !0 ? n.setAttribute(s, "") : No(n, s, u);
          }
    }
  }
  function Ot(n, r, s) {
    switch (r) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Be("error", n), Be("load", n);
        var u = !1, p = !1, g;
        for (g in s)
          if (s.hasOwnProperty(g)) {
            var y = s[g];
            if (y != null)
              switch (g) {
                case "src":
                  u = !0;
                  break;
                case "srcSet":
                  p = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, r));
                default:
                  Je(n, r, g, y, s, null);
              }
          }
        p && Je(n, r, "srcSet", s.srcSet, s, null), u && Je(n, r, "src", s.src, s, null);
        return;
      case "input":
        Be("invalid", n);
        var A = g = y = p = null, P = null, X = null;
        for (u in s)
          if (s.hasOwnProperty(u)) {
            var re = s[u];
            if (re != null)
              switch (u) {
                case "name":
                  p = re;
                  break;
                case "type":
                  y = re;
                  break;
                case "checked":
                  P = re;
                  break;
                case "defaultChecked":
                  X = re;
                  break;
                case "value":
                  g = re;
                  break;
                case "defaultValue":
                  A = re;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (re != null)
                    throw Error(i(137, r));
                  break;
                default:
                  Je(n, r, u, re, s, null);
              }
          }
        QE(
          n,
          g,
          A,
          P,
          X,
          y,
          p,
          !1
        );
        return;
      case "select":
        Be("invalid", n), u = y = g = null;
        for (p in s)
          if (s.hasOwnProperty(p) && (A = s[p], A != null))
            switch (p) {
              case "value":
                g = A;
                break;
              case "defaultValue":
                y = A;
                break;
              case "multiple":
                u = A;
              default:
                Je(n, r, p, A, s, null);
            }
        r = g, s = y, n.multiple = !!u, r != null ? Or(n, !!u, r, !1) : s != null && Or(n, !!u, s, !0);
        return;
      case "textarea":
        Be("invalid", n), g = p = u = null;
        for (y in s)
          if (s.hasOwnProperty(y) && (A = s[y], A != null))
            switch (y) {
              case "value":
                u = A;
                break;
              case "defaultValue":
                p = A;
                break;
              case "children":
                g = A;
                break;
              case "dangerouslySetInnerHTML":
                if (A != null) throw Error(i(91));
                break;
              default:
                Je(n, r, y, A, s, null);
            }
        e0(n, u, p, g);
        return;
      case "option":
        for (P in s)
          if (s.hasOwnProperty(P) && (u = s[P], u != null))
            switch (P) {
              case "selected":
                n.selected = u && typeof u != "function" && typeof u != "symbol";
                break;
              default:
                Je(n, r, P, u, s, null);
            }
        return;
      case "dialog":
        Be("beforetoggle", n), Be("toggle", n), Be("cancel", n), Be("close", n);
        break;
      case "iframe":
      case "object":
        Be("load", n);
        break;
      case "video":
      case "audio":
        for (u = 0; u < hs.length; u++)
          Be(hs[u], n);
        break;
      case "image":
        Be("error", n), Be("load", n);
        break;
      case "details":
        Be("toggle", n);
        break;
      case "embed":
      case "source":
      case "link":
        Be("error", n), Be("load", n);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (X in s)
          if (s.hasOwnProperty(X) && (u = s[X], u != null))
            switch (X) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, r));
              default:
                Je(n, r, X, u, s, null);
            }
        return;
      default:
        if (Gu(r)) {
          for (re in s)
            s.hasOwnProperty(re) && (u = s[re], u !== void 0 && wd(
              n,
              r,
              re,
              u,
              s,
              void 0
            ));
          return;
        }
    }
    for (A in s)
      s.hasOwnProperty(A) && (u = s[A], u != null && Je(n, r, A, u, s, null));
  }
  function $v(n, r, s, u) {
    switch (r) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var p = null, g = null, y = null, A = null, P = null, X = null, re = null;
        for (J in s) {
          var le = s[J];
          if (s.hasOwnProperty(J) && le != null)
            switch (J) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                P = le;
              default:
                u.hasOwnProperty(J) || Je(n, r, J, null, u, le);
            }
        }
        for (var Z in u) {
          var J = u[Z];
          if (le = s[Z], u.hasOwnProperty(Z) && (J != null || le != null))
            switch (Z) {
              case "type":
                g = J;
                break;
              case "name":
                p = J;
                break;
              case "checked":
                X = J;
                break;
              case "defaultChecked":
                re = J;
                break;
              case "value":
                y = J;
                break;
              case "defaultValue":
                A = J;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (J != null)
                  throw Error(i(137, r));
                break;
              default:
                J !== le && Je(
                  n,
                  r,
                  Z,
                  J,
                  u,
                  le
                );
            }
        }
        Hu(
          n,
          y,
          A,
          P,
          X,
          re,
          g,
          p
        );
        return;
      case "select":
        J = y = A = Z = null;
        for (g in s)
          if (P = s[g], s.hasOwnProperty(g) && P != null)
            switch (g) {
              case "value":
                break;
              case "multiple":
                J = P;
              default:
                u.hasOwnProperty(g) || Je(
                  n,
                  r,
                  g,
                  null,
                  u,
                  P
                );
            }
        for (p in u)
          if (g = u[p], P = s[p], u.hasOwnProperty(p) && (g != null || P != null))
            switch (p) {
              case "value":
                Z = g;
                break;
              case "defaultValue":
                A = g;
                break;
              case "multiple":
                y = g;
              default:
                g !== P && Je(
                  n,
                  r,
                  p,
                  g,
                  u,
                  P
                );
            }
        r = A, s = y, u = J, Z != null ? Or(n, !!s, Z, !1) : !!u != !!s && (r != null ? Or(n, !!s, r, !0) : Or(n, !!s, s ? [] : "", !1));
        return;
      case "textarea":
        J = Z = null;
        for (A in s)
          if (p = s[A], s.hasOwnProperty(A) && p != null && !u.hasOwnProperty(A))
            switch (A) {
              case "value":
                break;
              case "children":
                break;
              default:
                Je(n, r, A, null, u, p);
            }
        for (y in u)
          if (p = u[y], g = s[y], u.hasOwnProperty(y) && (p != null || g != null))
            switch (y) {
              case "value":
                Z = p;
                break;
              case "defaultValue":
                J = p;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (p != null) throw Error(i(91));
                break;
              default:
                p !== g && Je(n, r, y, p, u, g);
            }
        JE(n, Z, J);
        return;
      case "option":
        for (var Te in s)
          if (Z = s[Te], s.hasOwnProperty(Te) && Z != null && !u.hasOwnProperty(Te))
            switch (Te) {
              case "selected":
                n.selected = !1;
                break;
              default:
                Je(
                  n,
                  r,
                  Te,
                  null,
                  u,
                  Z
                );
            }
        for (P in u)
          if (Z = u[P], J = s[P], u.hasOwnProperty(P) && Z !== J && (Z != null || J != null))
            switch (P) {
              case "selected":
                n.selected = Z && typeof Z != "function" && typeof Z != "symbol";
                break;
              default:
                Je(
                  n,
                  r,
                  P,
                  Z,
                  u,
                  J
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ce in s)
          Z = s[Ce], s.hasOwnProperty(Ce) && Z != null && !u.hasOwnProperty(Ce) && Je(n, r, Ce, null, u, Z);
        for (X in u)
          if (Z = u[X], J = s[X], u.hasOwnProperty(X) && Z !== J && (Z != null || J != null))
            switch (X) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Z != null)
                  throw Error(i(137, r));
                break;
              default:
                Je(
                  n,
                  r,
                  X,
                  Z,
                  u,
                  J
                );
            }
        return;
      default:
        if (Gu(r)) {
          for (var et in s)
            Z = s[et], s.hasOwnProperty(et) && Z !== void 0 && !u.hasOwnProperty(et) && wd(
              n,
              r,
              et,
              void 0,
              u,
              Z
            );
          for (re in u)
            Z = u[re], J = s[re], !u.hasOwnProperty(re) || Z === J || Z === void 0 && J === void 0 || wd(
              n,
              r,
              re,
              Z,
              u,
              J
            );
          return;
        }
    }
    for (var $ in s)
      Z = s[$], s.hasOwnProperty($) && Z != null && !u.hasOwnProperty($) && Je(n, r, $, null, u, Z);
    for (le in u)
      Z = u[le], J = s[le], !u.hasOwnProperty(le) || Z === J || Z == null && J == null || Je(n, r, le, Z, u, J);
  }
  function aS(n) {
    switch (n) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function qv() {
    if (typeof performance.getEntriesByType == "function") {
      for (var n = 0, r = 0, s = performance.getEntriesByType("resource"), u = 0; u < s.length; u++) {
        var p = s[u], g = p.transferSize, y = p.initiatorType, A = p.duration;
        if (g && A && aS(y)) {
          for (y = 0, A = p.responseEnd, u += 1; u < s.length; u++) {
            var P = s[u], X = P.startTime;
            if (X > A) break;
            var re = P.transferSize, le = P.initiatorType;
            re && aS(le) && (P = P.responseEnd, y += re * (P < A ? 1 : (A - X) / (P - X)));
          }
          if (--u, r += 8 * (g + y) / (p.duration / 1e3), n++, 10 < n) break;
        }
      }
      if (0 < n) return r / n / 1e6;
    }
    return navigator.connection && (n = navigator.connection.downlink, typeof n == "number") ? n : 5;
  }
  var kd = null, Id = null;
  function _l(n) {
    return n.nodeType === 9 ? n : n.ownerDocument;
  }
  function rS(n) {
    switch (n) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function iS(n, r) {
    if (n === 0)
      switch (r) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return n === 1 && r === "foreignObject" ? 0 : n;
  }
  function Od(n, r) {
    return n === "textarea" || n === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.children == "bigint" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
  }
  var xd = null;
  function Yv() {
    var n = window.event;
    return n && n.type === "popstate" ? n === xd ? !1 : (xd = n, !0) : (xd = null, !1);
  }
  var sS = typeof setTimeout == "function" ? setTimeout : void 0, Vv = typeof clearTimeout == "function" ? clearTimeout : void 0, oS = typeof Promise == "function" ? Promise : void 0, Wv = typeof queueMicrotask == "function" ? queueMicrotask : typeof oS < "u" ? function(n) {
    return oS.resolve(null).then(n).catch(Xv);
  } : sS;
  function Xv(n) {
    setTimeout(function() {
      throw n;
    });
  }
  function La(n) {
    return n === "head";
  }
  function lS(n, r) {
    var s = r, u = 0;
    do {
      var p = s.nextSibling;
      if (n.removeChild(s), p && p.nodeType === 8)
        if (s = p.data, s === "/$" || s === "/&") {
          if (u === 0) {
            n.removeChild(p), ui(r);
            return;
          }
          u--;
        } else if (s === "$" || s === "$?" || s === "$~" || s === "$!" || s === "&")
          u++;
        else if (s === "html")
          Es(n.ownerDocument.documentElement);
        else if (s === "head") {
          s = n.ownerDocument.head, Es(s);
          for (var g = s.firstChild; g; ) {
            var y = g.nextSibling, A = g.nodeName;
            g[Ui] || A === "SCRIPT" || A === "STYLE" || A === "LINK" && g.rel.toLowerCase() === "stylesheet" || s.removeChild(g), g = y;
          }
        } else
          s === "body" && Es(n.ownerDocument.body);
      s = p;
    } while (s);
    ui(r);
  }
  function uS(n, r) {
    var s = n;
    n = 0;
    do {
      var u = s.nextSibling;
      if (s.nodeType === 1 ? r ? (s._stashedDisplay = s.style.display, s.style.display = "none") : (s.style.display = s._stashedDisplay || "", s.getAttribute("style") === "" && s.removeAttribute("style")) : s.nodeType === 3 && (r ? (s._stashedText = s.nodeValue, s.nodeValue = "") : s.nodeValue = s._stashedText || ""), u && u.nodeType === 8)
        if (s = u.data, s === "/$") {
          if (n === 0) break;
          n--;
        } else
          s !== "$" && s !== "$?" && s !== "$~" && s !== "$!" || n++;
      s = u;
    } while (s);
  }
  function Ld(n) {
    var r = n.firstChild;
    for (r && r.nodeType === 10 && (r = r.nextSibling); r; ) {
      var s = r;
      switch (r = r.nextSibling, s.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Ld(s), Fu(s);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (s.rel.toLowerCase() === "stylesheet") continue;
      }
      n.removeChild(s);
    }
  }
  function Kv(n, r, s, u) {
    for (; n.nodeType === 1; ) {
      var p = s;
      if (n.nodeName.toLowerCase() !== r.toLowerCase()) {
        if (!u && (n.nodeName !== "INPUT" || n.type !== "hidden"))
          break;
      } else if (u) {
        if (!n[Ui])
          switch (r) {
            case "meta":
              if (!n.hasAttribute("itemprop")) break;
              return n;
            case "link":
              if (g = n.getAttribute("rel"), g === "stylesheet" && n.hasAttribute("data-precedence"))
                break;
              if (g !== p.rel || n.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || n.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || n.getAttribute("title") !== (p.title == null ? null : p.title))
                break;
              return n;
            case "style":
              if (n.hasAttribute("data-precedence")) break;
              return n;
            case "script":
              if (g = n.getAttribute("src"), (g !== (p.src == null ? null : p.src) || n.getAttribute("type") !== (p.type == null ? null : p.type) || n.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && g && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                break;
              return n;
            default:
              return n;
          }
      } else if (r === "input" && n.type === "hidden") {
        var g = p.name == null ? null : "" + p.name;
        if (p.type === "hidden" && n.getAttribute("name") === g)
          return n;
      } else return n;
      if (n = Sn(n.nextSibling), n === null) break;
    }
    return null;
  }
  function Zv(n, r, s) {
    if (r === "") return null;
    for (; n.nodeType !== 3; )
      if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !s || (n = Sn(n.nextSibling), n === null)) return null;
    return n;
  }
  function cS(n, r) {
    for (; n.nodeType !== 8; )
      if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !r || (n = Sn(n.nextSibling), n === null)) return null;
    return n;
  }
  function Dd(n) {
    return n.data === "$?" || n.data === "$~";
  }
  function Md(n) {
    return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState !== "loading";
  }
  function Qv(n, r) {
    var s = n.ownerDocument;
    if (n.data === "$~") n._reactRetry = r;
    else if (n.data !== "$?" || s.readyState !== "loading")
      r();
    else {
      var u = function() {
        r(), s.removeEventListener("DOMContentLoaded", u);
      };
      s.addEventListener("DOMContentLoaded", u), n._reactRetry = u;
    }
  }
  function Sn(n) {
    for (; n != null; n = n.nextSibling) {
      var r = n.nodeType;
      if (r === 1 || r === 3) break;
      if (r === 8) {
        if (r = n.data, r === "$" || r === "$!" || r === "$?" || r === "$~" || r === "&" || r === "F!" || r === "F")
          break;
        if (r === "/$" || r === "/&") return null;
      }
    }
    return n;
  }
  var Ud = null;
  function dS(n) {
    n = n.nextSibling;
    for (var r = 0; n; ) {
      if (n.nodeType === 8) {
        var s = n.data;
        if (s === "/$" || s === "/&") {
          if (r === 0)
            return Sn(n.nextSibling);
          r--;
        } else
          s !== "$" && s !== "$!" && s !== "$?" && s !== "$~" && s !== "&" || r++;
      }
      n = n.nextSibling;
    }
    return null;
  }
  function pS(n) {
    n = n.previousSibling;
    for (var r = 0; n; ) {
      if (n.nodeType === 8) {
        var s = n.data;
        if (s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&") {
          if (r === 0) return n;
          r--;
        } else s !== "/$" && s !== "/&" || r++;
      }
      n = n.previousSibling;
    }
    return null;
  }
  function fS(n, r, s) {
    switch (r = _l(s), n) {
      case "html":
        if (n = r.documentElement, !n) throw Error(i(452));
        return n;
      case "head":
        if (n = r.head, !n) throw Error(i(453));
        return n;
      case "body":
        if (n = r.body, !n) throw Error(i(454));
        return n;
      default:
        throw Error(i(451));
    }
  }
  function Es(n) {
    for (var r = n.attributes; r.length; )
      n.removeAttributeNode(r[0]);
    Fu(n);
  }
  var _n = /* @__PURE__ */ new Map(), mS = /* @__PURE__ */ new Set();
  function Al(n) {
    return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument;
  }
  var ua = se.d;
  se.d = {
    f: Jv,
    r: eC,
    D: tC,
    C: nC,
    L: aC,
    m: rC,
    X: sC,
    S: iC,
    M: oC
  };
  function Jv() {
    var n = ua.f(), r = ml();
    return n || r;
  }
  function eC(n) {
    var r = wr(n);
    r !== null && r.tag === 5 && r.type === "form" ? Oy(r) : ua.r(n);
  }
  var si = typeof document > "u" ? null : document;
  function gS(n, r, s) {
    var u = si;
    if (u && typeof r == "string" && r) {
      var p = mn(r);
      p = 'link[rel="' + n + '"][href="' + p + '"]', typeof s == "string" && (p += '[crossorigin="' + s + '"]'), mS.has(p) || (mS.add(p), n = { rel: n, crossOrigin: s, href: r }, u.querySelector(p) === null && (r = u.createElement("link"), Ot(r, "link", n), _t(r), u.head.appendChild(r)));
    }
  }
  function tC(n) {
    ua.D(n), gS("dns-prefetch", n, null);
  }
  function nC(n, r) {
    ua.C(n, r), gS("preconnect", n, r);
  }
  function aC(n, r, s) {
    ua.L(n, r, s);
    var u = si;
    if (u && n && r) {
      var p = 'link[rel="preload"][as="' + mn(r) + '"]';
      r === "image" && s && s.imageSrcSet ? (p += '[imagesrcset="' + mn(
        s.imageSrcSet
      ) + '"]', typeof s.imageSizes == "string" && (p += '[imagesizes="' + mn(
        s.imageSizes
      ) + '"]')) : p += '[href="' + mn(n) + '"]';
      var g = p;
      switch (r) {
        case "style":
          g = oi(n);
          break;
        case "script":
          g = li(n);
      }
      _n.has(g) || (n = E(
        {
          rel: "preload",
          href: r === "image" && s && s.imageSrcSet ? void 0 : n,
          as: r
        },
        s
      ), _n.set(g, n), u.querySelector(p) !== null || r === "style" && u.querySelector(ys(g)) || r === "script" && u.querySelector(Ts(g)) || (r = u.createElement("link"), Ot(r, "link", n), _t(r), u.head.appendChild(r)));
    }
  }
  function rC(n, r) {
    ua.m(n, r);
    var s = si;
    if (s && n) {
      var u = r && typeof r.as == "string" ? r.as : "script", p = 'link[rel="modulepreload"][as="' + mn(u) + '"][href="' + mn(n) + '"]', g = p;
      switch (u) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          g = li(n);
      }
      if (!_n.has(g) && (n = E({ rel: "modulepreload", href: n }, r), _n.set(g, n), s.querySelector(p) === null)) {
        switch (u) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (s.querySelector(Ts(g)))
              return;
        }
        u = s.createElement("link"), Ot(u, "link", n), _t(u), s.head.appendChild(u);
      }
    }
  }
  function iC(n, r, s) {
    ua.S(n, r, s);
    var u = si;
    if (u && n) {
      var p = kr(u).hoistableStyles, g = oi(n);
      r = r || "default";
      var y = p.get(g);
      if (!y) {
        var A = { loading: 0, preload: null };
        if (y = u.querySelector(
          ys(g)
        ))
          A.loading = 5;
        else {
          n = E(
            { rel: "stylesheet", href: n, "data-precedence": r },
            s
          ), (s = _n.get(g)) && Bd(n, s);
          var P = y = u.createElement("link");
          _t(P), Ot(P, "link", n), P._p = new Promise(function(X, re) {
            P.onload = X, P.onerror = re;
          }), P.addEventListener("load", function() {
            A.loading |= 1;
          }), P.addEventListener("error", function() {
            A.loading |= 2;
          }), A.loading |= 4, Nl(y, r, u);
        }
        y = {
          type: "stylesheet",
          instance: y,
          count: 1,
          state: A
        }, p.set(g, y);
      }
    }
  }
  function sC(n, r) {
    ua.X(n, r);
    var s = si;
    if (s && n) {
      var u = kr(s).hoistableScripts, p = li(n), g = u.get(p);
      g || (g = s.querySelector(Ts(p)), g || (n = E({ src: n, async: !0 }, r), (r = _n.get(p)) && Fd(n, r), g = s.createElement("script"), _t(g), Ot(g, "link", n), s.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, u.set(p, g));
    }
  }
  function oC(n, r) {
    ua.M(n, r);
    var s = si;
    if (s && n) {
      var u = kr(s).hoistableScripts, p = li(n), g = u.get(p);
      g || (g = s.querySelector(Ts(p)), g || (n = E({ src: n, async: !0, type: "module" }, r), (r = _n.get(p)) && Fd(n, r), g = s.createElement("script"), _t(g), Ot(g, "link", n), s.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, u.set(p, g));
    }
  }
  function hS(n, r, s, u) {
    var p = (p = _e.current) ? Al(p) : null;
    if (!p) throw Error(i(446));
    switch (n) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof s.precedence == "string" && typeof s.href == "string" ? (r = oi(s.href), s = kr(
          p
        ).hoistableStyles, u = s.get(r), u || (u = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, s.set(r, u)), u) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (s.rel === "stylesheet" && typeof s.href == "string" && typeof s.precedence == "string") {
          n = oi(s.href);
          var g = kr(
            p
          ).hoistableStyles, y = g.get(n);
          if (y || (p = p.ownerDocument || p, y = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, g.set(n, y), (g = p.querySelector(
            ys(n)
          )) && !g._p && (y.instance = g, y.state.loading = 5), _n.has(n) || (s = {
            rel: "preload",
            as: "style",
            href: s.href,
            crossOrigin: s.crossOrigin,
            integrity: s.integrity,
            media: s.media,
            hrefLang: s.hrefLang,
            referrerPolicy: s.referrerPolicy
          }, _n.set(n, s), g || lC(
            p,
            n,
            s,
            y.state
          ))), r && u === null)
            throw Error(i(528, ""));
          return y;
        }
        if (r && u !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return r = s.async, s = s.src, typeof s == "string" && r && typeof r != "function" && typeof r != "symbol" ? (r = li(s), s = kr(
          p
        ).hoistableScripts, u = s.get(r), u || (u = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, s.set(r, u)), u) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, n));
    }
  }
  function oi(n) {
    return 'href="' + mn(n) + '"';
  }
  function ys(n) {
    return 'link[rel="stylesheet"][' + n + "]";
  }
  function bS(n) {
    return E({}, n, {
      "data-precedence": n.precedence,
      precedence: null
    });
  }
  function lC(n, r, s, u) {
    n.querySelector('link[rel="preload"][as="style"][' + r + "]") ? u.loading = 1 : (r = n.createElement("link"), u.preload = r, r.addEventListener("load", function() {
      return u.loading |= 1;
    }), r.addEventListener("error", function() {
      return u.loading |= 2;
    }), Ot(r, "link", s), _t(r), n.head.appendChild(r));
  }
  function li(n) {
    return '[src="' + mn(n) + '"]';
  }
  function Ts(n) {
    return "script[async]" + n;
  }
  function ES(n, r, s) {
    if (r.count++, r.instance === null)
      switch (r.type) {
        case "style":
          var u = n.querySelector(
            'style[data-href~="' + mn(s.href) + '"]'
          );
          if (u)
            return r.instance = u, _t(u), u;
          var p = E({}, s, {
            "data-href": s.href,
            "data-precedence": s.precedence,
            href: null,
            precedence: null
          });
          return u = (n.ownerDocument || n).createElement(
            "style"
          ), _t(u), Ot(u, "style", p), Nl(u, s.precedence, n), r.instance = u;
        case "stylesheet":
          p = oi(s.href);
          var g = n.querySelector(
            ys(p)
          );
          if (g)
            return r.state.loading |= 4, r.instance = g, _t(g), g;
          u = bS(s), (p = _n.get(p)) && Bd(u, p), g = (n.ownerDocument || n).createElement("link"), _t(g);
          var y = g;
          return y._p = new Promise(function(A, P) {
            y.onload = A, y.onerror = P;
          }), Ot(g, "link", u), r.state.loading |= 4, Nl(g, s.precedence, n), r.instance = g;
        case "script":
          return g = li(s.src), (p = n.querySelector(
            Ts(g)
          )) ? (r.instance = p, _t(p), p) : (u = s, (p = _n.get(g)) && (u = E({}, s), Fd(u, p)), n = n.ownerDocument || n, p = n.createElement("script"), _t(p), Ot(p, "link", u), n.head.appendChild(p), r.instance = p);
        case "void":
          return null;
        default:
          throw Error(i(443, r.type));
      }
    else
      r.type === "stylesheet" && (r.state.loading & 4) === 0 && (u = r.instance, r.state.loading |= 4, Nl(u, s.precedence, n));
    return r.instance;
  }
  function Nl(n, r, s) {
    for (var u = s.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), p = u.length ? u[u.length - 1] : null, g = p, y = 0; y < u.length; y++) {
      var A = u[y];
      if (A.dataset.precedence === r) g = A;
      else if (g !== p) break;
    }
    g ? g.parentNode.insertBefore(n, g.nextSibling) : (r = s.nodeType === 9 ? s.head : s, r.insertBefore(n, r.firstChild));
  }
  function Bd(n, r) {
    n.crossOrigin == null && (n.crossOrigin = r.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = r.referrerPolicy), n.title == null && (n.title = r.title);
  }
  function Fd(n, r) {
    n.crossOrigin == null && (n.crossOrigin = r.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = r.referrerPolicy), n.integrity == null && (n.integrity = r.integrity);
  }
  var Rl = null;
  function yS(n, r, s) {
    if (Rl === null) {
      var u = /* @__PURE__ */ new Map(), p = Rl = /* @__PURE__ */ new Map();
      p.set(s, u);
    } else
      p = Rl, u = p.get(s), u || (u = /* @__PURE__ */ new Map(), p.set(s, u));
    if (u.has(n)) return u;
    for (u.set(n, null), s = s.getElementsByTagName(n), p = 0; p < s.length; p++) {
      var g = s[p];
      if (!(g[Ui] || g[Ct] || n === "link" && g.getAttribute("rel") === "stylesheet") && g.namespaceURI !== "http://www.w3.org/2000/svg") {
        var y = g.getAttribute(r) || "";
        y = n + y;
        var A = u.get(y);
        A ? A.push(g) : u.set(y, [g]);
      }
    }
    return u;
  }
  function TS(n, r, s) {
    n = n.ownerDocument || n, n.head.insertBefore(
      s,
      r === "title" ? n.querySelector("head > title") : null
    );
  }
  function uC(n, r, s) {
    if (s === 1 || r.itemProp != null) return !1;
    switch (n) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof r.precedence != "string" || typeof r.href != "string" || r.href === "")
          break;
        return !0;
      case "link":
        if (typeof r.rel != "string" || typeof r.href != "string" || r.href === "" || r.onLoad || r.onError)
          break;
        switch (r.rel) {
          case "stylesheet":
            return n = r.disabled, typeof r.precedence == "string" && n == null;
          default:
            return !0;
        }
      case "script":
        if (r.async && typeof r.async != "function" && typeof r.async != "symbol" && !r.onLoad && !r.onError && r.src && typeof r.src == "string")
          return !0;
    }
    return !1;
  }
  function SS(n) {
    return !(n.type === "stylesheet" && (n.state.loading & 3) === 0);
  }
  function cC(n, r, s, u) {
    if (s.type === "stylesheet" && (typeof u.media != "string" || matchMedia(u.media).matches !== !1) && (s.state.loading & 4) === 0) {
      if (s.instance === null) {
        var p = oi(u.href), g = r.querySelector(
          ys(p)
        );
        if (g) {
          r = g._p, r !== null && typeof r == "object" && typeof r.then == "function" && (n.count++, n = vl.bind(n), r.then(n, n)), s.state.loading |= 4, s.instance = g, _t(g);
          return;
        }
        g = r.ownerDocument || r, u = bS(u), (p = _n.get(p)) && Bd(u, p), g = g.createElement("link"), _t(g);
        var y = g;
        y._p = new Promise(function(A, P) {
          y.onload = A, y.onerror = P;
        }), Ot(g, "link", u), s.instance = g;
      }
      n.stylesheets === null && (n.stylesheets = /* @__PURE__ */ new Map()), n.stylesheets.set(s, r), (r = s.state.preload) && (s.state.loading & 3) === 0 && (n.count++, s = vl.bind(n), r.addEventListener("load", s), r.addEventListener("error", s));
    }
  }
  var Pd = 0;
  function dC(n, r) {
    return n.stylesheets && n.count === 0 && wl(n, n.stylesheets), 0 < n.count || 0 < n.imgCount ? function(s) {
      var u = setTimeout(function() {
        if (n.stylesheets && wl(n, n.stylesheets), n.unsuspend) {
          var g = n.unsuspend;
          n.unsuspend = null, g();
        }
      }, 6e4 + r);
      0 < n.imgBytes && Pd === 0 && (Pd = 62500 * qv());
      var p = setTimeout(
        function() {
          if (n.waitingForImages = !1, n.count === 0 && (n.stylesheets && wl(n, n.stylesheets), n.unsuspend)) {
            var g = n.unsuspend;
            n.unsuspend = null, g();
          }
        },
        (n.imgBytes > Pd ? 50 : 800) + r
      );
      return n.unsuspend = s, function() {
        n.unsuspend = null, clearTimeout(u), clearTimeout(p);
      };
    } : null;
  }
  function vl() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) wl(this, this.stylesheets);
      else if (this.unsuspend) {
        var n = this.unsuspend;
        this.unsuspend = null, n();
      }
    }
  }
  var Cl = null;
  function wl(n, r) {
    n.stylesheets = null, n.unsuspend !== null && (n.count++, Cl = /* @__PURE__ */ new Map(), r.forEach(pC, n), Cl = null, vl.call(n));
  }
  function pC(n, r) {
    if (!(r.state.loading & 4)) {
      var s = Cl.get(n);
      if (s) var u = s.get(null);
      else {
        s = /* @__PURE__ */ new Map(), Cl.set(n, s);
        for (var p = n.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), g = 0; g < p.length; g++) {
          var y = p[g];
          (y.nodeName === "LINK" || y.getAttribute("media") !== "not all") && (s.set(y.dataset.precedence, y), u = y);
        }
        u && s.set(null, u);
      }
      p = r.instance, y = p.getAttribute("data-precedence"), g = s.get(y) || u, g === u && s.set(null, p), s.set(y, p), this.count++, u = vl.bind(this), p.addEventListener("load", u), p.addEventListener("error", u), g ? g.parentNode.insertBefore(p, g.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(p, n.firstChild)), r.state.loading |= 4;
    }
  }
  var Ss = {
    $$typeof: x,
    Provider: null,
    Consumer: null,
    _currentValue: Ee,
    _currentValue2: Ee,
    _threadCount: 0
  };
  function fC(n, r, s, u, p, g, y, A, P) {
    this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Du(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Du(0), this.hiddenUpdates = Du(null), this.identifierPrefix = u, this.onUncaughtError = p, this.onCaughtError = g, this.onRecoverableError = y, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = P, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function _S(n, r, s, u, p, g, y, A, P, X, re, le) {
    return n = new fC(
      n,
      r,
      s,
      y,
      P,
      X,
      re,
      le,
      A
    ), r = 1, g === !0 && (r |= 24), g = rn(3, null, null, r), n.current = g, g.stateNode = n, r = Ec(), r.refCount++, n.pooledCache = r, r.refCount++, g.memoizedState = {
      element: u,
      isDehydrated: s,
      cache: r
    }, _c(g), n;
  }
  function AS(n) {
    return n ? (n = Pr, n) : Pr;
  }
  function NS(n, r, s, u, p, g) {
    p = AS(p), u.context === null ? u.context = p : u.pendingContext = p, u = _a(r), u.payload = { element: s }, g = g === void 0 ? null : g, g !== null && (u.callback = g), s = Aa(n, u, r), s !== null && (Zt(s, n, r), Ji(s, n, r));
  }
  function RS(n, r) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
      var s = n.retryLane;
      n.retryLane = s !== 0 && s < r ? s : r;
    }
  }
  function Hd(n, r) {
    RS(n, r), (n = n.alternate) && RS(n, r);
  }
  function vS(n) {
    if (n.tag === 13 || n.tag === 31) {
      var r = Qa(n, 67108864);
      r !== null && Zt(r, n, 67108864), Hd(n, 67108864);
    }
  }
  function CS(n) {
    if (n.tag === 13 || n.tag === 31) {
      var r = cn();
      r = Mu(r);
      var s = Qa(n, r);
      s !== null && Zt(s, n, r), Hd(n, r);
    }
  }
  var kl = !0;
  function mC(n, r, s, u) {
    var p = j.T;
    j.T = null;
    var g = se.p;
    try {
      se.p = 2, zd(n, r, s, u);
    } finally {
      se.p = g, j.T = p;
    }
  }
  function gC(n, r, s, u) {
    var p = j.T;
    j.T = null;
    var g = se.p;
    try {
      se.p = 8, zd(n, r, s, u);
    } finally {
      se.p = g, j.T = p;
    }
  }
  function zd(n, r, s, u) {
    if (kl) {
      var p = Gd(u);
      if (p === null)
        Cd(
          n,
          r,
          u,
          Il,
          s
        ), kS(n, u);
      else if (bC(
        p,
        n,
        r,
        s,
        u
      ))
        u.stopPropagation();
      else if (kS(n, u), r & 4 && -1 < hC.indexOf(n)) {
        for (; p !== null; ) {
          var g = wr(p);
          if (g !== null)
            switch (g.tag) {
              case 3:
                if (g = g.stateNode, g.current.memoizedState.isDehydrated) {
                  var y = Va(g.pendingLanes);
                  if (y !== 0) {
                    var A = g;
                    for (A.pendingLanes |= 2, A.entangledLanes |= 2; y; ) {
                      var P = 1 << 31 - tt(y);
                      A.entanglements[1] |= P, y &= ~P;
                    }
                    Fn(g), (Ye & 6) === 0 && (pl = Pt() + 500, gs(0));
                  }
                }
                break;
              case 31:
              case 13:
                A = Qa(g, 2), A !== null && Zt(A, g, 2), ml(), Hd(g, 2);
            }
          if (g = Gd(u), g === null && Cd(
            n,
            r,
            u,
            Il,
            s
          ), g === p) break;
          p = g;
        }
        p !== null && u.stopPropagation();
      } else
        Cd(
          n,
          r,
          u,
          null,
          s
        );
    }
  }
  function Gd(n) {
    return n = $u(n), jd(n);
  }
  var Il = null;
  function jd(n) {
    if (Il = null, n = Cr(n), n !== null) {
      var r = l(n);
      if (r === null) n = null;
      else {
        var s = r.tag;
        if (s === 13) {
          if (n = c(r), n !== null) return n;
          n = null;
        } else if (s === 31) {
          if (n = d(r), n !== null) return n;
          n = null;
        } else if (s === 3) {
          if (r.stateNode.current.memoizedState.isDehydrated)
            return r.tag === 3 ? r.stateNode.containerInfo : null;
          n = null;
        } else r !== n && (n = null);
      }
    }
    return Il = n, null;
  }
  function wS(n) {
    switch (n) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Lu()) {
          case ie:
            return 2;
          case be:
            return 8;
          case we:
          case Me:
            return 32;
          case We:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var $d = !1, Da = null, Ma = null, Ua = null, _s = /* @__PURE__ */ new Map(), As = /* @__PURE__ */ new Map(), Ba = [], hC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function kS(n, r) {
    switch (n) {
      case "focusin":
      case "focusout":
        Da = null;
        break;
      case "dragenter":
      case "dragleave":
        Ma = null;
        break;
      case "mouseover":
      case "mouseout":
        Ua = null;
        break;
      case "pointerover":
      case "pointerout":
        _s.delete(r.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        As.delete(r.pointerId);
    }
  }
  function Ns(n, r, s, u, p, g) {
    return n === null || n.nativeEvent !== g ? (n = {
      blockedOn: r,
      domEventName: s,
      eventSystemFlags: u,
      nativeEvent: g,
      targetContainers: [p]
    }, r !== null && (r = wr(r), r !== null && vS(r)), n) : (n.eventSystemFlags |= u, r = n.targetContainers, p !== null && r.indexOf(p) === -1 && r.push(p), n);
  }
  function bC(n, r, s, u, p) {
    switch (r) {
      case "focusin":
        return Da = Ns(
          Da,
          n,
          r,
          s,
          u,
          p
        ), !0;
      case "dragenter":
        return Ma = Ns(
          Ma,
          n,
          r,
          s,
          u,
          p
        ), !0;
      case "mouseover":
        return Ua = Ns(
          Ua,
          n,
          r,
          s,
          u,
          p
        ), !0;
      case "pointerover":
        var g = p.pointerId;
        return _s.set(
          g,
          Ns(
            _s.get(g) || null,
            n,
            r,
            s,
            u,
            p
          )
        ), !0;
      case "gotpointercapture":
        return g = p.pointerId, As.set(
          g,
          Ns(
            As.get(g) || null,
            n,
            r,
            s,
            u,
            p
          )
        ), !0;
    }
    return !1;
  }
  function IS(n) {
    var r = Cr(n.target);
    if (r !== null) {
      var s = l(r);
      if (s !== null) {
        if (r = s.tag, r === 13) {
          if (r = c(s), r !== null) {
            n.blockedOn = r, $E(n.priority, function() {
              CS(s);
            });
            return;
          }
        } else if (r === 31) {
          if (r = d(s), r !== null) {
            n.blockedOn = r, $E(n.priority, function() {
              CS(s);
            });
            return;
          }
        } else if (r === 3 && s.stateNode.current.memoizedState.isDehydrated) {
          n.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
          return;
        }
      }
    }
    n.blockedOn = null;
  }
  function Ol(n) {
    if (n.blockedOn !== null) return !1;
    for (var r = n.targetContainers; 0 < r.length; ) {
      var s = Gd(n.nativeEvent);
      if (s === null) {
        s = n.nativeEvent;
        var u = new s.constructor(
          s.type,
          s
        );
        ju = u, s.target.dispatchEvent(u), ju = null;
      } else
        return r = wr(s), r !== null && vS(r), n.blockedOn = s, !1;
      r.shift();
    }
    return !0;
  }
  function OS(n, r, s) {
    Ol(n) && s.delete(r);
  }
  function EC() {
    $d = !1, Da !== null && Ol(Da) && (Da = null), Ma !== null && Ol(Ma) && (Ma = null), Ua !== null && Ol(Ua) && (Ua = null), _s.forEach(OS), As.forEach(OS);
  }
  function xl(n, r) {
    n.blockedOn === r && (n.blockedOn = null, $d || ($d = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      EC
    )));
  }
  var Ll = null;
  function xS(n) {
    Ll !== n && (Ll = n, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Ll === n && (Ll = null);
        for (var r = 0; r < n.length; r += 3) {
          var s = n[r], u = n[r + 1], p = n[r + 2];
          if (typeof u != "function") {
            if (jd(u || s) === null)
              continue;
            break;
          }
          var g = wr(s);
          g !== null && (n.splice(r, 3), r -= 3, Gc(
            g,
            {
              pending: !0,
              data: p,
              method: s.method,
              action: u
            },
            u,
            p
          ));
        }
      }
    ));
  }
  function ui(n) {
    function r(P) {
      return xl(P, n);
    }
    Da !== null && xl(Da, n), Ma !== null && xl(Ma, n), Ua !== null && xl(Ua, n), _s.forEach(r), As.forEach(r);
    for (var s = 0; s < Ba.length; s++) {
      var u = Ba[s];
      u.blockedOn === n && (u.blockedOn = null);
    }
    for (; 0 < Ba.length && (s = Ba[0], s.blockedOn === null); )
      IS(s), s.blockedOn === null && Ba.shift();
    if (s = (n.ownerDocument || n).$$reactFormReplay, s != null)
      for (u = 0; u < s.length; u += 3) {
        var p = s[u], g = s[u + 1], y = p[qt] || null;
        if (typeof g == "function")
          y || xS(s);
        else if (y) {
          var A = null;
          if (g && g.hasAttribute("formAction")) {
            if (p = g, y = g[qt] || null)
              A = y.formAction;
            else if (jd(p) !== null) continue;
          } else A = y.action;
          typeof A == "function" ? s[u + 1] = A : (s.splice(u, 3), u -= 3), xS(s);
        }
      }
  }
  function LS() {
    function n(g) {
      g.canIntercept && g.info === "react-transition" && g.intercept({
        handler: function() {
          return new Promise(function(y) {
            return p = y;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function r() {
      p !== null && (p(), p = null), u || setTimeout(s, 20);
    }
    function s() {
      if (!u && !navigation.transition) {
        var g = navigation.currentEntry;
        g && g.url != null && navigation.navigate(g.url, {
          state: g.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var u = !1, p = null;
      return navigation.addEventListener("navigate", n), navigation.addEventListener("navigatesuccess", r), navigation.addEventListener("navigateerror", r), setTimeout(s, 100), function() {
        u = !0, navigation.removeEventListener("navigate", n), navigation.removeEventListener("navigatesuccess", r), navigation.removeEventListener("navigateerror", r), p !== null && (p(), p = null);
      };
    }
  }
  function qd(n) {
    this._internalRoot = n;
  }
  Dl.prototype.render = qd.prototype.render = function(n) {
    var r = this._internalRoot;
    if (r === null) throw Error(i(409));
    var s = r.current, u = cn();
    NS(s, u, n, r, null, null);
  }, Dl.prototype.unmount = qd.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
      this._internalRoot = null;
      var r = n.containerInfo;
      NS(n.current, 2, null, n, null, null), ml(), r[vr] = null;
    }
  };
  function Dl(n) {
    this._internalRoot = n;
  }
  Dl.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
      var r = jE();
      n = { blockedOn: null, target: n, priority: r };
      for (var s = 0; s < Ba.length && r !== 0 && r < Ba[s].priority; s++) ;
      Ba.splice(s, 0, n), s === 0 && IS(n);
    }
  };
  var DS = t.version;
  if (DS !== "19.2.3")
    throw Error(
      i(
        527,
        DS,
        "19.2.3"
      )
    );
  se.findDOMNode = function(n) {
    var r = n._reactInternals;
    if (r === void 0)
      throw typeof n.render == "function" ? Error(i(188)) : (n = Object.keys(n).join(","), Error(i(268, n)));
    return n = f(r), n = n !== null ? b(n) : null, n = n === null ? null : n.stateNode, n;
  };
  var yC = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: j,
    reconcilerVersion: "19.2.3"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ml = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ml.isDisabled && Ml.supportsFiber)
      try {
        Ht = Ml.inject(
          yC
        ), Tt = Ml;
      } catch {
      }
  }
  return vs.createRoot = function(n, r) {
    if (!o(n)) throw Error(i(299));
    var s = !1, u = "", p = zy, g = Gy, y = jy;
    return r != null && (r.unstable_strictMode === !0 && (s = !0), r.identifierPrefix !== void 0 && (u = r.identifierPrefix), r.onUncaughtError !== void 0 && (p = r.onUncaughtError), r.onCaughtError !== void 0 && (g = r.onCaughtError), r.onRecoverableError !== void 0 && (y = r.onRecoverableError)), r = _S(
      n,
      1,
      !1,
      null,
      null,
      s,
      u,
      null,
      p,
      g,
      y,
      LS
    ), n[vr] = r.current, vd(n), new qd(r);
  }, vs.hydrateRoot = function(n, r, s) {
    if (!o(n)) throw Error(i(299));
    var u = !1, p = "", g = zy, y = Gy, A = jy, P = null;
    return s != null && (s.unstable_strictMode === !0 && (u = !0), s.identifierPrefix !== void 0 && (p = s.identifierPrefix), s.onUncaughtError !== void 0 && (g = s.onUncaughtError), s.onCaughtError !== void 0 && (y = s.onCaughtError), s.onRecoverableError !== void 0 && (A = s.onRecoverableError), s.formState !== void 0 && (P = s.formState)), r = _S(
      n,
      1,
      !0,
      r,
      s ?? null,
      u,
      p,
      P,
      g,
      y,
      A,
      LS
    ), r.context = AS(null), s = r.current, u = cn(), u = Mu(u), p = _a(u), p.callback = null, Aa(s, p, u), s = u, r.current.lanes = s, Mi(r, s), Fn(r), n[vr] = r.current, vd(n), new Dl(r);
  }, vs.version = "19.2.3", vs;
}
var $S;
function kC() {
  if ($S) return Vd.exports;
  $S = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Vd.exports = wC(), Vd.exports;
}
var IC = kC(), z = uf();
const Re = /* @__PURE__ */ iu(z);
/**
 * react-router v7.10.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var qS = "popstate";
function OC(e = {}) {
  function t(o, l) {
    let {
      pathname: c = "/",
      search: d = "",
      hash: m = ""
    } = br(o.location.hash.substring(1));
    return !c.startsWith("/") && !c.startsWith(".") && (c = "/" + c), Rp(
      "",
      { pathname: c, search: d, hash: m },
      // state defaults to `null` because `window.history.state` does
      l.state && l.state.usr || null,
      l.state && l.state.key || "default"
    );
  }
  function a(o, l) {
    let c = o.document.querySelector("base"), d = "";
    if (c && c.getAttribute("href")) {
      let m = o.location.href, f = m.indexOf("#");
      d = f === -1 ? m : m.slice(0, f);
    }
    return d + "#" + (typeof l == "string" ? l : Ys(l));
  }
  function i(o, l) {
    en(
      o.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        l
      )})`
    );
  }
  return LC(
    t,
    a,
    i,
    e
  );
}
function ut(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function en(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function xC() {
  return Math.random().toString(36).substring(2, 10);
}
function YS(e, t) {
  return {
    usr: e.state,
    key: e.key,
    idx: t
  };
}
function Rp(e, t, a = null, i) {
  return {
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: "",
    ...typeof t == "string" ? br(t) : t,
    state: a,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || i || xC()
  };
}
function Ys({
  pathname: e = "/",
  search: t = "",
  hash: a = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), a && a !== "#" && (e += a.charAt(0) === "#" ? a : "#" + a), e;
}
function br(e) {
  let t = {};
  if (e) {
    let a = e.indexOf("#");
    a >= 0 && (t.hash = e.substring(a), e = e.substring(0, a));
    let i = e.indexOf("?");
    i >= 0 && (t.search = e.substring(i), e = e.substring(0, i)), e && (t.pathname = e);
  }
  return t;
}
function LC(e, t, a, i = {}) {
  let { window: o = document.defaultView, v5Compat: l = !1 } = i, c = o.history, d = "POP", m = null, f = b();
  f == null && (f = 0, c.replaceState({ ...c.state, idx: f }, ""));
  function b() {
    return (c.state || { idx: null }).idx;
  }
  function E() {
    d = "POP";
    let R = b(), C = R == null ? null : R - f;
    f = R, m && m({ action: d, location: k.location, delta: C });
  }
  function T(R, C) {
    d = "PUSH";
    let L = Rp(k.location, R, C);
    a && a(L, R), f = b() + 1;
    let x = YS(L, f), Y = k.createHref(L);
    try {
      c.pushState(x, "", Y);
    } catch (q) {
      if (q instanceof DOMException && q.name === "DataCloneError")
        throw q;
      o.location.assign(Y);
    }
    l && m && m({ action: d, location: k.location, delta: 1 });
  }
  function S(R, C) {
    d = "REPLACE";
    let L = Rp(k.location, R, C);
    a && a(L, R), f = b();
    let x = YS(L, f), Y = k.createHref(L);
    c.replaceState(x, "", Y), l && m && m({ action: d, location: k.location, delta: 0 });
  }
  function _(R) {
    return DC(R);
  }
  let k = {
    get action() {
      return d;
    },
    get location() {
      return e(o, c);
    },
    listen(R) {
      if (m)
        throw new Error("A history only accepts one active listener");
      return o.addEventListener(qS, E), m = R, () => {
        o.removeEventListener(qS, E), m = null;
      };
    },
    createHref(R) {
      return t(o, R);
    },
    createURL: _,
    encodeLocation(R) {
      let C = _(R);
      return {
        pathname: C.pathname,
        search: C.search,
        hash: C.hash
      };
    },
    push: T,
    replace: S,
    go(R) {
      return c.go(R);
    }
  };
  return k;
}
function DC(e, t = !1) {
  let a = "http://localhost";
  typeof window < "u" && (a = window.location.origin !== "null" ? window.location.origin : window.location.href), ut(a, "No window.location.(origin|href) available to create URL");
  let i = typeof e == "string" ? e : Ys(e);
  return i = i.replace(/ $/, "%20"), !t && i.startsWith("//") && (i = a + i), new URL(i, a);
}
function TA(e, t, a = "/") {
  return MC(e, t, a, !1);
}
function MC(e, t, a, i) {
  let o = typeof t == "string" ? br(t) : t, l = pa(o.pathname || "/", a);
  if (l == null)
    return null;
  let c = SA(e);
  UC(c);
  let d = null;
  for (let m = 0; d == null && m < c.length; ++m) {
    let f = VC(l);
    d = qC(
      c[m],
      f,
      i
    );
  }
  return d;
}
function SA(e, t = [], a = [], i = "", o = !1) {
  let l = (c, d, m = o, f) => {
    let b = {
      relativePath: f === void 0 ? c.path || "" : f,
      caseSensitive: c.caseSensitive === !0,
      childrenIndex: d,
      route: c
    };
    if (b.relativePath.startsWith("/")) {
      if (!b.relativePath.startsWith(i) && m)
        return;
      ut(
        b.relativePath.startsWith(i),
        `Absolute route path "${b.relativePath}" nested under path "${i}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), b.relativePath = b.relativePath.slice(i.length);
    }
    let E = da([i, b.relativePath]), T = a.concat(b);
    c.children && c.children.length > 0 && (ut(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      c.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${E}".`
    ), SA(
      c.children,
      t,
      T,
      E,
      m
    )), !(c.path == null && !c.index) && t.push({
      path: E,
      score: jC(E, c.index),
      routesMeta: T
    });
  };
  return e.forEach((c, d) => {
    var m;
    if (c.path === "" || !((m = c.path) != null && m.includes("?")))
      l(c, d);
    else
      for (let f of _A(c.path))
        l(c, d, !0, f);
  }), t;
}
function _A(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [a, ...i] = t, o = a.endsWith("?"), l = a.replace(/\?$/, "");
  if (i.length === 0)
    return o ? [l, ""] : [l];
  let c = _A(i.join("/")), d = [];
  return d.push(
    ...c.map(
      (m) => m === "" ? l : [l, m].join("/")
    )
  ), o && d.push(...c), d.map(
    (m) => e.startsWith("/") && m === "" ? "/" : m
  );
}
function UC(e) {
  e.sort(
    (t, a) => t.score !== a.score ? a.score - t.score : $C(
      t.routesMeta.map((i) => i.childrenIndex),
      a.routesMeta.map((i) => i.childrenIndex)
    )
  );
}
var BC = /^:[\w-]+$/, FC = 3, PC = 2, HC = 1, zC = 10, GC = -2, VS = (e) => e === "*";
function jC(e, t) {
  let a = e.split("/"), i = a.length;
  return a.some(VS) && (i += GC), t && (i += PC), a.filter((o) => !VS(o)).reduce(
    (o, l) => o + (BC.test(l) ? FC : l === "" ? HC : zC),
    i
  );
}
function $C(e, t) {
  return e.length === t.length && e.slice(0, -1).every((i, o) => i === t[o]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function qC(e, t, a = !1) {
  let { routesMeta: i } = e, o = {}, l = "/", c = [];
  for (let d = 0; d < i.length; ++d) {
    let m = i[d], f = d === i.length - 1, b = l === "/" ? t : t.slice(l.length) || "/", E = Kl(
      { path: m.relativePath, caseSensitive: m.caseSensitive, end: f },
      b
    ), T = m.route;
    if (!E && f && a && !i[i.length - 1].route.index && (E = Kl(
      {
        path: m.relativePath,
        caseSensitive: m.caseSensitive,
        end: !1
      },
      b
    )), !E)
      return null;
    Object.assign(o, E.params), c.push({
      // TODO: Can this as be avoided?
      params: o,
      pathname: da([l, E.pathname]),
      pathnameBase: QC(
        da([l, E.pathnameBase])
      ),
      route: T
    }), E.pathnameBase !== "/" && (l = da([l, E.pathnameBase]));
  }
  return c;
}
function Kl(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [a, i] = YC(
    e.path,
    e.caseSensitive,
    e.end
  ), o = t.match(a);
  if (!o) return null;
  let l = o[0], c = l.replace(/(.)\/+$/, "$1"), d = o.slice(1);
  return {
    params: i.reduce(
      (f, { paramName: b, isOptional: E }, T) => {
        if (b === "*") {
          let _ = d[T] || "";
          c = l.slice(0, l.length - _.length).replace(/(.)\/+$/, "$1");
        }
        const S = d[T];
        return E && !S ? f[b] = void 0 : f[b] = (S || "").replace(/%2F/g, "/"), f;
      },
      {}
    ),
    pathname: l,
    pathnameBase: c,
    pattern: e
  };
}
function YC(e, t = !1, a = !0) {
  en(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let i = [], o = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (c, d, m) => (i.push({ paramName: d, isOptional: m != null }), m ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (i.push({ paramName: "*" }), o += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : a ? o += "\\/*$" : e !== "" && e !== "/" && (o += "(?:(?=\\/|$))"), [new RegExp(o, t ? void 0 : "i"), i];
}
function VC(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return en(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function pa(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let a = t.endsWith("/") ? t.length - 1 : t.length, i = e.charAt(a);
  return i && i !== "/" ? null : e.slice(a) || "/";
}
var WC = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, XC = (e) => WC.test(e);
function KC(e, t = "/") {
  let {
    pathname: a,
    search: i = "",
    hash: o = ""
  } = typeof e == "string" ? br(e) : e, l;
  if (a)
    if (XC(a))
      l = a;
    else {
      if (a.includes("//")) {
        let c = a;
        a = a.replace(/\/\/+/g, "/"), en(
          !1,
          `Pathnames cannot have embedded double slashes - normalizing ${c} -> ${a}`
        );
      }
      a.startsWith("/") ? l = WS(a.substring(1), "/") : l = WS(a, t);
    }
  else
    l = t;
  return {
    pathname: l,
    search: JC(i),
    hash: ew(o)
  };
}
function WS(e, t) {
  let a = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((o) => {
    o === ".." ? a.length > 1 && a.pop() : o !== "." && a.push(o);
  }), a.length > 1 ? a.join("/") : "/";
}
function Qd(e, t, a, i) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    i
  )}].  Please separate it out to the \`to.${a}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function ZC(e) {
  return e.filter(
    (t, a) => a === 0 || t.route.path && t.route.path.length > 0
  );
}
function cf(e) {
  let t = ZC(e);
  return t.map(
    (a, i) => i === t.length - 1 ? a.pathname : a.pathnameBase
  );
}
function df(e, t, a, i = !1) {
  let o;
  typeof e == "string" ? o = br(e) : (o = { ...e }, ut(
    !o.pathname || !o.pathname.includes("?"),
    Qd("?", "pathname", "search", o)
  ), ut(
    !o.pathname || !o.pathname.includes("#"),
    Qd("#", "pathname", "hash", o)
  ), ut(
    !o.search || !o.search.includes("#"),
    Qd("#", "search", "hash", o)
  ));
  let l = e === "" || o.pathname === "", c = l ? "/" : o.pathname, d;
  if (c == null)
    d = a;
  else {
    let E = t.length - 1;
    if (!i && c.startsWith("..")) {
      let T = c.split("/");
      for (; T[0] === ".."; )
        T.shift(), E -= 1;
      o.pathname = T.join("/");
    }
    d = E >= 0 ? t[E] : "/";
  }
  let m = KC(o, d), f = c && c !== "/" && c.endsWith("/"), b = (l || c === ".") && a.endsWith("/");
  return !m.pathname.endsWith("/") && (f || b) && (m.pathname += "/"), m;
}
var da = (e) => e.join("/").replace(/\/\/+/g, "/"), QC = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), JC = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, ew = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function tw(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function nw(e) {
  return e.map((t) => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var AA = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  AA
);
var aw = [
  "GET",
  ...AA
];
new Set(aw);
var yi = z.createContext(null);
yi.displayName = "DataRouter";
var su = z.createContext(null);
su.displayName = "DataRouterState";
z.createContext(!1);
var NA = z.createContext({
  isTransitioning: !1
});
NA.displayName = "ViewTransition";
var rw = z.createContext(
  /* @__PURE__ */ new Map()
);
rw.displayName = "Fetchers";
var iw = z.createContext(null);
iw.displayName = "Await";
var Rn = z.createContext(
  null
);
Rn.displayName = "Navigation";
var Js = z.createContext(
  null
);
Js.displayName = "Location";
var xn = z.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
xn.displayName = "Route";
var pf = z.createContext(null);
pf.displayName = "RouteError";
function sw(e, { relative: t } = {}) {
  ut(
    Ti(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: a, navigator: i } = z.useContext(Rn), { hash: o, pathname: l, search: c } = eo(e, { relative: t }), d = l;
  return a !== "/" && (d = l === "/" ? a : da([a, l])), i.createHref({ pathname: d, search: c, hash: o });
}
function Ti() {
  return z.useContext(Js) != null;
}
function Ln() {
  return ut(
    Ti(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), z.useContext(Js).location;
}
var RA = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function vA(e) {
  z.useContext(Rn).static || z.useLayoutEffect(e);
}
function ff() {
  let { isDataRoute: e } = z.useContext(xn);
  return e ? yw() : ow();
}
function ow() {
  ut(
    Ti(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = z.useContext(yi), { basename: t, navigator: a } = z.useContext(Rn), { matches: i } = z.useContext(xn), { pathname: o } = Ln(), l = JSON.stringify(cf(i)), c = z.useRef(!1);
  return vA(() => {
    c.current = !0;
  }), z.useCallback(
    (m, f = {}) => {
      if (en(c.current, RA), !c.current) return;
      if (typeof m == "number") {
        a.go(m);
        return;
      }
      let b = df(
        m,
        JSON.parse(l),
        o,
        f.relative === "path"
      );
      e == null && t !== "/" && (b.pathname = b.pathname === "/" ? t : da([t, b.pathname])), (f.replace ? a.replace : a.push)(
        b,
        f.state,
        f
      );
    },
    [
      t,
      a,
      l,
      o,
      e
    ]
  );
}
z.createContext(null);
function CA() {
  let { matches: e } = z.useContext(xn), t = e[e.length - 1];
  return t ? t.params : {};
}
function eo(e, { relative: t } = {}) {
  let { matches: a } = z.useContext(xn), { pathname: i } = Ln(), o = JSON.stringify(cf(a));
  return z.useMemo(
    () => df(
      e,
      JSON.parse(o),
      i,
      t === "path"
    ),
    [e, o, i, t]
  );
}
function lw(e, t) {
  return wA(e, t);
}
function wA(e, t, a, i, o) {
  var L;
  ut(
    Ti(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: l } = z.useContext(Rn), { matches: c } = z.useContext(xn), d = c[c.length - 1], m = d ? d.params : {}, f = d ? d.pathname : "/", b = d ? d.pathnameBase : "/", E = d && d.route;
  {
    let x = E && E.path || "";
    kA(
      f,
      !E || x.endsWith("*") || x.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${f}" (under <Route path="${x}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${x}"> to <Route path="${x === "/" ? "*" : `${x}/*`}">.`
    );
  }
  let T = Ln(), S;
  if (t) {
    let x = typeof t == "string" ? br(t) : t;
    ut(
      b === "/" || ((L = x.pathname) == null ? void 0 : L.startsWith(b)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${b}" but pathname "${x.pathname}" was given in the \`location\` prop.`
    ), S = x;
  } else
    S = T;
  let _ = S.pathname || "/", k = _;
  if (b !== "/") {
    let x = b.replace(/^\//, "").split("/");
    k = "/" + _.replace(/^\//, "").split("/").slice(x.length).join("/");
  }
  let R = TA(e, { pathname: k });
  en(
    E || R != null,
    `No routes matched location "${S.pathname}${S.search}${S.hash}" `
  ), en(
    R == null || R[R.length - 1].route.element !== void 0 || R[R.length - 1].route.Component !== void 0 || R[R.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${S.pathname}${S.search}${S.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  );
  let C = fw(
    R && R.map(
      (x) => Object.assign({}, x, {
        params: Object.assign({}, m, x.params),
        pathname: da([
          b,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          l.encodeLocation ? l.encodeLocation(
            x.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : x.pathname
        ]),
        pathnameBase: x.pathnameBase === "/" ? b : da([
          b,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          l.encodeLocation ? l.encodeLocation(
            x.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : x.pathnameBase
        ])
      })
    ),
    c,
    a,
    i,
    o
  );
  return t && C ? /* @__PURE__ */ z.createElement(
    Js.Provider,
    {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...S
        },
        navigationType: "POP"
        /* Pop */
      }
    },
    C
  ) : C;
}
function uw() {
  let e = Ew(), t = tw(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), a = e instanceof Error ? e.stack : null, i = "rgba(200,200,200, 0.5)", o = { padding: "0.5rem", backgroundColor: i }, l = { padding: "2px 4px", backgroundColor: i }, c = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), c = /* @__PURE__ */ z.createElement(z.Fragment, null, /* @__PURE__ */ z.createElement("p", null, " Hey developer "), /* @__PURE__ */ z.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ z.createElement("code", { style: l }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ z.createElement("code", { style: l }, "errorElement"), " prop on your route.")), /* @__PURE__ */ z.createElement(z.Fragment, null, /* @__PURE__ */ z.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ z.createElement("h3", { style: { fontStyle: "italic" } }, t), a ? /* @__PURE__ */ z.createElement("pre", { style: o }, a) : null, c);
}
var cw = /* @__PURE__ */ z.createElement(uw, null), dw = class extends z.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ z.createElement(xn.Provider, { value: this.props.routeContext }, /* @__PURE__ */ z.createElement(
      pf.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function pw({ routeContext: e, match: t, children: a }) {
  let i = z.useContext(yi);
  return i && i.static && i.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ z.createElement(xn.Provider, { value: e }, a);
}
function fw(e, t = [], a = null, i = null, o = null) {
  if (e == null) {
    if (!a)
      return null;
    if (a.errors)
      e = a.matches;
    else if (t.length === 0 && !a.initialized && a.matches.length > 0)
      e = a.matches;
    else
      return null;
  }
  let l = e, c = a == null ? void 0 : a.errors;
  if (c != null) {
    let b = l.findIndex(
      (E) => E.route.id && (c == null ? void 0 : c[E.route.id]) !== void 0
    );
    ut(
      b >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        c
      ).join(",")}`
    ), l = l.slice(
      0,
      Math.min(l.length, b + 1)
    );
  }
  let d = !1, m = -1;
  if (a)
    for (let b = 0; b < l.length; b++) {
      let E = l[b];
      if ((E.route.HydrateFallback || E.route.hydrateFallbackElement) && (m = b), E.route.id) {
        let { loaderData: T, errors: S } = a, _ = E.route.loader && !T.hasOwnProperty(E.route.id) && (!S || S[E.route.id] === void 0);
        if (E.route.lazy || _) {
          d = !0, m >= 0 ? l = l.slice(0, m + 1) : l = [l[0]];
          break;
        }
      }
    }
  let f = a && i ? (b, E) => {
    var T, S;
    i(b, {
      location: a.location,
      params: ((S = (T = a.matches) == null ? void 0 : T[0]) == null ? void 0 : S.params) ?? {},
      unstable_pattern: nw(a.matches),
      errorInfo: E
    });
  } : void 0;
  return l.reduceRight(
    (b, E, T) => {
      let S, _ = !1, k = null, R = null;
      a && (S = c && E.route.id ? c[E.route.id] : void 0, k = E.route.errorElement || cw, d && (m < 0 && T === 0 ? (kA(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), _ = !0, R = null) : m === T && (_ = !0, R = E.route.hydrateFallbackElement || null)));
      let C = t.concat(l.slice(0, T + 1)), L = () => {
        let x;
        return S ? x = k : _ ? x = R : E.route.Component ? x = /* @__PURE__ */ z.createElement(E.route.Component, null) : E.route.element ? x = E.route.element : x = b, /* @__PURE__ */ z.createElement(
          pw,
          {
            match: E,
            routeContext: {
              outlet: b,
              matches: C,
              isDataRoute: a != null
            },
            children: x
          }
        );
      };
      return a && (E.route.ErrorBoundary || E.route.errorElement || T === 0) ? /* @__PURE__ */ z.createElement(
        dw,
        {
          location: a.location,
          revalidation: a.revalidation,
          component: k,
          error: S,
          children: L(),
          routeContext: { outlet: null, matches: C, isDataRoute: !0 },
          onError: f
        }
      ) : L();
    },
    null
  );
}
function mf(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function mw(e) {
  let t = z.useContext(yi);
  return ut(t, mf(e)), t;
}
function gw(e) {
  let t = z.useContext(su);
  return ut(t, mf(e)), t;
}
function hw(e) {
  let t = z.useContext(xn);
  return ut(t, mf(e)), t;
}
function gf(e) {
  let t = hw(e), a = t.matches[t.matches.length - 1];
  return ut(
    a.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), a.route.id;
}
function bw() {
  return gf(
    "useRouteId"
    /* UseRouteId */
  );
}
function Ew() {
  var i;
  let e = z.useContext(pf), t = gw(
    "useRouteError"
    /* UseRouteError */
  ), a = gf(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : (i = t.errors) == null ? void 0 : i[a];
}
function yw() {
  let { router: e } = mw(
    "useNavigate"
    /* UseNavigateStable */
  ), t = gf(
    "useNavigate"
    /* UseNavigateStable */
  ), a = z.useRef(!1);
  return vA(() => {
    a.current = !0;
  }), z.useCallback(
    async (o, l = {}) => {
      en(a.current, RA), a.current && (typeof o == "number" ? await e.navigate(o) : await e.navigate(o, { fromRouteId: t, ...l }));
    },
    [e, t]
  );
}
var XS = {};
function kA(e, t, a) {
  !t && !XS[e] && (XS[e] = !0, en(!1, a));
}
z.memo(Tw);
function Tw({
  routes: e,
  future: t,
  state: a,
  unstable_onError: i
}) {
  return wA(e, void 0, a, i, t);
}
function IA({
  to: e,
  replace: t,
  state: a,
  relative: i
}) {
  ut(
    Ti(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: o } = z.useContext(Rn);
  en(
    !o,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: l } = z.useContext(xn), { pathname: c } = Ln(), d = ff(), m = df(
    e,
    cf(l),
    c,
    i === "path"
  ), f = JSON.stringify(m);
  return z.useEffect(() => {
    d(JSON.parse(f), { replace: t, state: a, relative: i });
  }, [d, f, i, t, a]), null;
}
function Ds(e) {
  ut(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."
  );
}
function Sw({
  basename: e = "/",
  children: t = null,
  location: a,
  navigationType: i = "POP",
  navigator: o,
  static: l = !1,
  unstable_useTransitions: c
}) {
  ut(
    !Ti(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let d = e.replace(/^\/*/, "/"), m = z.useMemo(
    () => ({
      basename: d,
      navigator: o,
      static: l,
      unstable_useTransitions: c,
      future: {}
    }),
    [d, o, l, c]
  );
  typeof a == "string" && (a = br(a));
  let {
    pathname: f = "/",
    search: b = "",
    hash: E = "",
    state: T = null,
    key: S = "default"
  } = a, _ = z.useMemo(() => {
    let k = pa(f, d);
    return k == null ? null : {
      location: {
        pathname: k,
        search: b,
        hash: E,
        state: T,
        key: S
      },
      navigationType: i
    };
  }, [d, f, b, E, T, S, i]);
  return en(
    _ != null,
    `<Router basename="${d}"> is not able to match the URL "${f}${b}${E}" because it does not start with the basename, so the <Router> won't render anything.`
  ), _ == null ? null : /* @__PURE__ */ z.createElement(Rn.Provider, { value: m }, /* @__PURE__ */ z.createElement(Js.Provider, { children: t, value: _ }));
}
function _w({
  children: e,
  location: t
}) {
  return lw(vp(e), t);
}
function vp(e, t = []) {
  let a = [];
  return z.Children.forEach(e, (i, o) => {
    if (!z.isValidElement(i))
      return;
    let l = [...t, o];
    if (i.type === z.Fragment) {
      a.push.apply(
        a,
        vp(i.props.children, l)
      );
      return;
    }
    ut(
      i.type === Ds,
      `[${typeof i.type == "string" ? i.type : i.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    ), ut(
      !i.props.index || !i.props.children,
      "An index route cannot have child routes."
    );
    let c = {
      id: i.props.id || l.join("-"),
      caseSensitive: i.props.caseSensitive,
      element: i.props.element,
      Component: i.props.Component,
      index: i.props.index,
      path: i.props.path,
      middleware: i.props.middleware,
      loader: i.props.loader,
      action: i.props.action,
      hydrateFallbackElement: i.props.hydrateFallbackElement,
      HydrateFallback: i.props.HydrateFallback,
      errorElement: i.props.errorElement,
      ErrorBoundary: i.props.ErrorBoundary,
      hasErrorBoundary: i.props.hasErrorBoundary === !0 || i.props.ErrorBoundary != null || i.props.errorElement != null,
      shouldRevalidate: i.props.shouldRevalidate,
      handle: i.props.handle,
      lazy: i.props.lazy
    };
    i.props.children && (c.children = vp(
      i.props.children,
      l
    )), a.push(c);
  }), a;
}
var jl = "get", $l = "application/x-www-form-urlencoded";
function ou(e) {
  return typeof HTMLElement < "u" && e instanceof HTMLElement;
}
function Aw(e) {
  return ou(e) && e.tagName.toLowerCase() === "button";
}
function Nw(e) {
  return ou(e) && e.tagName.toLowerCase() === "form";
}
function Rw(e) {
  return ou(e) && e.tagName.toLowerCase() === "input";
}
function vw(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Cw(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !vw(e);
}
function Cp(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, a) => {
      let i = e[a];
      return t.concat(
        Array.isArray(i) ? i.map((o) => [a, o]) : [[a, i]]
      );
    }, [])
  );
}
function ww(e, t) {
  let a = Cp(e);
  return t && t.forEach((i, o) => {
    a.has(o) || t.getAll(o).forEach((l) => {
      a.append(o, l);
    });
  }), a;
}
var Ul = null;
function kw() {
  if (Ul === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Ul = !1;
    } catch {
      Ul = !0;
    }
  return Ul;
}
var Iw = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function Jd(e) {
  return e != null && !Iw.has(e) ? (en(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${$l}"`
  ), null) : e;
}
function Ow(e, t) {
  let a, i, o, l, c;
  if (Nw(e)) {
    let d = e.getAttribute("action");
    i = d ? pa(d, t) : null, a = e.getAttribute("method") || jl, o = Jd(e.getAttribute("enctype")) || $l, l = new FormData(e);
  } else if (Aw(e) || Rw(e) && (e.type === "submit" || e.type === "image")) {
    let d = e.form;
    if (d == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let m = e.getAttribute("formaction") || d.getAttribute("action");
    if (i = m ? pa(m, t) : null, a = e.getAttribute("formmethod") || d.getAttribute("method") || jl, o = Jd(e.getAttribute("formenctype")) || Jd(d.getAttribute("enctype")) || $l, l = new FormData(d, e), !kw()) {
      let { name: f, type: b, value: E } = e;
      if (b === "image") {
        let T = f ? `${f}.` : "";
        l.append(`${T}x`, "0"), l.append(`${T}y`, "0");
      } else f && l.append(f, E);
    }
  } else {
    if (ou(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    a = jl, i = null, o = $l, c = e;
  }
  return l && o === "text/plain" && (c = l, l = void 0), { action: i, method: a.toLowerCase(), encType: o, formData: l, body: c };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function hf(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function xw(e, t, a) {
  let i = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return i.pathname === "/" ? i.pathname = `_root.${a}` : t && pa(i.pathname, t) === "/" ? i.pathname = `${t.replace(/\/$/, "")}/_root.${a}` : i.pathname = `${i.pathname.replace(/\/$/, "")}.${a}`, i;
}
async function Lw(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let a = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = a, a;
  } catch (a) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(a), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Dw(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function Mw(e, t, a) {
  let i = await Promise.all(
    e.map(async (o) => {
      let l = t.routes[o.route.id];
      if (l) {
        let c = await Lw(l, a);
        return c.links ? c.links() : [];
      }
      return [];
    })
  );
  return Pw(
    i.flat(1).filter(Dw).filter((o) => o.rel === "stylesheet" || o.rel === "preload").map(
      (o) => o.rel === "stylesheet" ? { ...o, rel: "prefetch", as: "style" } : { ...o, rel: "prefetch" }
    )
  );
}
function KS(e, t, a, i, o, l) {
  let c = (m, f) => a[f] ? m.route.id !== a[f].route.id : !0, d = (m, f) => {
    var b;
    return (
      // param change, /users/123 -> /users/456
      a[f].pathname !== m.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((b = a[f].route.path) == null ? void 0 : b.endsWith("*")) && a[f].params["*"] !== m.params["*"]
    );
  };
  return l === "assets" ? t.filter(
    (m, f) => c(m, f) || d(m, f)
  ) : l === "data" ? t.filter((m, f) => {
    var E;
    let b = i.routes[m.route.id];
    if (!b || !b.hasLoader)
      return !1;
    if (c(m, f) || d(m, f))
      return !0;
    if (m.route.shouldRevalidate) {
      let T = m.route.shouldRevalidate({
        currentUrl: new URL(
          o.pathname + o.search + o.hash,
          window.origin
        ),
        currentParams: ((E = a[0]) == null ? void 0 : E.params) || {},
        nextUrl: new URL(e, window.origin),
        nextParams: m.params,
        defaultShouldRevalidate: !0
      });
      if (typeof T == "boolean")
        return T;
    }
    return !0;
  }) : [];
}
function Uw(e, t, { includeHydrateFallback: a } = {}) {
  return Bw(
    e.map((i) => {
      let o = t.routes[i.route.id];
      if (!o) return [];
      let l = [o.module];
      return o.clientActionModule && (l = l.concat(o.clientActionModule)), o.clientLoaderModule && (l = l.concat(o.clientLoaderModule)), a && o.hydrateFallbackModule && (l = l.concat(o.hydrateFallbackModule)), o.imports && (l = l.concat(o.imports)), l;
    }).flat(1)
  );
}
function Bw(e) {
  return [...new Set(e)];
}
function Fw(e) {
  let t = {}, a = Object.keys(e).sort();
  for (let i of a)
    t[i] = e[i];
  return t;
}
function Pw(e, t) {
  let a = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((i, o) => {
    let l = JSON.stringify(Fw(o));
    return a.has(l) || (a.add(l), i.push({ key: l, link: o })), i;
  }, []);
}
function OA() {
  let e = z.useContext(yi);
  return hf(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Hw() {
  let e = z.useContext(su);
  return hf(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var bf = z.createContext(void 0);
bf.displayName = "FrameworkContext";
function xA() {
  let e = z.useContext(bf);
  return hf(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function zw(e, t) {
  let a = z.useContext(bf), [i, o] = z.useState(!1), [l, c] = z.useState(!1), { onFocus: d, onBlur: m, onMouseEnter: f, onMouseLeave: b, onTouchStart: E } = t, T = z.useRef(null);
  z.useEffect(() => {
    if (e === "render" && c(!0), e === "viewport") {
      let k = (C) => {
        C.forEach((L) => {
          c(L.isIntersecting);
        });
      }, R = new IntersectionObserver(k, { threshold: 0.5 });
      return T.current && R.observe(T.current), () => {
        R.disconnect();
      };
    }
  }, [e]), z.useEffect(() => {
    if (i) {
      let k = setTimeout(() => {
        c(!0);
      }, 100);
      return () => {
        clearTimeout(k);
      };
    }
  }, [i]);
  let S = () => {
    o(!0);
  }, _ = () => {
    o(!1), c(!1);
  };
  return a ? e !== "intent" ? [l, T, {}] : [
    l,
    T,
    {
      onFocus: Cs(d, S),
      onBlur: Cs(m, _),
      onMouseEnter: Cs(f, S),
      onMouseLeave: Cs(b, _),
      onTouchStart: Cs(E, S)
    }
  ] : [!1, T, {}];
}
function Cs(e, t) {
  return (a) => {
    e && e(a), a.defaultPrevented || t(a);
  };
}
function Gw({ page: e, ...t }) {
  let { router: a } = OA(), i = z.useMemo(
    () => TA(a.routes, e, a.basename),
    [a.routes, e, a.basename]
  );
  return i ? /* @__PURE__ */ z.createElement($w, { page: e, matches: i, ...t }) : null;
}
function jw(e) {
  let { manifest: t, routeModules: a } = xA(), [i, o] = z.useState([]);
  return z.useEffect(() => {
    let l = !1;
    return Mw(e, t, a).then(
      (c) => {
        l || o(c);
      }
    ), () => {
      l = !0;
    };
  }, [e, t, a]), i;
}
function $w({
  page: e,
  matches: t,
  ...a
}) {
  let i = Ln(), { manifest: o, routeModules: l } = xA(), { basename: c } = OA(), { loaderData: d, matches: m } = Hw(), f = z.useMemo(
    () => KS(
      e,
      t,
      m,
      o,
      i,
      "data"
    ),
    [e, t, m, o, i]
  ), b = z.useMemo(
    () => KS(
      e,
      t,
      m,
      o,
      i,
      "assets"
    ),
    [e, t, m, o, i]
  ), E = z.useMemo(() => {
    if (e === i.pathname + i.search + i.hash)
      return [];
    let _ = /* @__PURE__ */ new Set(), k = !1;
    if (t.forEach((C) => {
      var x;
      let L = o.routes[C.route.id];
      !L || !L.hasLoader || (!f.some((Y) => Y.route.id === C.route.id) && C.route.id in d && ((x = l[C.route.id]) != null && x.shouldRevalidate) || L.hasClientLoader ? k = !0 : _.add(C.route.id));
    }), _.size === 0)
      return [];
    let R = xw(e, c, "data");
    return k && _.size > 0 && R.searchParams.set(
      "_routes",
      t.filter((C) => _.has(C.route.id)).map((C) => C.route.id).join(",")
    ), [R.pathname + R.search];
  }, [
    c,
    d,
    i,
    o,
    f,
    t,
    e,
    l
  ]), T = z.useMemo(
    () => Uw(b, o),
    [b, o]
  ), S = jw(b);
  return /* @__PURE__ */ z.createElement(z.Fragment, null, E.map((_) => /* @__PURE__ */ z.createElement("link", { key: _, rel: "prefetch", as: "fetch", href: _, ...a })), T.map((_) => /* @__PURE__ */ z.createElement("link", { key: _, rel: "modulepreload", href: _, ...a })), S.map(({ key: _, link: k }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ z.createElement("link", { key: _, nonce: a.nonce, ...k })
  )));
}
function qw(...e) {
  return (t) => {
    e.forEach((a) => {
      typeof a == "function" ? a(t) : a != null && (a.current = t);
    });
  };
}
var LA = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  LA && (window.__reactRouterVersion = // @ts-expect-error
  "7.10.1");
} catch {
}
function Yw({
  basename: e,
  children: t,
  unstable_useTransitions: a,
  window: i
}) {
  let o = z.useRef();
  o.current == null && (o.current = OC({ window: i, v5Compat: !0 }));
  let l = o.current, [c, d] = z.useState({
    action: l.action,
    location: l.location
  }), m = z.useCallback(
    (f) => {
      a === !1 ? d(f) : z.startTransition(() => d(f));
    },
    [a]
  );
  return z.useLayoutEffect(() => l.listen(m), [l, m]), /* @__PURE__ */ z.createElement(
    Sw,
    {
      basename: e,
      children: t,
      location: c.location,
      navigationType: c.action,
      navigator: l,
      unstable_useTransitions: a === !0
    }
  );
}
var DA = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, to = z.forwardRef(
  function({
    onClick: t,
    discover: a = "render",
    prefetch: i = "none",
    relative: o,
    reloadDocument: l,
    replace: c,
    state: d,
    target: m,
    to: f,
    preventScrollReset: b,
    viewTransition: E,
    ...T
  }, S) {
    let { basename: _, unstable_useTransitions: k } = z.useContext(Rn), R = typeof f == "string" && DA.test(f), C, L = !1;
    if (typeof f == "string" && R && (C = f, LA))
      try {
        let U = new URL(window.location.href), ee = f.startsWith("//") ? new URL(U.protocol + f) : new URL(f), ae = pa(ee.pathname, _);
        ee.origin === U.origin && ae != null ? f = ae + ee.search + ee.hash : L = !0;
      } catch {
        en(
          !1,
          `<Link to="${f}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let x = sw(f, { relative: o }), [Y, q, D] = zw(
      i,
      T
    ), G = Kw(f, {
      replace: c,
      state: d,
      target: m,
      preventScrollReset: b,
      relative: o,
      viewTransition: E,
      unstable_useTransitions: k
    });
    function K(U) {
      t && t(U), U.defaultPrevented || G(U);
    }
    let Q = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ z.createElement(
        "a",
        {
          ...T,
          ...D,
          href: C || x,
          onClick: L || l ? t : K,
          ref: qw(S, q),
          target: m,
          "data-discover": !R && a === "render" ? "true" : void 0
        }
      )
    );
    return Y && !R ? /* @__PURE__ */ z.createElement(z.Fragment, null, Q, /* @__PURE__ */ z.createElement(Gw, { page: x })) : Q;
  }
);
to.displayName = "Link";
var Vw = z.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: a = !1,
    className: i = "",
    end: o = !1,
    style: l,
    to: c,
    viewTransition: d,
    children: m,
    ...f
  }, b) {
    let E = eo(c, { relative: f.relative }), T = Ln(), S = z.useContext(su), { navigator: _, basename: k } = z.useContext(Rn), R = S != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    tk(E) && d === !0, C = _.encodeLocation ? _.encodeLocation(E).pathname : E.pathname, L = T.pathname, x = S && S.navigation && S.navigation.location ? S.navigation.location.pathname : null;
    a || (L = L.toLowerCase(), x = x ? x.toLowerCase() : null, C = C.toLowerCase()), x && k && (x = pa(x, k) || x);
    const Y = C !== "/" && C.endsWith("/") ? C.length - 1 : C.length;
    let q = L === C || !o && L.startsWith(C) && L.charAt(Y) === "/", D = x != null && (x === C || !o && x.startsWith(C) && x.charAt(C.length) === "/"), G = {
      isActive: q,
      isPending: D,
      isTransitioning: R
    }, K = q ? t : void 0, Q;
    typeof i == "function" ? Q = i(G) : Q = [
      i,
      q ? "active" : null,
      D ? "pending" : null,
      R ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let U = typeof l == "function" ? l(G) : l;
    return /* @__PURE__ */ z.createElement(
      to,
      {
        ...f,
        "aria-current": K,
        className: Q,
        ref: b,
        style: U,
        to: c,
        viewTransition: d
      },
      typeof m == "function" ? m(G) : m
    );
  }
);
Vw.displayName = "NavLink";
var Ww = z.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: a,
    reloadDocument: i,
    replace: o,
    state: l,
    method: c = jl,
    action: d,
    onSubmit: m,
    relative: f,
    preventScrollReset: b,
    viewTransition: E,
    ...T
  }, S) => {
    let { unstable_useTransitions: _ } = z.useContext(Rn), k = Jw(), R = ek(d, { relative: f }), C = c.toLowerCase() === "get" ? "get" : "post", L = typeof d == "string" && DA.test(d), x = (Y) => {
      if (m && m(Y), Y.defaultPrevented) return;
      Y.preventDefault();
      let q = Y.nativeEvent.submitter, D = (q == null ? void 0 : q.getAttribute("formmethod")) || c, G = () => k(q || Y.currentTarget, {
        fetcherKey: t,
        method: D,
        navigate: a,
        replace: o,
        state: l,
        relative: f,
        preventScrollReset: b,
        viewTransition: E
      });
      _ && a !== !1 ? z.startTransition(() => G()) : G();
    };
    return /* @__PURE__ */ z.createElement(
      "form",
      {
        ref: S,
        method: C,
        action: R,
        onSubmit: i ? m : x,
        ...T,
        "data-discover": !L && e === "render" ? "true" : void 0
      }
    );
  }
);
Ww.displayName = "Form";
function Xw(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function MA(e) {
  let t = z.useContext(yi);
  return ut(t, Xw(e)), t;
}
function Kw(e, {
  target: t,
  replace: a,
  state: i,
  preventScrollReset: o,
  relative: l,
  viewTransition: c,
  unstable_useTransitions: d
} = {}) {
  let m = ff(), f = Ln(), b = eo(e, { relative: l });
  return z.useCallback(
    (E) => {
      if (Cw(E, t)) {
        E.preventDefault();
        let T = a !== void 0 ? a : Ys(f) === Ys(b), S = () => m(e, {
          replace: T,
          state: i,
          preventScrollReset: o,
          relative: l,
          viewTransition: c
        });
        d ? z.startTransition(() => S()) : S();
      }
    },
    [
      f,
      m,
      b,
      a,
      i,
      t,
      e,
      o,
      l,
      c,
      d
    ]
  );
}
function UA(e) {
  en(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = z.useRef(Cp(e)), a = z.useRef(!1), i = Ln(), o = z.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      ww(
        i.search,
        a.current ? null : t.current
      )
    ),
    [i.search]
  ), l = ff(), c = z.useCallback(
    (d, m) => {
      const f = Cp(
        typeof d == "function" ? d(new URLSearchParams(o)) : d
      );
      a.current = !0, l("?" + f, m);
    },
    [l, o]
  );
  return [o, c];
}
var Zw = 0, Qw = () => `__${String(++Zw)}__`;
function Jw() {
  let { router: e } = MA(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = z.useContext(Rn), a = bw(), i = e.fetch, o = e.navigate;
  return z.useCallback(
    async (l, c = {}) => {
      let { action: d, method: m, encType: f, formData: b, body: E } = Ow(
        l,
        t
      );
      if (c.navigate === !1) {
        let T = c.fetcherKey || Qw();
        await i(T, a, c.action || d, {
          preventScrollReset: c.preventScrollReset,
          formData: b,
          body: E,
          formMethod: c.method || m,
          formEncType: c.encType || f,
          flushSync: c.flushSync
        });
      } else
        await o(c.action || d, {
          preventScrollReset: c.preventScrollReset,
          formData: b,
          body: E,
          formMethod: c.method || m,
          formEncType: c.encType || f,
          replace: c.replace,
          state: c.state,
          fromRouteId: a,
          flushSync: c.flushSync,
          viewTransition: c.viewTransition
        });
    },
    [i, o, t, a]
  );
}
function ek(e, { relative: t } = {}) {
  let { basename: a } = z.useContext(Rn), i = z.useContext(xn);
  ut(i, "useFormAction must be used inside a RouteContext");
  let [o] = i.matches.slice(-1), l = { ...eo(e || ".", { relative: t }) }, c = Ln();
  if (e == null) {
    l.search = c.search;
    let d = new URLSearchParams(l.search), m = d.getAll("index");
    if (m.some((b) => b === "")) {
      d.delete("index"), m.filter((E) => E).forEach((E) => d.append("index", E));
      let b = d.toString();
      l.search = b ? `?${b}` : "";
    }
  }
  return (!e || e === ".") && o.route.index && (l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index"), a !== "/" && (l.pathname = l.pathname === "/" ? a : da([a, l.pathname])), Ys(l);
}
function tk(e, { relative: t } = {}) {
  let a = z.useContext(NA);
  ut(
    a != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: i } = MA(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), o = eo(e, { relative: t });
  if (!a.isTransitioning)
    return !1;
  let l = pa(a.currentLocation.pathname, i) || a.currentLocation.pathname, c = pa(a.nextLocation.pathname, i) || a.nextLocation.pathname;
  return Kl(o.pathname, c) != null || Kl(o.pathname, l) != null;
}
const no = "/api", BA = "";
function nk(e, t) {
  try {
    const a = new URL(e), i = a.pathname.replace("/jsonapi", "");
    return `${t}${i}${a.search}`;
  } catch {
    return e;
  }
}
async function FA(e, t, a = no) {
  var m, f;
  let i = [], o = [], l = e;
  for (; l; ) {
    const b = await fetch(l);
    if (!b.ok)
      throw new Error(`Failed to fetch: ${b.statusText}`);
    const E = await b.json();
    i = i.concat(E.data || []), o = o.concat(E.included || []);
    const T = ((f = (m = E.links) == null ? void 0 : m.next) == null ? void 0 : f.href) || null;
    l = T ? nk(T, a) : null;
  }
  const c = /* @__PURE__ */ new Map();
  for (const b of i)
    c.set(b.id, b);
  const d = /* @__PURE__ */ new Map();
  for (const b of o)
    d.set(b.id, b);
  return {
    data: Array.from(c.values()),
    included: Array.from(d.values())
  };
}
const lu = {
  allSoftware: (e) => `${e}/node/appverse_software?include=field_appverse_logo.field_media_image_1,field_appverse_logo.field_media_image,field_appverse_topics,field_license,field_tags`,
  allApps: (e) => `${e}/node/appverse_app?include=field_appverse_software_implemen,field_add_implementation_tags,field_appverse_app_type`,
  softwareById: (e, t) => `${e}/node/appverse_software/${t}?include=field_appverse_logo.field_media_image_1,field_appverse_logo.field_media_image,field_appverse_topics,field_license,field_tags`,
  appsBySoftwareId: (e, t) => `${e}/node/appverse_app?filter[field_appverse_software_implemen.id]=${t}&include=field_appverse_app_type,field_add_implementation_tags,field_appverse_organization,field_license`
};
async function ak(e = {}) {
  var o, l, c, d, m, f, b, E;
  const t = e.apiBaseUrl ?? no, a = e.siteBaseUrl ?? BA, i = lu.allSoftware(t);
  try {
    const { data: T, included: S } = await FA(i, "ALL_SOFTWARE", t), _ = {};
    for (const L of S)
      _[L.id] = L;
    const k = {};
    for (const L of S)
      L.type === "file--file" && (k[L.id] = L);
    const R = {};
    for (const L of S)
      if (L.type === "media--svg" || L.type === "media--image") {
        const x = L.type === "media--svg" ? (c = (l = (o = L.relationships) == null ? void 0 : o.field_media_image_1) == null ? void 0 : l.data) == null ? void 0 : c.id : (f = (m = (d = L.relationships) == null ? void 0 : d.field_media_image) == null ? void 0 : m.data) == null ? void 0 : f.id;
        if (x && k[x]) {
          const Y = (E = (b = k[x].attributes) == null ? void 0 : b.uri) == null ? void 0 : E.url;
          Y && (R[L.id] = `${a}${Y}`);
        }
      }
    return {
      software: T.map((L) => {
        var ue, de, ce, j, se, Ee, Ne, O, F, te, v, he;
        const x = (ce = (de = (ue = L.relationships) == null ? void 0 : ue.field_appverse_logo) == null ? void 0 : de.data) == null ? void 0 : ce.id, Y = x ? R[x] : null, D = (((se = (j = L.relationships) == null ? void 0 : j.field_appverse_topics) == null ? void 0 : se.data) || []).map((ye) => _[ye.id]).filter(Boolean).map((ye) => ({ id: ye.id, name: ye.attributes.name })), G = (Ne = (Ee = L.relationships) == null ? void 0 : Ee.field_license) == null ? void 0 : Ne.data, K = G && _[G.id] ? { id: G.id, name: _[G.id].attributes.name } : null, U = (((F = (O = L.relationships) == null ? void 0 : O.field_tags) == null ? void 0 : F.data) || []).map((ye) => _[ye.id]).filter(Boolean).map((ye) => ({ id: ye.id, name: ye.attributes.name })), ee = (v = (te = L.attributes) == null ? void 0 : te.path) == null ? void 0 : v.alias, ae = ee ? ee.split("/").filter(Boolean).pop() : null;
        return {
          ...L,
          title: ((he = L.attributes) == null ? void 0 : he.title) || "",
          logoUrl: Y,
          topics: D,
          license: K,
          tags: U,
          slug: ae
        };
      }),
      included: S
    };
  } catch (T) {
    throw console.error("Error fetching software:", T), T;
  }
}
async function rk(e = {}) {
  const t = e.apiBaseUrl ?? no, a = lu.allApps(t);
  try {
    const { data: i, included: o } = await FA(a, "ALL_APPS", t), l = {};
    for (const d of o)
      l[d.id] = d;
    return {
      apps: i.map((d) => {
        var T, S, _, k;
        const m = (S = (T = d.relationships) == null ? void 0 : T.field_appverse_app_type) == null ? void 0 : S.data, f = m && l[m.id] ? { id: m.id, name: l[m.id].attributes.name } : null, E = (((k = (_ = d.relationships) == null ? void 0 : _.field_add_implementation_tags) == null ? void 0 : k.data) || []).map((R) => l[R.id]).filter(Boolean).map((R) => ({ id: R.id, name: R.attributes.name }));
        return {
          ...d,
          appType: f,
          tags: E
        };
      }),
      included: o
    };
  } catch (i) {
    throw console.error("Error fetching apps:", i), i;
  }
}
function ik(e) {
  const t = {
    tags: [],
    appType: []
  };
  for (const a of e)
    a.type === "taxonomy_term--tags" ? t.tags.push({
      id: a.id,
      name: a.attributes.name
    }) : a.type === "taxonomy_term--appverse_app_type" && t.appType.push({
      id: a.id,
      name: a.attributes.name
    });
  return t.tags.sort((a, i) => a.name.localeCompare(i.name)), t.appType.sort((a, i) => a.name.localeCompare(i.name)), t;
}
function sk(e) {
  const t = {
    topics: [],
    license: [],
    tags: []
    // Software also has tags (field_tags)
  };
  for (const a of e)
    a.type === "taxonomy_term--appverse_science_domains" ? t.topics.push({
      id: a.id,
      name: a.attributes.name
    }) : a.type === "taxonomy_term--appverse_license" ? t.license.push({
      id: a.id,
      name: a.attributes.name
    }) : a.type === "taxonomy_term--tags" && t.tags.push({
      id: a.id,
      name: a.attributes.name
    });
  return t.topics.sort((a, i) => a.name.localeCompare(i.name)), t.license.sort((a, i) => a.name.localeCompare(i.name)), t.tags.sort((a, i) => a.name.localeCompare(i.name)), t;
}
async function ep(e, t = {}) {
  var o, l, c, d, m, f, b, E, T, S, _, k, R, C, L, x, Y, q, D;
  const a = t.apiBaseUrl ?? no, i = t.siteBaseUrl ?? BA;
  try {
    const G = lu.softwareById(a, e), K = await fetch(G);
    if (!K.ok)
      throw new Error(`Failed to fetch software: ${K.statusText}`);
    const Q = await K.json(), U = Q.data, ee = Q.included || [], ae = {};
    for (const v of ee)
      ae[v.id] = v;
    let ue = null;
    const de = (c = (l = (o = U.relationships) == null ? void 0 : o.field_appverse_logo) == null ? void 0 : l.data) == null ? void 0 : c.id;
    if (de) {
      const v = ae[de], he = (v == null ? void 0 : v.type) === "media--svg" ? (f = (m = (d = v == null ? void 0 : v.relationships) == null ? void 0 : d.field_media_image_1) == null ? void 0 : m.data) == null ? void 0 : f.id : (T = (E = (b = v == null ? void 0 : v.relationships) == null ? void 0 : b.field_media_image) == null ? void 0 : E.data) == null ? void 0 : T.id;
      if (he && ae[he]) {
        const ye = (_ = (S = ae[he].attributes) == null ? void 0 : S.uri) == null ? void 0 : _.url;
        ye && (ue = `${i}${ye}`);
      }
    }
    const j = (((R = (k = U.relationships) == null ? void 0 : k.field_appverse_topics) == null ? void 0 : R.data) || []).map((v) => ae[v.id]).filter(Boolean).map((v) => ({ id: v.id, name: v.attributes.name })), se = (L = (C = U.relationships) == null ? void 0 : C.field_license) == null ? void 0 : L.data, Ee = se && ae[se.id] ? { id: se.id, name: ae[se.id].attributes.name } : null, O = (((Y = (x = U.relationships) == null ? void 0 : x.field_tags) == null ? void 0 : Y.data) || []).map((v) => ae[v.id]).filter(Boolean).map((v) => ({ id: v.id, name: v.attributes.name })), F = (D = (q = U.attributes) == null ? void 0 : q.path) == null ? void 0 : D.alias, te = F ? F.split("/").filter(Boolean).pop() : null;
    return {
      ...U,
      logoUrl: ue,
      topics: j,
      license: Ee,
      tags: O,
      slug: te
    };
  } catch (G) {
    throw console.error("Error fetching software by ID:", G), G;
  }
}
async function ZS(e, t = {}) {
  const a = t.apiBaseUrl ?? no;
  try {
    const i = lu.appsBySoftwareId(a, e), o = await fetch(i);
    if (!o.ok)
      throw new Error(`Failed to fetch apps: ${o.statusText}`);
    const l = await o.json(), c = l.data || [], d = l.included || [], m = {};
    for (const b of d)
      m[b.id] = b;
    return c.map((b) => {
      var x, Y, q, D, G, K, Q, U;
      const E = (Y = (x = b.relationships) == null ? void 0 : x.field_appverse_app_type) == null ? void 0 : Y.data, T = E && m[E.id] ? { id: E.id, name: m[E.id].attributes.name } : null, S = (D = (q = b.relationships) == null ? void 0 : q.field_appverse_organization) == null ? void 0 : D.data, _ = S && m[S.id] ? { id: S.id, name: m[S.id].attributes.name } : null, k = (K = (G = b.relationships) == null ? void 0 : G.field_license) == null ? void 0 : K.data, R = k && m[k.id] ? { id: k.id, name: m[k.id].attributes.name } : null, L = (((U = (Q = b.relationships) == null ? void 0 : Q.field_add_implementation_tags) == null ? void 0 : U.data) || []).map((ee) => m[ee.id]).filter(Boolean).map((ee) => ({ id: ee.id, name: ee.attributes.name }));
      return {
        ...b,
        appType: T,
        organization: _,
        license: R,
        tags: L
      };
    });
  } catch (i) {
    throw console.error("Error fetching apps by software:", i), i;
  }
}
function ok(e) {
  var a, i, o;
  const t = {};
  for (const l of e) {
    const c = (o = (i = (a = l.relationships) == null ? void 0 : a.field_appverse_software_implemen) == null ? void 0 : i.data) == null ? void 0 : o.id;
    c && (t[c] || (t[c] = []), t[c].push(l));
  }
  return t;
}
function Us(e) {
  return e ? e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "") : "";
}
const PA = z.createContext({
  apiBaseUrl: "/api",
  siteBaseUrl: "",
  tracking: !0,
  dataLayerName: "dataLayer"
});
function lk({ config: e, children: t }) {
  const a = {
    apiBaseUrl: (e == null ? void 0 : e.apiBaseUrl) ?? "/api",
    siteBaseUrl: (e == null ? void 0 : e.siteBaseUrl) ?? "",
    tracking: (e == null ? void 0 : e.tracking) !== !1,
    dataLayerName: (e == null ? void 0 : e.dataLayerName) ?? "dataLayer"
  };
  return /* @__PURE__ */ B.jsx(PA.Provider, { value: a, children: t });
}
function uu() {
  return z.useContext(PA);
}
const HA = z.createContext(null);
function uk({ children: e }) {
  const t = uu(), [a, i] = z.useState({
    software: [],
    apps: [],
    appsBySoftwareId: {},
    filterOptions: { tags: [], appType: [], topics: [], license: [] },
    softwareLoading: !0,
    appsLoading: !0,
    error: null
  }), o = (f, b) => {
    const E = {};
    for (const T of f) E[T.id] = T;
    for (const T of b) E[T.id] = T;
    return Object.values(E).sort((T, S) => T.name.localeCompare(S.name));
  }, l = () => {
    i((f) => ({ ...f, softwareLoading: !0, appsLoading: !0, error: null })), ak(t).then(({ software: f, included: b }) => {
      const E = sk(b);
      i((T) => ({
        ...T,
        software: f,
        softwareLoading: !1,
        filterOptions: {
          ...T.filterOptions,
          topics: E.topics,
          license: E.license,
          tags: o(T.filterOptions.tags, E.tags)
        }
      }));
    }).catch((f) => {
      console.error("Failed to fetch software:", f), i((b) => ({ ...b, softwareLoading: !1, error: f }));
    }), rk(t).then(({ apps: f, included: b }) => {
      const E = ik(b), T = ok(f);
      i((S) => ({
        ...S,
        apps: f,
        appsBySoftwareId: T,
        appsLoading: !1,
        filterOptions: {
          ...S.filterOptions,
          appType: E.appType,
          tags: o(S.filterOptions.tags, E.tags)
        }
      }));
    }).catch((f) => {
      console.error("Failed to fetch apps:", f), i((b) => ({ ...b, appsLoading: !1, error: f }));
    });
  };
  z.useEffect(() => {
    l();
  }, []);
  const c = z.useMemo(() => {
    var b;
    const f = {};
    for (const E of a.software) {
      const T = (b = E.attributes) == null ? void 0 : b.title;
      if (T) {
        const S = Us(T);
        f[S] = E;
      }
    }
    return f;
  }, [a.software]), d = (f) => c[f] || null, m = {
    ...a,
    // Backward-compatible loading: true only while software is loading (grid not yet visible)
    loading: a.softwareLoading,
    slugMap: c,
    getSoftwareBySlug: d,
    refetch: l
    // Allow manual refetch if needed
  };
  return /* @__PURE__ */ B.jsx(HA.Provider, { value: m, children: e });
}
let tp = null, ci = null;
async function ck(e = "/api", t = "") {
  const i = `${t}/user/login_status?_format=json`;
  try {
    const o = await fetch(i, {
      credentials: "include"
    });
    if (!o.ok)
      return console.error("[FlagApi] Login status check failed:", o.status), { authenticated: !1, flaggedIds: [], userUuid: null };
    if (await o.json() !== 1)
      return { authenticated: !1, flaggedIds: [], userUuid: null };
    const [c, d] = await Promise.all([
      dk(e),
      pk(e)
    ]);
    return {
      authenticated: !0,
      userUuid: c,
      flaggedIds: d.flaggedIds,
      flaggingMap: d.flaggingMap
    };
  } catch (o) {
    return console.error("[FlagApi] Auth check failed:", o), { authenticated: !1, flaggedIds: [], userUuid: null };
  }
}
async function dk(e) {
  var t, a, i, o;
  try {
    const l = await fetch(e, { credentials: "include" });
    if (!l.ok)
      return console.error("[FlagApi] JSON:API root fetch failed:", l.status), null;
    const c = await l.json(), d = (o = (i = (a = (t = c == null ? void 0 : c.meta) == null ? void 0 : t.links) == null ? void 0 : a.me) == null ? void 0 : i.meta) == null ? void 0 : o.id;
    return d || console.error("[FlagApi] No user UUID in JSON:API root response"), d || null;
  } catch (l) {
    return console.error("[FlagApi] Failed to fetch user UUID:", l), null;
  }
}
async function pk(e) {
  var t, a, i;
  try {
    const o = `${e}/flagging/appverse_apps`, l = await fetch(o, { credentials: "include" });
    if (!l.ok)
      return console.error("[FlagApi] Flaggings fetch failed:", l.status), { flaggedIds: [], flaggingMap: {} };
    const c = await l.json(), d = [], m = {};
    for (const f of c.data || []) {
      const b = (i = (a = (t = f.relationships) == null ? void 0 : t.flagged_entity) == null ? void 0 : a.data) == null ? void 0 : i.id;
      b && (d.push(b), m[b] = f.id);
    }
    return { flaggedIds: d, flaggingMap: m };
  } catch (o) {
    return console.error("[FlagApi] Flaggings fetch failed:", o), { flaggedIds: [], flaggingMap: {} };
  }
}
async function zA(e = "") {
  if (tp)
    return tp;
  if (ci)
    return ci;
  const a = `${e}/session/token`;
  return ci = fetch(a, {
    credentials: "include"
  }).then((i) => {
    if (!i.ok)
      throw new Error(`Failed to fetch CSRF token: ${i.statusText}`);
    return i.text();
  }).then((i) => (tp = i, ci = null, i)).catch((i) => {
    throw ci = null, i;
  }), ci;
}
async function fk(e, t, a, i = "/api", o = "") {
  var b;
  const l = await zA(o), c = {
    data: {
      type: "flagging--appverse_apps",
      attributes: {
        entity_type: "node",
        entity_id: String(t)
      },
      relationships: {
        uid: {
          data: { type: "user--user", id: a }
        },
        flagged_entity: {
          data: { type: "node--appverse_app", id: e }
        }
      }
    }
  }, d = `${i}/flagging/appverse_apps`, m = await fetch(d, {
    method: "POST",
    credentials: "include",
    headers: {
      "Content-Type": "application/vnd.api+json",
      Accept: "application/vnd.api+json",
      "X-CSRF-Token": l
    },
    body: JSON.stringify(c)
  });
  if (!m.ok) {
    const E = await m.text();
    throw console.error("[FlagApi] Flag failed:", m.status, E), new Error(`Flag failed: ${m.status}`);
  }
  return { flaggingId: (b = (await m.json()).data) == null ? void 0 : b.id };
}
async function mk(e, t = "/api", a = "") {
  const i = await zA(a), o = `${t}/flagging/appverse_apps/${e}`, l = await fetch(o, {
    method: "DELETE",
    credentials: "include",
    headers: {
      Accept: "application/vnd.api+json",
      "X-CSRF-Token": i
    }
  });
  if (!l.ok) {
    const c = await l.text();
    throw console.error("[FlagApi] Unflag failed:", l.status, c), new Error(`Unflag failed: ${l.status}`);
  }
}
const GA = z.createContext(null);
function gk({ children: e }) {
  const t = uu(), [a, i] = z.useState(/* @__PURE__ */ new Set()), [o, l] = z.useState({}), [c, d] = z.useState(!0), [m, f] = z.useState(!1), [b, E] = z.useState(null), [T, S] = z.useState(/* @__PURE__ */ new Set()), [_, k] = z.useState({});
  z.useEffect(() => {
    (async () => {
      const D = await ck(t.apiBaseUrl, t.siteBaseUrl);
      f(D.authenticated), E(D.userUuid || null), i(new Set(D.flaggedIds)), l(D.flaggingMap || {}), d(!1);
    })();
  }, [t.apiBaseUrl, t.siteBaseUrl]);
  const R = z.useCallback((q) => a.has(q), [a]), C = z.useCallback((q) => T.has(q), [T]), L = z.useCallback((q) => _[q] || 0, [_]), x = z.useCallback(async (q, D) => {
    if (!m || T.has(q)) return;
    if (!b) {
      console.error("[FlagContext] Cannot toggle flag: no user UUID available");
      return;
    }
    const G = a.has(q);
    S((K) => new Set(K).add(q)), i((K) => {
      const Q = new Set(K);
      return G ? Q.delete(q) : Q.add(q), Q;
    });
    try {
      if (G) {
        const K = o[q];
        if (!K)
          throw new Error(`No flagging UUID found for app ${q}`);
        await mk(K, t.apiBaseUrl, t.siteBaseUrl), l((Q) => {
          const U = { ...Q };
          return delete U[q], U;
        }), k((Q) => ({
          ...Q,
          [q]: (Q[q] || 0) - 1
        }));
      } else {
        const K = await fk(q, D, b, t.apiBaseUrl, t.siteBaseUrl);
        l((Q) => ({ ...Q, [q]: K.flaggingId })), k((Q) => ({
          ...Q,
          [q]: (Q[q] || 0) + 1
        }));
      }
    } catch (K) {
      console.error("[FlagContext] toggleFlag failed, rolling back:", K), i((Q) => {
        const U = new Set(Q);
        return G ? U.add(q) : U.delete(q), U;
      });
    } finally {
      S((K) => {
        const Q = new Set(K);
        return Q.delete(q), Q;
      });
    }
  }, [m, b, a, o, T, t.apiBaseUrl, t.siteBaseUrl]), Y = {
    authenticated: m,
    loading: c,
    isFlagged: R,
    isPending: C,
    toggleFlag: x,
    getFlagCountAdjustment: L,
    siteBaseUrl: t.siteBaseUrl
  };
  return /* @__PURE__ */ B.jsx(GA.Provider, { value: Y, children: e });
}
function jA() {
  const e = z.useContext(GA);
  if (!e)
    throw new Error("useFlag must be used within FlagProvider");
  return e;
}
function hk(e, t = {}, { dataLayerName: a = "dataLayer" } = {}) {
  const i = window[a];
  if (!Array.isArray(i))
    return;
  const { event: o, ...l } = t;
  i.push({
    event: `appverse_${e}`,
    ...l
  });
}
const bk = () => {
};
function Er() {
  const { tracking: e, dataLayerName: t } = uu(), a = z.useCallback(
    (i, o = {}) => {
      hk(i, o, { dataLayerName: t });
    },
    [t]
  );
  return e ? a : bk;
}
function Ek() {
  const e = Er(), { pathname: t } = Ln();
  z.useEffect(() => {
    const a = t === "/", i = a ? void 0 : t.replace(/^\//, "");
    e("page_view", {
      page_type: a ? "home" : "software_detail",
      page_path: t,
      ...i && { software_slug: i }
    });
  }, [t, e]);
}
function $A() {
  const e = z.useContext(HA);
  if (!e)
    throw new Error("useAppverseData must be used within AppverseDataProvider");
  return e;
}
function yk(e) {
  return e ? e.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim() : "";
}
function Tk(e, t, a) {
  return z.useMemo(() => {
    if (!e) return [];
    if (!a || a.trim() === "") return e;
    const i = a.toLowerCase().trim();
    return e.filter((o) => {
      var T, S, _, k, R, C, L, x, Y, q, D, G, K;
      if ((((S = (T = o.attributes) == null ? void 0 : T.title) == null ? void 0 : S.toLowerCase()) || "").includes(i)) return !0;
      const c = ((k = (_ = o.attributes) == null ? void 0 : _.body) == null ? void 0 : k.processed) || "", d = ((C = (R = o.attributes) == null ? void 0 : R.body) == null ? void 0 : C.value) || "";
      if (yk(c || d).toLowerCase().includes(i) || (((L = o.tags) == null ? void 0 : L.map((Q) => Q.name.toLowerCase())) || []).some((Q) => Q.includes(i)) || (((x = o.topics) == null ? void 0 : x.map((Q) => Q.name.toLowerCase())) || []).some((Q) => Q.includes(i))) return !0;
      const E = t[o.id] || [];
      for (const Q of E)
        if ((((q = (Y = Q.attributes) == null ? void 0 : Y.title) == null ? void 0 : q.toLowerCase()) || "").includes(i) || (((G = (D = Q.organization) == null ? void 0 : D.name) == null ? void 0 : G.toLowerCase()) || "").includes(i) || (((K = Q.tags) == null ? void 0 : K.map((ue) => ue.name.toLowerCase())) || []).some((ue) => ue.includes(i))) return !0;
      return !1;
    });
  }, [e, t, a]);
}
var np = { exports: {} }, ap, QS;
function Sk() {
  if (QS) return ap;
  QS = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ap = e, ap;
}
var rp, JS;
function _k() {
  if (JS) return rp;
  JS = 1;
  var e = /* @__PURE__ */ Sk();
  function t() {
  }
  function a() {
  }
  return a.resetWarningCache = t, rp = function() {
    function i(c, d, m, f, b, E) {
      if (E !== e) {
        var T = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw T.name = "Invariant Violation", T;
      }
    }
    i.isRequired = i;
    function o() {
      return i;
    }
    var l = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: o,
      element: i,
      elementType: i,
      instanceOf: o,
      node: i,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: a,
      resetWarningCache: t
    };
    return l.PropTypes = l, l;
  }, rp;
}
var e_;
function Ak() {
  return e_ || (e_ = 1, np.exports = /* @__PURE__ */ _k()()), np.exports;
}
var Nk = /* @__PURE__ */ Ak();
const ge = /* @__PURE__ */ iu(Nk);
var Rk = ["color", "size", "title", "className"];
function wp() {
  return wp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, wp.apply(null, arguments);
}
function vk(e, t) {
  if (e == null) return {};
  var a, i, o = Ck(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Ck(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var qA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = vk(e, Rk);
  return /* @__PURE__ */ Re.createElement("svg", wp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-book", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M1 2.828c.885-.37 2.154-.769 3.388-.893 1.33-.134 2.458.063 3.112.752v9.746c-.935-.53-2.12-.603-3.213-.493-1.18.12-2.37.461-3.287.811zm7.5-.141c.654-.689 1.782-.886 3.112-.752 1.234.124 2.503.523 3.388.893v9.923c-.918-.35-2.107-.692-3.287-.81-1.094-.111-2.278-.039-3.213.492zM8 1.783C7.015.936 5.587.81 4.287.94c-1.514.153-3.042.672-3.994 1.105A.5.5 0 0 0 0 2.5v11a.5.5 0 0 0 .707.455c.882-.4 2.303-.881 3.68-1.02 1.409-.142 2.59.087 3.223.877a.5.5 0 0 0 .78 0c.633-.79 1.814-1.019 3.222-.877 1.378.139 2.8.62 3.681 1.02A.5.5 0 0 0 16 13.5v-11a.5.5 0 0 0-.293-.455c-.952-.433-2.48-.952-3.994-1.105C10.413.809 8.985.936 8 1.783"
  }));
});
qA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var wk = ["color", "size", "title", "className"];
function kp() {
  return kp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, kp.apply(null, arguments);
}
function kk(e, t) {
  if (e == null) return {};
  var a, i, o = Ik(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Ik(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var YA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = kk(e, wk);
  return /* @__PURE__ */ Re.createElement("svg", kp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-chevron-down", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    fillRule: "evenodd",
    d: "M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708"
  }));
});
YA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Ok = ["color", "size", "title", "className"];
function Ip() {
  return Ip = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Ip.apply(null, arguments);
}
function xk(e, t) {
  if (e == null) return {};
  var a, i, o = Lk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Lk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var VA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = xk(e, Ok);
  return /* @__PURE__ */ Re.createElement("svg", Ip({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-chevron-left", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    fillRule: "evenodd",
    d: "M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0"
  }));
});
VA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Dk = ["color", "size", "title", "className"];
function Op() {
  return Op = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Op.apply(null, arguments);
}
function Mk(e, t) {
  if (e == null) return {};
  var a, i, o = Uk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Uk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var Zl = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = Mk(e, Dk);
  return /* @__PURE__ */ Re.createElement("svg", Op({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-chevron-right", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    fillRule: "evenodd",
    d: "M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708"
  }));
});
Zl.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Bk = ["color", "size", "title", "className"];
function xp() {
  return xp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, xp.apply(null, arguments);
}
function Fk(e, t) {
  if (e == null) return {};
  var a, i, o = Pk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Pk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var WA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = Fk(e, Bk);
  return /* @__PURE__ */ Re.createElement("svg", xp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-exclamation-circle", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"
  }), /* @__PURE__ */ Re.createElement("path", {
    d: "M7.002 11a1 1 0 1 1 2 0 1 1 0 0 1-2 0M7.1 4.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0z"
  }));
});
WA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Hk = ["color", "size", "title", "className"];
function Lp() {
  return Lp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Lp.apply(null, arguments);
}
function zk(e, t) {
  if (e == null) return {};
  var a, i, o = Gk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Gk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var XA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = zk(e, Hk);
  return /* @__PURE__ */ Re.createElement("svg", Lp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-file-earmark-code", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5z"
  }), /* @__PURE__ */ Re.createElement("path", {
    d: "M8.646 6.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L10.293 9 8.646 7.354a.5.5 0 0 1 0-.708m-1.292 0a.5.5 0 0 0-.708 0l-2 2a.5.5 0 0 0 0 .708l2 2a.5.5 0 0 0 .708-.708L5.707 9l1.647-1.646a.5.5 0 0 0 0-.708"
  }));
});
XA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var jk = ["color", "size", "title", "className"];
function Dp() {
  return Dp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Dp.apply(null, arguments);
}
function $k(e, t) {
  if (e == null) return {};
  var a, i, o = qk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function qk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var KA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = $k(e, jk);
  return /* @__PURE__ */ Re.createElement("svg", Dp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-file-earmark-lock", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M10 7v1.076c.54.166 1 .597 1 1.224v2.4c0 .816-.781 1.3-1.5 1.3h-3c-.719 0-1.5-.484-1.5-1.3V9.3c0-.627.46-1.058 1-1.224V7a2 2 0 1 1 4 0M7 7v1h2V7a1 1 0 0 0-2 0M6 9.3v2.4c0 .042.02.107.105.175A.64.64 0 0 0 6.5 12h3a.64.64 0 0 0 .395-.125c.085-.068.105-.133.105-.175V9.3c0-.042-.02-.107-.105-.175A.64.64 0 0 0 9.5 9h-3a.64.64 0 0 0-.395.125C6.02 9.193 6 9.258 6 9.3"
  }), /* @__PURE__ */ Re.createElement("path", {
    d: "M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2M9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5z"
  }));
});
KA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Yk = ["color", "size", "title", "className"];
function Mp() {
  return Mp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Mp.apply(null, arguments);
}
function Vk(e, t) {
  if (e == null) return {};
  var a, i, o = Wk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Wk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var ZA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = Vk(e, Yk);
  return /* @__PURE__ */ Re.createElement("svg", Mp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-file-text", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M5 4a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1zm-.5 2.5A.5.5 0 0 1 5 6h6a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5M5 8a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1zm0 2a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1z"
  }), /* @__PURE__ */ Re.createElement("path", {
    d: "M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1"
  }));
});
ZA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Xk = ["color", "size", "title", "className"];
function Up() {
  return Up = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Up.apply(null, arguments);
}
function Kk(e, t) {
  if (e == null) return {};
  var a, i, o = Zk(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function Zk(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var QA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = Kk(e, Xk);
  return /* @__PURE__ */ Re.createElement("svg", Up({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-flag-fill", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M14.778.085A.5.5 0 0 1 15 .5V8a.5.5 0 0 1-.314.464L14.5 8l.186.464-.003.001-.006.003-.023.009a12 12 0 0 1-.397.15c-.264.095-.631.223-1.047.35-.816.252-1.879.523-2.71.523-.847 0-1.548-.28-2.158-.525l-.028-.01C7.68 8.71 7.14 8.5 6.5 8.5c-.7 0-1.638.23-2.437.477A20 20 0 0 0 3 9.342V15.5a.5.5 0 0 1-1 0V.5a.5.5 0 0 1 1 0v.282c.226-.079.496-.17.79-.26C4.606.272 5.67 0 6.5 0c.84 0 1.524.277 2.121.519l.043.018C9.286.788 9.828 1 10.5 1c.7 0 1.638-.23 2.437-.477a20 20 0 0 0 1.349-.476l.019-.007.004-.002h.001"
  }));
});
QA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var Qk = ["color", "size", "title", "className"];
function Bp() {
  return Bp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Bp.apply(null, arguments);
}
function Jk(e, t) {
  if (e == null) return {};
  var a, i, o = eI(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function eI(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var JA = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = Jk(e, Qk);
  return /* @__PURE__ */ Re.createElement("svg", Bp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-globe", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m7.5-6.923c-.67.204-1.335.82-1.887 1.855A8 8 0 0 0 5.145 4H7.5zM4.09 4a9.3 9.3 0 0 1 .64-1.539 7 7 0 0 1 .597-.933A7.03 7.03 0 0 0 2.255 4zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a7 7 0 0 0-.656 2.5zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5zM8.5 5v2.5h2.99a12.5 12.5 0 0 0-.337-2.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5zM5.145 12q.208.58.468 1.068c.552 1.035 1.218 1.65 1.887 1.855V12zm.182 2.472a7 7 0 0 1-.597-.933A9.3 9.3 0 0 1 4.09 12H2.255a7 7 0 0 0 3.072 2.472M3.82 11a13.7 13.7 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5zm6.853 3.472A7 7 0 0 0 13.745 12H11.91a9.3 9.3 0 0 1-.64 1.539 7 7 0 0 1-.597.933M8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855q.26-.487.468-1.068zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.7 13.7 0 0 1-.312 2.5m2.802-3.5a7 7 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7 7 0 0 0-3.072-2.472c.218.284.418.598.597.933M10.855 4a8 8 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4z"
  }));
});
JA.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var tI = ["color", "size", "title", "className"];
function Fp() {
  return Fp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Fp.apply(null, arguments);
}
function nI(e, t) {
  if (e == null) return {};
  var a, i, o = aI(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function aI(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var e1 = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = nI(e, tI);
  return /* @__PURE__ */ Re.createElement("svg", Fp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-plus", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4"
  }));
});
e1.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var rI = ["color", "size", "title", "className"];
function Pp() {
  return Pp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Pp.apply(null, arguments);
}
function iI(e, t) {
  if (e == null) return {};
  var a, i, o = sI(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function sI(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var Ef = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = iI(e, rI);
  return /* @__PURE__ */ Re.createElement("svg", Pp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-search", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"
  }));
});
Ef.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var oI = ["color", "size", "title", "className"];
function Hp() {
  return Hp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, Hp.apply(null, arguments);
}
function lI(e, t) {
  if (e == null) return {};
  var a, i, o = uI(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function uI(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var Ql = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = lI(e, oI);
  return /* @__PURE__ */ Re.createElement("svg", Hp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-star-fill", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"
  }));
});
Ql.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
var cI = ["color", "size", "title", "className"];
function zp() {
  return zp = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, zp.apply(null, arguments);
}
function dI(e, t) {
  if (e == null) return {};
  var a, i, o = pI(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function pI(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
var t1 = /* @__PURE__ */ z.forwardRef(function(e, t) {
  var a = e.color, i = a === void 0 ? "currentColor" : a, o = e.size, l = o === void 0 ? "1em" : o, c = e.title, d = c === void 0 ? null : c, m = e.className, f = m === void 0 ? "" : m, b = dI(e, cI);
  return /* @__PURE__ */ Re.createElement("svg", zp({
    ref: t,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    width: l,
    height: l,
    fill: i,
    className: ["bi", "bi-x", f].filter(Boolean).join(" ")
  }, b), d ? /* @__PURE__ */ Re.createElement("title", null, d) : null, /* @__PURE__ */ Re.createElement("path", {
    d: "M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"
  }));
});
t1.propTypes = {
  color: ge.string,
  size: ge.oneOfType([ge.string, ge.number]),
  title: ge.string,
  className: ge.string
};
function n1({ error: e, onRetry: t }) {
  return /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center justify-center min-h-[400px] py-12 px-4", children: [
    /* @__PURE__ */ B.jsx("div", { className: "w-16 h-16 rounded-full bg-appverse-pink flex items-center justify-center mb-4", children: /* @__PURE__ */ B.jsx(WA, { className: "w-8 h-8 text-appverse-red" }) }),
    /* @__PURE__ */ B.jsx("h2", { className: "text-2xl font-serif text-appverse-black mb-2", children: "Unable to Load Data" }),
    /* @__PURE__ */ B.jsx("p", { className: "text-appverse-black text-center max-w-md mb-6", children: (e == null ? void 0 : e.message) || "An unexpected error occurred. Please try again." }),
    t && /* @__PURE__ */ B.jsx(
      "button",
      {
        onClick: t,
        className: "px-6 py-2 bg-appverse-red text-white rounded-appverse font-sans font-semibold hover:opacity-90 transition-opacity",
        children: "Try Again"
      }
    )
  ] });
}
function fI({
  value: e,
  onChange: t,
  placeholder: a = "Search software..."
}) {
  return /* @__PURE__ */ B.jsxs("div", { className: "relative w-full max-w-2xl", children: [
    /* @__PURE__ */ B.jsx(
      "input",
      {
        type: "text",
        value: e,
        onChange: (i) => t(i.target.value),
        placeholder: a,
        className: "w-full pl-4 pr-10 py-2 border border-gray-300 bg-white text-gray-900 placeholder-gray-400 focus:outline-none focus:border-gray-400 hover:border-gray-400 focus:ring-0 transition-colors rounded-appverse"
      }
    ),
    /* @__PURE__ */ B.jsx("div", { className: "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none", children: /* @__PURE__ */ B.jsx(Ef, { className: "h-4 w-4 text-gray-600" }) })
  ] });
}
function a1({ filters: e, onFilterChange: t, filterOptions: a = {}, isInDrawer: i = !1 }) {
  var S, _, k;
  const [o, l] = z.useState({
    topics: !0,
    appType: !0,
    tags: !0
  }), c = 8, d = z.useRef({}), m = z.useRef(!1);
  z.useEffect(() => {
    if (m.current || !Object.keys(e).some((Y) => {
      var q;
      return ((q = e[Y]) == null ? void 0 : q.length) > 0;
    }) || !Object.keys(a).some((Y) => {
      var q;
      return ((q = a[Y]) == null ? void 0 : q.length) > 0;
    }))
      return;
    const L = () => {
      let Y = !1;
      Object.keys(e).forEach((q) => {
        var U;
        const D = d.current[q];
        if (!D) return;
        const G = (U = e[q]) == null ? void 0 : U[0];
        if (!G)
          return;
        const K = `input[data-value="${CSS.escape(G)}"]`, Q = D.querySelector(K);
        if (Q) {
          const ee = Q.closest("label");
          ee && (ee.scrollIntoView({ block: "center", behavior: "instant" }), Y = !0);
        }
      }), Y && (m.current = !0);
    }, x = setTimeout(() => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          L();
        });
      });
    }, 50);
    return () => clearTimeout(x);
  }, [e, a]);
  const f = [
    ((S = a.topics) == null ? void 0 : S.length) > 0 && {
      key: "topics",
      title: "Topics",
      options: a.topics.map((R) => ({
        value: R.name,
        // Use name for URL params
        label: R.name.replace(/_/g, " ")
        // "engineering_and_technology"  "engineering and technology"
      }))
    },
    ((_ = a.appType) == null ? void 0 : _.length) > 0 && {
      key: "appType",
      title: "Type",
      options: a.appType.map((R) => ({
        value: R.name,
        // Use name for URL params
        label: R.name.replace(/_/g, " ")
        // "batch_connect"  "batch connect"
      }))
    },
    ((k = a.tags) == null ? void 0 : k.length) > 0 && {
      key: "tags",
      title: "Tags",
      options: a.tags.map((R) => ({
        value: R.name,
        // Use name for URL params
        label: R.name
      }))
    }
  ].filter(Boolean), b = (R, C, L) => {
    if (C === "all") {
      const q = { ...e };
      delete q[R], t(q);
      return;
    }
    const x = e[R] || [], Y = L ? [...x, C] : x.filter((q) => q !== C);
    t({
      ...e,
      [R]: Y.length > 0 ? Y : void 0
    });
  }, E = (R, C) => C === "all" ? !e[R] || e[R].length === 0 : (e[R] || []).includes(C), T = /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    f.map((R) => {
      const C = o[R.key];
      return /* @__PURE__ */ B.jsxs("div", { className: "mb-6 border border-gray-200 rounded-lg overflow-hidden", children: [
        /* @__PURE__ */ B.jsxs(
          "button",
          {
            onClick: () => l({
              ...o,
              [R.key]: !C
            }),
            className: "w-full flex items-center justify-between bg-gray-100 px-4 py-2 hover:bg-gray-200 transition-colors",
            children: [
              /* @__PURE__ */ B.jsxs("h3", { className: "text-base font-serif font-bold text-gray-900", children: [
                R.title,
                " (",
                R.options.length,
                ")"
              ] }),
              /* @__PURE__ */ B.jsx(
                YA,
                {
                  className: `w-4 h-4 text-gray-600 transition-transform ${C ? "rotate-180" : ""}`
                }
              )
            ]
          }
        ),
        C && /* @__PURE__ */ B.jsx(
          "div",
          {
            ref: (L) => d.current[R.key] = L,
            className: `px-4 py-3 space-y-2 ${R.options.length > c ? "max-h-64 overflow-y-auto" : ""}`,
            children: R.options.map((L) => {
              const x = E(R.key, L.value);
              return /* @__PURE__ */ B.jsxs(
                "label",
                {
                  className: "flex items-center cursor-pointer group",
                  children: [
                    /* @__PURE__ */ B.jsx(
                      "input",
                      {
                        type: "checkbox",
                        "data-value": L.value,
                        checked: x,
                        onChange: (Y) => b(
                          R.key,
                          L.value,
                          Y.target.checked
                        ),
                        className: "w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-2"
                      }
                    ),
                    /* @__PURE__ */ B.jsx("span", { className: "ml-3 text-sm font-sans text-gray-900", children: L.label })
                  ]
                },
                L.value
              );
            })
          }
        )
      ] }, R.key);
    }),
    Object.keys(e).some((R) => {
      var C;
      return ((C = e[R]) == null ? void 0 : C.length) > 0;
    }) && /* @__PURE__ */ B.jsx(
      "button",
      {
        onClick: () => t({}),
        className: "w-full mt-4 px-4 py-2 text-sm font-sans font-semibold text-appverse-red border-2 border-appverse-red rounded-appverse hover:bg-appverse-pink transition-colors",
        children: "Clear All Filters"
      }
    )
  ] });
  return i ? T : /* @__PURE__ */ B.jsx("aside", { className: "w-64 flex-shrink-0", children: /* @__PURE__ */ B.jsx("div", { className: "sticky top-4 max-h-[calc(100vh-2rem)] overflow-y-auto pr-2", children: T }) });
}
const mI = [
  "nav.navbar.fixed-top",
  "nav.navbar.secondary-nav"
  // Add other fixed header selectors here as needed
];
function gI() {
  const [e, t] = z.useState(0);
  return z.useEffect(() => {
    const a = () => {
      let i = 0;
      for (const o of mI) {
        const l = document.querySelector(o);
        if (l) {
          const c = l.getBoundingClientRect();
          (c.top >= 0 && c.top < 100 || c.top < 0) && (i = Math.max(i, c.bottom));
        }
      }
      t(i);
    };
    return a(), window.addEventListener("resize", a), () => window.removeEventListener("resize", a);
  }, []), e;
}
function hI({
  isOpen: e,
  onClose: t,
  filters: a,
  onFilterChange: i,
  filterOptions: o
}) {
  const l = gI();
  return z.useEffect(() => {
    const c = () => window.innerWidth < 1024, d = () => {
      e && c() ? document.body.style.overflow = "hidden" : document.body.style.overflow = "";
    };
    return d(), window.addEventListener("resize", d), () => {
      document.body.style.overflow = "", window.removeEventListener("resize", d);
    };
  }, [e]), z.useEffect(() => {
    const c = (d) => {
      d.key === "Escape" && e && t();
    };
    return document.addEventListener("keydown", c), () => document.removeEventListener("keydown", c);
  }, [e, t]), e ? /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    /* @__PURE__ */ B.jsx(
      "div",
      {
        className: "lg:hidden fixed inset-0 bg-black/50 z-40",
        style: { top: l },
        onClick: t,
        "aria-hidden": "true"
      }
    ),
    /* @__PURE__ */ B.jsxs(
      "div",
      {
        className: "lg:hidden fixed left-0 bottom-0 z-50 w-80 max-w-[85vw] bg-white shadow-xl flex flex-col",
        style: { top: l },
        children: [
          /* @__PURE__ */ B.jsxs("div", { className: "flex items-center justify-between px-4 py-3 border-b border-gray-200 bg-gray-50", children: [
            /* @__PURE__ */ B.jsx("h2", { className: "text-lg font-serif font-bold text-gray-900", children: "Filters" }),
            /* @__PURE__ */ B.jsx(
              "button",
              {
                onClick: t,
                className: "p-2 -mr-2 text-gray-500 hover:text-gray-700 transition-colors",
                "aria-label": "Close filters",
                children: /* @__PURE__ */ B.jsx(t1, { className: "w-5 h-5" })
              }
            )
          ] }),
          /* @__PURE__ */ B.jsx("div", { className: "flex-1 overflow-y-auto p-4", children: /* @__PURE__ */ B.jsx(
            a1,
            {
              filters: a,
              onFilterChange: i,
              filterOptions: o,
              isInDrawer: !0
            }
          ) })
        ]
      }
    )
  ] }) : null;
}
function bI({ software: e, appCount: t = 0, appsLoading: a = !1 }) {
  var f;
  const i = Er(), o = ((f = e.attributes) == null ? void 0 : f.title) || "Untitled Software", l = e.logoUrl, c = Us(o), d = t === 1 ? "app" : "apps", m = (b) => {
    console.error(`Failed to load logo for ${o}:`, l);
  };
  return /* @__PURE__ */ B.jsx(
    to,
    {
      to: `/${c}`,
      className: "block group",
      onClick: () => i("software_click", {
        software_title: o,
        software_slug: c,
        app_count: t
      }),
      children: /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center gap-4 border-appverse-black border-2 rounded-lg p-6 bg-white h-[199px] hover:border-red-500 transition-all duration-200", children: [
        /* @__PURE__ */ B.jsx("div", { className: "h-[60px] w-full flex items-center justify-center", children: l ? /* @__PURE__ */ B.jsx(
          "img",
          {
            src: l,
            alt: `${o} logo`,
            className: "max-h-[60px] max-w-full object-contain",
            loading: "lazy",
            onError: m
          }
        ) : (
          // Placeholder if no logo
          /* @__PURE__ */ B.jsx("div", { className: "w-16 h-16 rounded-lg bg-gray-200 flex items-center justify-center", children: /* @__PURE__ */ B.jsx("span", { className: "text-4xl font-bold text-gray-600 leading-none", children: o.charAt(0).toUpperCase() }) })
        ) }),
        /* @__PURE__ */ B.jsx("h3", { className: "text-xl font-semibold text-center text-gray-900 line-clamp-2", children: o }),
        /* @__PURE__ */ B.jsx("div", { className: "mt-auto", children: a ? /* @__PURE__ */ B.jsxs("div", { className: "inline-flex items-center gap-1.5 animate-pulse", children: [
          /* @__PURE__ */ B.jsx("div", { className: "w-5 h-5 bg-gray-200 rounded-full" }),
          /* @__PURE__ */ B.jsx("div", { className: "w-12 h-4 bg-gray-200 rounded" })
        ] }) : /* @__PURE__ */ B.jsxs(
          "span",
          {
            role: t === 0 ? "button" : void 0,
            onClick: t === 0 ? (b) => {
              b.preventDefault(), b.stopPropagation(), window.location.href = "/node/add/appverse_app";
            } : void 0,
            className: `inline-flex items-center gap-1.5 text-base font-medium ${t === 0 ? "cursor-pointer hover:opacity-80 transition-opacity" : ""}`,
            children: [
              /* @__PURE__ */ B.jsx("span", { className: `grid place-items-center w-5 h-5 rounded-full ${t === 0 ? "bg-appverse-green" : "bg-appverse-blue"}`, children: t === 0 ? /* @__PURE__ */ B.jsx(Ql, { className: "w-2.5 h-2.5 text-white -translate-y-[0.5px]" }) : /* @__PURE__ */ B.jsx("span", { className: "text-[10px] font-bold text-white -translate-y-[2px]", children: t }) }),
              /* @__PURE__ */ B.jsx("span", { className: t === 0 ? "text-appverse-green" : "text-appverse-black", children: t === 0 ? "Add an app" : d })
            ]
          }
        ) })
      ] })
    }
  );
}
function EI() {
  return /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center gap-4 border-gray-200 border-2 rounded-lg p-6 bg-white h-[199px] animate-pulse", children: [
    /* @__PURE__ */ B.jsx("div", { className: "h-[60px] w-full flex items-center justify-center", children: /* @__PURE__ */ B.jsx("div", { className: "w-16 h-16 rounded-lg bg-gray-200" }) }),
    /* @__PURE__ */ B.jsx("div", { className: "w-3/4 h-6 bg-gray-200 rounded" }),
    /* @__PURE__ */ B.jsxs("div", { className: "mt-auto flex items-center gap-1.5", children: [
      /* @__PURE__ */ B.jsx("div", { className: "w-5 h-5 bg-gray-200 rounded-full" }),
      /* @__PURE__ */ B.jsx("div", { className: "w-16 h-4 bg-gray-200 rounded" })
    ] })
  ] });
}
function yI({ software: e, appsBySoftwareId: t, loading: a, appsLoading: i }) {
  return a ? /* @__PURE__ */ B.jsx("div", { className: "grid gap-6", style: { gridTemplateColumns: "repeat(auto-fill, minmax(199px, 1fr))" }, children: Array.from({ length: 10 }).map((o, l) => /* @__PURE__ */ B.jsx(EI, {}, l)) }) : !e || e.length === 0 ? /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center justify-center py-16", children: [
    /* @__PURE__ */ B.jsx("div", { className: "w-20 h-20 rounded-full bg-appverse-gray flex items-center justify-center mb-4", children: /* @__PURE__ */ B.jsx(Ef, { className: "w-10 h-10 text-gray-400" }) }),
    /* @__PURE__ */ B.jsx("h3", { className: "text-xl font-serif font-bold text-appverse-black mb-2", children: "No Software Found" }),
    /* @__PURE__ */ B.jsx("p", { className: "text-gray-600 font-sans text-center max-w-md", children: "No software matches your current filters. Try adjusting your search or clearing filters." })
  ] }) : /* @__PURE__ */ B.jsx("div", { className: "grid gap-6", style: { gridTemplateColumns: "repeat(auto-fill, minmax(199px, 1fr))" }, children: e.map((o) => {
    const l = (t[o.id] || []).length;
    return /* @__PURE__ */ B.jsx(
      bI,
      {
        software: o,
        appCount: l,
        appsLoading: i
      },
      o.id
    );
  }) });
}
function TI() {
  const { software: e, appsBySoftwareId: t, filterOptions: a, loading: i, appsLoading: o, error: l, refetch: c } = $A(), [d, m] = UA(), [f, b] = z.useState(
    d.get("search") || ""
  ), E = z.useMemo(() => {
    const D = {};
    for (const [G, K] of d.entries())
      G !== "search" && (D[G] ? D[G].push(K) : D[G] = [K]);
    return D;
  }, [d]), T = z.useMemo(() => {
    for (const [D] of d.entries())
      if (D !== "search")
        return !0;
    return !1;
  }, [d]), S = Er(), _ = z.useRef(null), k = z.useRef(0);
  z.useEffect(() => () => clearTimeout(_.current), []);
  const [R, C] = z.useState(T), L = (D) => {
    b(D);
    const G = new URLSearchParams(d);
    D ? G.set("search", D) : G.delete("search"), m(G), clearTimeout(_.current), D && (_.current = setTimeout(() => {
      S("search", {
        search_query: D,
        result_count: k.current
      });
    }, 500));
  }, x = z.useCallback((D) => {
    const G = Object.values(E).some((U) => U.length > 0), K = Object.values(D).some((U) => Array.isArray(U) && U.length > 0);
    if (G && !K)
      S("filter_clear_all");
    else {
      const U = /* @__PURE__ */ new Set([...Object.keys(E), ...Object.keys(D)]);
      for (const ee of U) {
        const ae = E[ee] || [], ue = D[ee] || [];
        for (const de of ue)
          ae.includes(de) || S("filter_apply", { filter_type: ee, filter_value: de });
        for (const de of ae)
          ue.includes(de) || S("filter_remove", { filter_type: ee, filter_value: de });
      }
    }
    const Q = new URLSearchParams();
    f && Q.set("search", f), Object.entries(D).forEach(([U, ee]) => {
      Array.isArray(ee) && ee.length > 0 && ee.forEach((ae) => {
        Q.append(U, ae);
      });
    }), m(Q);
  }, [E, f, m, S]), Y = Tk(e, t, f), q = z.useMemo(() => {
    if (!Y) return [];
    let D = [...Y];
    return E.topics && E.topics.length > 0 && (D = D.filter((G) => {
      var Q;
      const K = ((Q = G.topics) == null ? void 0 : Q.map((U) => U.name)) || [];
      return E.topics.some((U) => K.includes(U));
    })), E.appType && E.appType.length > 0 && (D = D.filter((G) => (t[G.id] || []).some((Q) => {
      var ee;
      const U = (ee = Q.appType) == null ? void 0 : ee.name;
      return U && E.appType.includes(U);
    }))), E.tags && E.tags.length > 0 && (D = D.filter((G) => {
      var ae;
      const K = ((ae = G.tags) == null ? void 0 : ae.map((ue) => ue.name)) || [];
      return E.tags.some((ue) => K.includes(ue)) ? !0 : (t[G.id] || []).some((ue) => {
        var ce;
        const de = ((ce = ue.tags) == null ? void 0 : ce.map((j) => j.name)) || [];
        return E.tags.some((j) => de.includes(j));
      });
    })), D.sort((G, K) => {
      const Q = (G.title || "").toLowerCase(), U = (K.title || "").toLowerCase();
      return Q.localeCompare(U);
    }), D;
  }, [Y, E, t]);
  return k.current = q.length, l ? /* @__PURE__ */ B.jsx(n1, { error: l, onRetry: c }) : /* @__PURE__ */ B.jsxs("div", { className: "mb-4 bg-white", children: [
    /* @__PURE__ */ B.jsx("div", { className: "mx-6 mt-6 mb-4", children: /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-start lg:justify-between gap-4 lg:gap-8", children: [
      /* @__PURE__ */ B.jsx("div", { className: "flex-1", children: /* @__PURE__ */ B.jsx("h2", { className: "text-3xl font-serif font-bold text-appverse-black mb-2", children: "Welcome to Appverse Alphasharing apps for all." }) }),
      /* @__PURE__ */ B.jsx(
        "a",
        {
          href: "/node/add/appverse_app",
          className: "w-full lg:w-auto text-center lg:flex-shrink-0 py-3 px-6 bg-appverse-red text-white font-sans font-semibold rounded-appverse hover:bg-red-700 transition-colors",
          children: "Add an app"
        }
      )
    ] }) }),
    /* @__PURE__ */ B.jsx("div", { className: "mx-6 my-6 bg-appverse-black px-4 py-3 rounded-appverse", children: /* @__PURE__ */ B.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
      /* @__PURE__ */ B.jsxs(
        "button",
        {
          onClick: () => {
            S("filter_toggle", { action: R ? "close" : "open" }), C(!R);
          },
          className: "flex items-center gap-2 text-white font-sans font-medium hover:opacity-80 transition-opacity",
          children: [
            R ? /* @__PURE__ */ B.jsx(VA, { className: "w-4 h-4" }) : /* @__PURE__ */ B.jsx(Zl, { className: "w-4 h-4" }),
            R ? "Hide Filters" : "Show Filters"
          ]
        }
      ),
      /* @__PURE__ */ B.jsx("div", { className: "w-80", children: /* @__PURE__ */ B.jsx(
        fI,
        {
          value: f,
          onChange: L,
          placeholder: "Search for apps"
        }
      ) })
    ] }) }),
    /* @__PURE__ */ B.jsx(
      hI,
      {
        isOpen: R,
        onClose: () => C(!1),
        filters: E,
        onFilterChange: x,
        filterOptions: a
      }
    ),
    /* @__PURE__ */ B.jsx("div", { className: "mx-6 mb-6", children: /* @__PURE__ */ B.jsxs("div", { className: "flex gap-8", children: [
      R && /* @__PURE__ */ B.jsx("div", { className: "hidden lg:block", children: /* @__PURE__ */ B.jsx(
        a1,
        {
          filters: E,
          onFilterChange: x,
          filterOptions: a
        }
      ) }),
      /* @__PURE__ */ B.jsx("main", { className: "flex-1 min-w-0", children: /* @__PURE__ */ B.jsx(
        yI,
        {
          software: q,
          appsBySoftwareId: t,
          loading: i,
          appsLoading: o
        }
      ) })
    ] }) })
  ] });
}
function SI({ message: e = "Loading..." }) {
  return /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center justify-center min-h-[400px] py-12", children: [
    /* @__PURE__ */ B.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-4 border-appverse-gray border-t-appverse-red mb-4" }),
    /* @__PURE__ */ B.jsx("p", { className: "text-appverse-black text-lg font-sans", children: e })
  ] });
}
function _I({ software: e }) {
  var T, S, _, k, R, C, L, x, Y, q;
  const t = Er(), a = ((T = e.attributes) == null ? void 0 : T.title) || "Untitled Software", i = ((_ = (S = e.attributes) == null ? void 0 : S.body) == null ? void 0 : _.processed) || ((R = (k = e.attributes) == null ? void 0 : k.body) == null ? void 0 : R.value) || "", o = e.logoUrl, l = (L = (C = e.attributes) == null ? void 0 : C.field_appverse_software_website) == null ? void 0 : L.uri, c = (Y = (x = e.attributes) == null ? void 0 : x.field_appverse_software_doc) == null ? void 0 : Y.uri, d = e.license, m = e.topics || [], f = e.tags || [], b = [
    ...m.map((D) => ({ ...D, filterType: "topics" })),
    ...f.map((D) => ({ ...D, filterType: "tags" }))
  ], E = (q = d == null ? void 0 : d.name) == null ? void 0 : q.toLowerCase().includes("open");
  return /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ B.jsx("div", { className: "flex items-start mb-4", children: o ? /* @__PURE__ */ B.jsx(
      "img",
      {
        src: o,
        alt: `${a} logo`,
        className: "w-20 h-20 object-contain"
      }
    ) : /* @__PURE__ */ B.jsx("div", { className: "w-20 h-20 rounded-appverse bg-gray-200 flex items-center justify-center", children: /* @__PURE__ */ B.jsx("span", { className: "text-4xl font-bold text-gray-600 leading-none", children: a.charAt(0).toUpperCase() }) }) }),
    /* @__PURE__ */ B.jsx("h1", { className: "text-3xl font-serif font-bold text-appverse-black mb-3", children: a }),
    /* @__PURE__ */ B.jsxs("div", { className: "flex items-center gap-4 mb-4 text-sm font-sans", children: [
      l && /* @__PURE__ */ B.jsxs(
        "a",
        {
          href: l,
          target: "_blank",
          rel: "noopener noreferrer",
          onClick: () => t("external_link", { software_title: a, link_type: "website", link_url: l }),
          className: "inline-flex items-center gap-1.5 text-appverse-black hover:text-appverse-red transition-colors",
          children: [
            /* @__PURE__ */ B.jsx(JA, { className: "w-4 h-4" }),
            "WWW"
          ]
        }
      ),
      c && /* @__PURE__ */ B.jsxs(
        "a",
        {
          href: c,
          target: "_blank",
          rel: "noopener noreferrer",
          onClick: () => t("external_link", { software_title: a, link_type: "docs", link_url: c }),
          className: "inline-flex items-center gap-1.5 text-appverse-black hover:text-appverse-red transition-colors",
          children: [
            /* @__PURE__ */ B.jsx(qA, { className: "w-4 h-4" }),
            "DOCS"
          ]
        }
      ),
      d && /* @__PURE__ */ B.jsxs("span", { className: "inline-flex items-center gap-1.5 text-appverse-black", children: [
        E ? /* @__PURE__ */ B.jsx(XA, { className: "w-4 h-4" }) : /* @__PURE__ */ B.jsx(KA, { className: "w-4 h-4" }),
        E ? "OPEN-SOURCE" : "COMMERCIAL"
      ] })
    ] }),
    i && /* @__PURE__ */ B.jsx(
      "div",
      {
        className: "text-sm font-sans text-appverse-black leading-relaxed mb-4 prose prose-sm max-w-none",
        dangerouslySetInnerHTML: { __html: i }
      }
    ),
    b.length > 0 && /* @__PURE__ */ B.jsx("div", { className: "flex flex-wrap gap-2", children: b.map((D) => /* @__PURE__ */ B.jsx(
      to,
      {
        to: `/appverse?${D.filterType}=${encodeURIComponent(D.name)}`,
        className: "px-2.5 py-1 text-xs font-sans text-appverse-black border border-appverse-black rounded hover:bg-appverse-gray transition-colors",
        children: D.name
      },
      D.id
    )) })
  ] });
}
function t_(e) {
  const t = [], a = String(e || "");
  let i = a.indexOf(","), o = 0, l = !1;
  for (; !l; ) {
    i === -1 && (i = a.length, l = !0);
    const c = a.slice(o, i).trim();
    (c || !l) && t.push(c), o = i + 1, i = a.indexOf(",", o);
  }
  return t;
}
function r1(e, t) {
  const a = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (a.padRight ? " " : "") + "," + (a.padLeft === !1 ? "" : " ")
  ).trim();
}
const AI = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, NI = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, RI = {};
function n_(e, t) {
  return (RI.jsx ? NI : AI).test(e);
}
const vI = /[ \t\n\f\r]/g;
function CI(e) {
  return typeof e == "object" ? e.type === "text" ? a_(e.value) : !1 : a_(e);
}
function a_(e) {
  return e.replace(vI, "") === "";
}
class ao {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, a, i) {
    this.normal = a, this.property = t, i && (this.space = i);
  }
}
ao.prototype.normal = {};
ao.prototype.property = {};
ao.prototype.space = void 0;
function i1(e, t) {
  const a = {}, i = {};
  for (const o of e)
    Object.assign(a, o.property), Object.assign(i, o.normal);
  return new ao(a, i, t);
}
function Vs(e) {
  return e.toLowerCase();
}
class tn {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, a) {
    this.attribute = a, this.property = t;
  }
}
tn.prototype.attribute = "";
tn.prototype.booleanish = !1;
tn.prototype.boolean = !1;
tn.prototype.commaOrSpaceSeparated = !1;
tn.prototype.commaSeparated = !1;
tn.prototype.defined = !1;
tn.prototype.mustUseProperty = !1;
tn.prototype.number = !1;
tn.prototype.overloadedBoolean = !1;
tn.prototype.property = "";
tn.prototype.spaceSeparated = !1;
tn.prototype.space = void 0;
let wI = 0;
const xe = yr(), yt = yr(), Gp = yr(), me = yr(), rt = yr(), hi = yr(), dn = yr();
function yr() {
  return 2 ** ++wI;
}
const jp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: xe,
  booleanish: yt,
  commaOrSpaceSeparated: dn,
  commaSeparated: hi,
  number: me,
  overloadedBoolean: Gp,
  spaceSeparated: rt
}, Symbol.toStringTag, { value: "Module" })), ip = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(jp)
);
class yf extends tn {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, a, i, o) {
    let l = -1;
    if (super(t, a), r_(this, "space", o), typeof i == "number")
      for (; ++l < ip.length; ) {
        const c = ip[l];
        r_(this, ip[l], (i & jp[c]) === jp[c]);
      }
  }
}
yf.prototype.defined = !0;
function r_(e, t, a) {
  a && (e[t] = a);
}
function Si(e) {
  const t = {}, a = {};
  for (const [i, o] of Object.entries(e.properties)) {
    const l = new yf(
      i,
      e.transform(e.attributes || {}, i),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(i) && (l.mustUseProperty = !0), t[i] = l, a[Vs(i)] = i, a[Vs(l.attribute)] = i;
  }
  return new ao(t, a, e.space);
}
const s1 = Si({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: yt,
    ariaAutoComplete: null,
    ariaBusy: yt,
    ariaChecked: yt,
    ariaColCount: me,
    ariaColIndex: me,
    ariaColSpan: me,
    ariaControls: rt,
    ariaCurrent: null,
    ariaDescribedBy: rt,
    ariaDetails: null,
    ariaDisabled: yt,
    ariaDropEffect: rt,
    ariaErrorMessage: null,
    ariaExpanded: yt,
    ariaFlowTo: rt,
    ariaGrabbed: yt,
    ariaHasPopup: null,
    ariaHidden: yt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: rt,
    ariaLevel: me,
    ariaLive: null,
    ariaModal: yt,
    ariaMultiLine: yt,
    ariaMultiSelectable: yt,
    ariaOrientation: null,
    ariaOwns: rt,
    ariaPlaceholder: null,
    ariaPosInSet: me,
    ariaPressed: yt,
    ariaReadOnly: yt,
    ariaRelevant: null,
    ariaRequired: yt,
    ariaRoleDescription: rt,
    ariaRowCount: me,
    ariaRowIndex: me,
    ariaRowSpan: me,
    ariaSelected: yt,
    ariaSetSize: me,
    ariaSort: null,
    ariaValueMax: me,
    ariaValueMin: me,
    ariaValueNow: me,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function o1(e, t) {
  return t in e ? e[t] : t;
}
function l1(e, t) {
  return o1(e, t.toLowerCase());
}
const kI = Si({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: hi,
    acceptCharset: rt,
    accessKey: rt,
    action: null,
    allow: null,
    allowFullScreen: xe,
    allowPaymentRequest: xe,
    allowUserMedia: xe,
    alt: null,
    as: null,
    async: xe,
    autoCapitalize: null,
    autoComplete: rt,
    autoFocus: xe,
    autoPlay: xe,
    blocking: rt,
    capture: null,
    charSet: null,
    checked: xe,
    cite: null,
    className: rt,
    cols: me,
    colSpan: null,
    content: null,
    contentEditable: yt,
    controls: xe,
    controlsList: rt,
    coords: me | hi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: xe,
    defer: xe,
    dir: null,
    dirName: null,
    disabled: xe,
    download: Gp,
    draggable: yt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: xe,
    formTarget: null,
    headers: rt,
    height: me,
    hidden: Gp,
    high: me,
    href: null,
    hrefLang: null,
    htmlFor: rt,
    httpEquiv: rt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: xe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: xe,
    itemId: null,
    itemProp: rt,
    itemRef: rt,
    itemScope: xe,
    itemType: rt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: xe,
    low: me,
    manifest: null,
    max: null,
    maxLength: me,
    media: null,
    method: null,
    min: null,
    minLength: me,
    multiple: xe,
    muted: xe,
    name: null,
    nonce: null,
    noModule: xe,
    noValidate: xe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: xe,
    optimum: me,
    pattern: null,
    ping: rt,
    placeholder: null,
    playsInline: xe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: xe,
    referrerPolicy: null,
    rel: rt,
    required: xe,
    reversed: xe,
    rows: me,
    rowSpan: me,
    sandbox: rt,
    scope: null,
    scoped: xe,
    seamless: xe,
    selected: xe,
    shadowRootClonable: xe,
    shadowRootDelegatesFocus: xe,
    shadowRootMode: null,
    shape: null,
    size: me,
    sizes: null,
    slot: null,
    span: me,
    spellCheck: yt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: me,
    step: null,
    style: null,
    tabIndex: me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: xe,
    useMap: null,
    value: yt,
    width: me,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: rt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: xe,
    // Lists. Use CSS to reduce space between items instead
    declare: xe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: me,
    // `<img>` and `<object>`
    leftMargin: me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: me,
    // `<body>`
    marginWidth: me,
    // `<body>`
    noResize: xe,
    // `<frame>`
    noHref: xe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: xe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: xe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: yt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: xe,
    disableRemotePlayback: xe,
    prefix: null,
    property: null,
    results: me,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: l1
}), II = Si({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: dn,
    accentHeight: me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: me,
    amplitude: me,
    arabicForm: null,
    ascent: me,
    attributeName: null,
    attributeType: null,
    azimuth: me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: me,
    by: null,
    calcMode: null,
    capHeight: me,
    className: rt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: me,
    diffuseConstant: me,
    direction: null,
    display: null,
    dur: null,
    divisor: me,
    dominantBaseline: null,
    download: xe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: hi,
    g2: hi,
    glyphName: hi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: me,
    horizOriginX: me,
    horizOriginY: me,
    id: null,
    ideographic: me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: me,
    k: me,
    k1: me,
    k2: me,
    k3: me,
    k4: me,
    kernelMatrix: dn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: me,
    overlineThickness: me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: rt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: me,
    pointsAtY: me,
    pointsAtZ: me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: dn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: dn,
    rev: dn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: dn,
    requiredFeatures: dn,
    requiredFonts: dn,
    requiredFormats: dn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: me,
    specularExponent: me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: me,
    strikethroughThickness: me,
    string: null,
    stroke: null,
    strokeDashArray: dn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: me,
    strokeOpacity: me,
    strokeWidth: null,
    style: null,
    surfaceScale: me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: dn,
    tabIndex: me,
    tableValues: null,
    target: null,
    targetX: me,
    targetY: me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: dn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: me,
    underlineThickness: me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: me,
    values: null,
    vAlphabetic: me,
    vMathematical: me,
    vectorEffect: null,
    vHanging: me,
    vIdeographic: me,
    version: null,
    vertAdvY: me,
    vertOriginX: me,
    vertOriginY: me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: o1
}), u1 = Si({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), c1 = Si({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: l1
}), d1 = Si({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), OI = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, xI = /[A-Z]/g, i_ = /-[a-z]/g, LI = /^data[-\w.:]+$/i;
function cu(e, t) {
  const a = Vs(t);
  let i = t, o = tn;
  if (a in e.normal)
    return e.property[e.normal[a]];
  if (a.length > 4 && a.slice(0, 4) === "data" && LI.test(t)) {
    if (t.charAt(4) === "-") {
      const l = t.slice(5).replace(i_, MI);
      i = "data" + l.charAt(0).toUpperCase() + l.slice(1);
    } else {
      const l = t.slice(4);
      if (!i_.test(l)) {
        let c = l.replace(xI, DI);
        c.charAt(0) !== "-" && (c = "-" + c), t = "data" + c;
      }
    }
    o = yf;
  }
  return new o(i, t);
}
function DI(e) {
  return "-" + e.toLowerCase();
}
function MI(e) {
  return e.charAt(1).toUpperCase();
}
const ro = i1([s1, kI, u1, c1, d1], "html"), qa = i1([s1, II, u1, c1, d1], "svg");
function s_(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function p1(e) {
  return e.join(" ").trim();
}
var di = {}, sp, o_;
function UI() {
  if (o_) return sp;
  o_ = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, a = /^\s*/, i = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, l = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, c = /^[;\s]*/, d = /^\s+|\s+$/g, m = `
`, f = "/", b = "*", E = "", T = "comment", S = "declaration";
  function _(R, C) {
    if (typeof R != "string")
      throw new TypeError("First argument must be a string");
    if (!R) return [];
    C = C || {};
    var L = 1, x = 1;
    function Y(de) {
      var ce = de.match(t);
      ce && (L += ce.length);
      var j = de.lastIndexOf(m);
      x = ~j ? de.length - j : x + de.length;
    }
    function q() {
      var de = { line: L, column: x };
      return function(ce) {
        return ce.position = new D(de), Q(), ce;
      };
    }
    function D(de) {
      this.start = de, this.end = { line: L, column: x }, this.source = C.source;
    }
    D.prototype.content = R;
    function G(de) {
      var ce = new Error(
        C.source + ":" + L + ":" + x + ": " + de
      );
      if (ce.reason = de, ce.filename = C.source, ce.line = L, ce.column = x, ce.source = R, !C.silent) throw ce;
    }
    function K(de) {
      var ce = de.exec(R);
      if (ce) {
        var j = ce[0];
        return Y(j), R = R.slice(j.length), ce;
      }
    }
    function Q() {
      K(a);
    }
    function U(de) {
      var ce;
      for (de = de || []; ce = ee(); )
        ce !== !1 && de.push(ce);
      return de;
    }
    function ee() {
      var de = q();
      if (!(f != R.charAt(0) || b != R.charAt(1))) {
        for (var ce = 2; E != R.charAt(ce) && (b != R.charAt(ce) || f != R.charAt(ce + 1)); )
          ++ce;
        if (ce += 2, E === R.charAt(ce - 1))
          return G("End of comment missing");
        var j = R.slice(2, ce - 2);
        return x += 2, Y(j), R = R.slice(ce), x += 2, de({
          type: T,
          comment: j
        });
      }
    }
    function ae() {
      var de = q(), ce = K(i);
      if (ce) {
        if (ee(), !K(o)) return G("property missing ':'");
        var j = K(l), se = de({
          type: S,
          property: k(ce[0].replace(e, E)),
          value: j ? k(j[0].replace(e, E)) : E
        });
        return K(c), se;
      }
    }
    function ue() {
      var de = [];
      U(de);
      for (var ce; ce = ae(); )
        ce !== !1 && (de.push(ce), U(de));
      return de;
    }
    return Q(), ue();
  }
  function k(R) {
    return R ? R.replace(d, E) : E;
  }
  return sp = _, sp;
}
var l_;
function BI() {
  if (l_) return di;
  l_ = 1;
  var e = di && di.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(di, "__esModule", { value: !0 }), di.default = a;
  const t = e(UI());
  function a(i, o) {
    let l = null;
    if (!i || typeof i != "string")
      return l;
    const c = (0, t.default)(i), d = typeof o == "function";
    return c.forEach((m) => {
      if (m.type !== "declaration")
        return;
      const { property: f, value: b } = m;
      d ? o(f, b, m) : b && (l = l || {}, l[f] = b);
    }), l;
  }
  return di;
}
var ws = {}, u_;
function FI() {
  if (u_) return ws;
  u_ = 1, Object.defineProperty(ws, "__esModule", { value: !0 }), ws.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, a = /^[^-]+$/, i = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, l = function(f) {
    return !f || a.test(f) || e.test(f);
  }, c = function(f, b) {
    return b.toUpperCase();
  }, d = function(f, b) {
    return "".concat(b, "-");
  }, m = function(f, b) {
    return b === void 0 && (b = {}), l(f) ? f : (f = f.toLowerCase(), b.reactCompat ? f = f.replace(o, d) : f = f.replace(i, d), f.replace(t, c));
  };
  return ws.camelCase = m, ws;
}
var ks, c_;
function PI() {
  if (c_) return ks;
  c_ = 1;
  var e = ks && ks.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, t = e(BI()), a = FI();
  function i(o, l) {
    var c = {};
    return !o || typeof o != "string" || (0, t.default)(o, function(d, m) {
      d && m && (c[(0, a.camelCase)(d, l)] = m);
    }), c;
  }
  return i.default = i, ks = i, ks;
}
var HI = PI();
const zI = /* @__PURE__ */ iu(HI), du = f1("end"), zn = f1("start");
function f1(e) {
  return t;
  function t(a) {
    const i = a && a.position && a.position[e] || {};
    if (typeof i.line == "number" && i.line > 0 && typeof i.column == "number" && i.column > 0)
      return {
        line: i.line,
        column: i.column,
        offset: typeof i.offset == "number" && i.offset > -1 ? i.offset : void 0
      };
  }
}
function m1(e) {
  const t = zn(e), a = du(e);
  if (t && a)
    return { start: t, end: a };
}
function Bs(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? d_(e.position) : "start" in e || "end" in e ? d_(e) : "line" in e || "column" in e ? $p(e) : "";
}
function $p(e) {
  return p_(e && e.line) + ":" + p_(e && e.column);
}
function d_(e) {
  return $p(e && e.start) + "-" + $p(e && e.end);
}
function p_(e) {
  return e && typeof e == "number" ? e : 1;
}
class Mt extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, a, i) {
    super(), typeof a == "string" && (i = a, a = void 0);
    let o = "", l = {}, c = !1;
    if (a && ("line" in a && "column" in a ? l = { place: a } : "start" in a && "end" in a ? l = { place: a } : "type" in a ? l = {
      ancestors: [a],
      place: a.position
    } : l = { ...a }), typeof t == "string" ? o = t : !l.cause && t && (c = !0, o = t.message, l.cause = t), !l.ruleId && !l.source && typeof i == "string") {
      const m = i.indexOf(":");
      m === -1 ? l.ruleId = i : (l.source = i.slice(0, m), l.ruleId = i.slice(m + 1));
    }
    if (!l.place && l.ancestors && l.ancestors) {
      const m = l.ancestors[l.ancestors.length - 1];
      m && (l.place = m.position);
    }
    const d = l.place && "start" in l.place ? l.place.start : l.place;
    this.ancestors = l.ancestors || void 0, this.cause = l.cause || void 0, this.column = d ? d.column : void 0, this.fatal = void 0, this.file = "", this.message = o, this.line = d ? d.line : void 0, this.name = Bs(l.place) || "1:1", this.place = l.place || void 0, this.reason = this.message, this.ruleId = l.ruleId || void 0, this.source = l.source || void 0, this.stack = c && l.cause && typeof l.cause.stack == "string" ? l.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Mt.prototype.file = "";
Mt.prototype.name = "";
Mt.prototype.reason = "";
Mt.prototype.message = "";
Mt.prototype.stack = "";
Mt.prototype.column = void 0;
Mt.prototype.line = void 0;
Mt.prototype.ancestors = void 0;
Mt.prototype.cause = void 0;
Mt.prototype.fatal = void 0;
Mt.prototype.place = void 0;
Mt.prototype.ruleId = void 0;
Mt.prototype.source = void 0;
const Tf = {}.hasOwnProperty, GI = /* @__PURE__ */ new Map(), jI = /[A-Z]/g, $I = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), qI = /* @__PURE__ */ new Set(["td", "th"]), g1 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function YI(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const a = t.filePath || void 0;
  let i;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    i = eO(a, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    i = JI(a, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: i,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: a,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? qa : ro,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, l = h1(o, e, void 0);
  return l && typeof l != "string" ? l : o.create(
    e,
    o.Fragment,
    { children: l || void 0 },
    void 0
  );
}
function h1(e, t, a) {
  if (t.type === "element")
    return VI(e, t, a);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return WI(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return KI(e, t, a);
  if (t.type === "mdxjsEsm")
    return XI(e, t);
  if (t.type === "root")
    return ZI(e, t, a);
  if (t.type === "text")
    return QI(e, t);
}
function VI(e, t, a) {
  const i = e.schema;
  let o = i;
  t.tagName.toLowerCase() === "svg" && i.space === "html" && (o = qa, e.schema = o), e.ancestors.push(t);
  const l = E1(e, t.tagName, !1), c = tO(e, t);
  let d = _f(e, t);
  return $I.has(t.tagName) && (d = d.filter(function(m) {
    return typeof m == "string" ? !CI(m) : !0;
  })), b1(e, c, l, t), Sf(c, d), e.ancestors.pop(), e.schema = i, e.create(t, l, c, a);
}
function WI(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const i = t.data.estree.body[0];
    return i.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(i.expression);
  }
  Ws(e, t.position);
}
function XI(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Ws(e, t.position);
}
function KI(e, t, a) {
  const i = e.schema;
  let o = i;
  t.name === "svg" && i.space === "html" && (o = qa, e.schema = o), e.ancestors.push(t);
  const l = t.name === null ? e.Fragment : E1(e, t.name, !0), c = nO(e, t), d = _f(e, t);
  return b1(e, c, l, t), Sf(c, d), e.ancestors.pop(), e.schema = i, e.create(t, l, c, a);
}
function ZI(e, t, a) {
  const i = {};
  return Sf(i, _f(e, t)), e.create(t, e.Fragment, i, a);
}
function QI(e, t) {
  return t.value;
}
function b1(e, t, a, i) {
  typeof a != "string" && a !== e.Fragment && e.passNode && (t.node = i);
}
function Sf(e, t) {
  if (t.length > 0) {
    const a = t.length > 1 ? t : t[0];
    a && (e.children = a);
  }
}
function JI(e, t, a) {
  return i;
  function i(o, l, c, d) {
    const f = Array.isArray(c.children) ? a : t;
    return d ? f(l, c, d) : f(l, c);
  }
}
function eO(e, t) {
  return a;
  function a(i, o, l, c) {
    const d = Array.isArray(l.children), m = zn(i);
    return t(
      o,
      l,
      c,
      d,
      {
        columnNumber: m ? m.column - 1 : void 0,
        fileName: e,
        lineNumber: m ? m.line : void 0
      },
      void 0
    );
  }
}
function tO(e, t) {
  const a = {};
  let i, o;
  for (o in t.properties)
    if (o !== "children" && Tf.call(t.properties, o)) {
      const l = aO(e, o, t.properties[o]);
      if (l) {
        const [c, d] = l;
        e.tableCellAlignToStyle && c === "align" && typeof d == "string" && qI.has(t.tagName) ? i = d : a[c] = d;
      }
    }
  if (i) {
    const l = (
      /** @type {Style} */
      a.style || (a.style = {})
    );
    l[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = i;
  }
  return a;
}
function nO(e, t) {
  const a = {};
  for (const i of t.attributes)
    if (i.type === "mdxJsxExpressionAttribute")
      if (i.data && i.data.estree && e.evaluater) {
        const l = i.data.estree.body[0];
        l.type;
        const c = l.expression;
        c.type;
        const d = c.properties[0];
        d.type, Object.assign(
          a,
          e.evaluater.evaluateExpression(d.argument)
        );
      } else
        Ws(e, t.position);
    else {
      const o = i.name;
      let l;
      if (i.value && typeof i.value == "object")
        if (i.value.data && i.value.data.estree && e.evaluater) {
          const d = i.value.data.estree.body[0];
          d.type, l = e.evaluater.evaluateExpression(d.expression);
        } else
          Ws(e, t.position);
      else
        l = i.value === null ? !0 : i.value;
      a[o] = /** @type {Props[keyof Props]} */
      l;
    }
  return a;
}
function _f(e, t) {
  const a = [];
  let i = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : GI;
  for (; ++i < t.children.length; ) {
    const l = t.children[i];
    let c;
    if (e.passKeys) {
      const m = l.type === "element" ? l.tagName : l.type === "mdxJsxFlowElement" || l.type === "mdxJsxTextElement" ? l.name : void 0;
      if (m) {
        const f = o.get(m) || 0;
        c = m + "-" + f, o.set(m, f + 1);
      }
    }
    const d = h1(e, l, c);
    d !== void 0 && a.push(d);
  }
  return a;
}
function aO(e, t, a) {
  const i = cu(e.schema, t);
  if (!(a == null || typeof a == "number" && Number.isNaN(a))) {
    if (Array.isArray(a) && (a = i.commaSeparated ? r1(a) : p1(a)), i.property === "style") {
      let o = typeof a == "object" ? a : rO(e, String(a));
      return e.stylePropertyNameCase === "css" && (o = iO(o)), ["style", o];
    }
    return [
      e.elementAttributeNameCase === "react" && i.space ? OI[i.property] || i.property : i.attribute,
      a
    ];
  }
}
function rO(e, t) {
  try {
    return zI(t, { reactCompat: !0 });
  } catch (a) {
    if (e.ignoreInvalidStyle)
      return {};
    const i = (
      /** @type {Error} */
      a
    ), o = new Mt("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: i,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = e.filePath || void 0, o.url = g1 + "#cannot-parse-style-attribute", o;
  }
}
function E1(e, t, a) {
  let i;
  if (!a)
    i = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const o = t.split(".");
    let l = -1, c;
    for (; ++l < o.length; ) {
      const d = n_(o[l]) ? { type: "Identifier", name: o[l] } : { type: "Literal", value: o[l] };
      c = c ? {
        type: "MemberExpression",
        object: c,
        property: d,
        computed: !!(l && d.type === "Literal"),
        optional: !1
      } : d;
    }
    i = c;
  } else
    i = n_(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (i.type === "Literal") {
    const o = (
      /** @type {string | number} */
      i.value
    );
    return Tf.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(i);
  Ws(e);
}
function Ws(e, t) {
  const a = new Mt(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw a.file = e.filePath || void 0, a.url = g1 + "#cannot-handle-mdx-estrees-without-createevaluater", a;
}
function iO(e) {
  const t = {};
  let a;
  for (a in e)
    Tf.call(e, a) && (t[sO(a)] = e[a]);
  return t;
}
function sO(e) {
  let t = e.replace(jI, oO);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function oO(e) {
  return "-" + e.toLowerCase();
}
const op = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, lO = {};
function Af(e, t) {
  const a = lO, i = typeof a.includeImageAlt == "boolean" ? a.includeImageAlt : !0, o = typeof a.includeHtml == "boolean" ? a.includeHtml : !0;
  return y1(e, i, o);
}
function y1(e, t, a) {
  if (uO(e)) {
    if ("value" in e)
      return e.type === "html" && !a ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return f_(e.children, t, a);
  }
  return Array.isArray(e) ? f_(e, t, a) : "";
}
function f_(e, t, a) {
  const i = [];
  let o = -1;
  for (; ++o < e.length; )
    i[o] = y1(e[o], t, a);
  return i.join("");
}
function uO(e) {
  return !!(e && typeof e == "object");
}
const m_ = document.createElement("i");
function Xs(e) {
  const t = "&" + e + ";";
  m_.innerHTML = t;
  const a = m_.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    a.charCodeAt(a.length - 1) === 59 && e !== "semi" || a === t ? !1 : a
  );
}
function pn(e, t, a, i) {
  const o = e.length;
  let l = 0, c;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, a = a > 0 ? a : 0, i.length < 1e4)
    c = Array.from(i), c.unshift(t, a), e.splice(...c);
  else
    for (a && e.splice(t, a); l < i.length; )
      c = i.slice(l, l + 1e4), c.unshift(t, 0), e.splice(...c), l += 1e4, t += 1e4;
}
function An(e, t) {
  return e.length > 0 ? (pn(e, e.length, 0, t), e) : t;
}
const g_ = {}.hasOwnProperty;
function T1(e) {
  const t = {};
  let a = -1;
  for (; ++a < e.length; )
    cO(t, e[a]);
  return t;
}
function cO(e, t) {
  let a;
  for (a in t) {
    const o = (g_.call(e, a) ? e[a] : void 0) || (e[a] = {}), l = t[a];
    let c;
    if (l)
      for (c in l) {
        g_.call(o, c) || (o[c] = []);
        const d = l[c];
        dO(
          // @ts-expect-error Looks like a list.
          o[c],
          Array.isArray(d) ? d : d ? [d] : []
        );
      }
  }
}
function dO(e, t) {
  let a = -1;
  const i = [];
  for (; ++a < t.length; )
    (t[a].add === "after" ? e : i).push(t[a]);
  pn(e, 0, 0, i);
}
function S1(e, t) {
  const a = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    a < 9 || a === 11 || a > 13 && a < 32 || // Control character (DEL) of C0, and C1 controls.
    a > 126 && a < 160 || // Lone high surrogates and low surrogates.
    a > 55295 && a < 57344 || // Noncharacters.
    a > 64975 && a < 65008 || /* eslint-disable no-bitwise */
    (a & 65535) === 65535 || (a & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    a > 1114111 ? "" : String.fromCodePoint(a)
  );
}
function On(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Gt = Ya(/[A-Za-z]/), Dt = Ya(/[\dA-Za-z]/), pO = Ya(/[#-'*+\--9=?A-Z^-~]/);
function Jl(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const qp = Ya(/\d/), fO = Ya(/[\dA-Fa-f]/), mO = Ya(/[!-/:-@[-`{-~]/);
function ve(e) {
  return e !== null && e < -2;
}
function at(e) {
  return e !== null && (e < 0 || e === 32);
}
function Fe(e) {
  return e === -2 || e === -1 || e === 32;
}
const pu = Ya(new RegExp("\\p{P}|\\p{S}", "u")), gr = Ya(/\s/);
function Ya(e) {
  return t;
  function t(a) {
    return a !== null && a > -1 && e.test(String.fromCharCode(a));
  }
}
function _i(e) {
  const t = [];
  let a = -1, i = 0, o = 0;
  for (; ++a < e.length; ) {
    const l = e.charCodeAt(a);
    let c = "";
    if (l === 37 && Dt(e.charCodeAt(a + 1)) && Dt(e.charCodeAt(a + 2)))
      o = 2;
    else if (l < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(l)) || (c = String.fromCharCode(l));
    else if (l > 55295 && l < 57344) {
      const d = e.charCodeAt(a + 1);
      l < 56320 && d > 56319 && d < 57344 ? (c = String.fromCharCode(l, d), o = 1) : c = "";
    } else
      c = String.fromCharCode(l);
    c && (t.push(e.slice(i, a), encodeURIComponent(c)), i = a + o + 1, c = ""), o && (a += o, o = 0);
  }
  return t.join("") + e.slice(i);
}
function je(e, t, a, i) {
  const o = i ? i - 1 : Number.POSITIVE_INFINITY;
  let l = 0;
  return c;
  function c(m) {
    return Fe(m) ? (e.enter(a), d(m)) : t(m);
  }
  function d(m) {
    return Fe(m) && l++ < o ? (e.consume(m), d) : (e.exit(a), t(m));
  }
}
const gO = {
  tokenize: hO
};
function hO(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, i, o);
  let a;
  return t;
  function i(d) {
    if (d === null) {
      e.consume(d);
      return;
    }
    return e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), je(e, t, "linePrefix");
  }
  function o(d) {
    return e.enter("paragraph"), l(d);
  }
  function l(d) {
    const m = e.enter("chunkText", {
      contentType: "text",
      previous: a
    });
    return a && (a.next = m), a = m, c(d);
  }
  function c(d) {
    if (d === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(d);
      return;
    }
    return ve(d) ? (e.consume(d), e.exit("chunkText"), l) : (e.consume(d), c);
  }
}
const bO = {
  tokenize: EO
}, h_ = {
  tokenize: yO
};
function EO(e) {
  const t = this, a = [];
  let i = 0, o, l, c;
  return d;
  function d(x) {
    if (i < a.length) {
      const Y = a[i];
      return t.containerState = Y[1], e.attempt(Y[0].continuation, m, f)(x);
    }
    return f(x);
  }
  function m(x) {
    if (i++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && L();
      const Y = t.events.length;
      let q = Y, D;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          D = t.events[q][1].end;
          break;
        }
      C(i);
      let G = Y;
      for (; G < t.events.length; )
        t.events[G][1].end = {
          ...D
        }, G++;
      return pn(t.events, q + 1, 0, t.events.slice(Y)), t.events.length = G, f(x);
    }
    return d(x);
  }
  function f(x) {
    if (i === a.length) {
      if (!o)
        return T(x);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return _(x);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(h_, b, E)(x);
  }
  function b(x) {
    return o && L(), C(i), T(x);
  }
  function E(x) {
    return t.parser.lazy[t.now().line] = i !== a.length, c = t.now().offset, _(x);
  }
  function T(x) {
    return t.containerState = {}, e.attempt(h_, S, _)(x);
  }
  function S(x) {
    return i++, a.push([t.currentConstruct, t.containerState]), T(x);
  }
  function _(x) {
    if (x === null) {
      o && L(), C(0), e.consume(x);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: l
    }), k(x);
  }
  function k(x) {
    if (x === null) {
      R(e.exit("chunkFlow"), !0), C(0), e.consume(x);
      return;
    }
    return ve(x) ? (e.consume(x), R(e.exit("chunkFlow")), i = 0, t.interrupt = void 0, d) : (e.consume(x), k);
  }
  function R(x, Y) {
    const q = t.sliceStream(x);
    if (Y && q.push(null), x.previous = l, l && (l.next = x), l = x, o.defineSkip(x.start), o.write(q), t.parser.lazy[x.start.line]) {
      let D = o.events.length;
      for (; D--; )
        if (
          // The token starts before the line ending
          o.events[D][1].start.offset < c && // and either is not ended yet
          (!o.events[D][1].end || // or ends after it.
          o.events[D][1].end.offset > c)
        )
          return;
      const G = t.events.length;
      let K = G, Q, U;
      for (; K--; )
        if (t.events[K][0] === "exit" && t.events[K][1].type === "chunkFlow") {
          if (Q) {
            U = t.events[K][1].end;
            break;
          }
          Q = !0;
        }
      for (C(i), D = G; D < t.events.length; )
        t.events[D][1].end = {
          ...U
        }, D++;
      pn(t.events, K + 1, 0, t.events.slice(G)), t.events.length = D;
    }
  }
  function C(x) {
    let Y = a.length;
    for (; Y-- > x; ) {
      const q = a[Y];
      t.containerState = q[1], q[0].exit.call(t, e);
    }
    a.length = x;
  }
  function L() {
    o.write([null]), l = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function yO(e, t, a) {
  return je(e, e.attempt(this.parser.constructs.document, t, a), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function bi(e) {
  if (e === null || at(e) || gr(e))
    return 1;
  if (pu(e))
    return 2;
}
function fu(e, t, a) {
  const i = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const l = e[o].resolveAll;
    l && !i.includes(l) && (t = l(t, a), i.push(l));
  }
  return t;
}
const Yp = {
  name: "attention",
  resolveAll: TO,
  tokenize: SO
};
function TO(e, t) {
  let a = -1, i, o, l, c, d, m, f, b;
  for (; ++a < e.length; )
    if (e[a][0] === "enter" && e[a][1].type === "attentionSequence" && e[a][1]._close) {
      for (i = a; i--; )
        if (e[i][0] === "exit" && e[i][1].type === "attentionSequence" && e[i][1]._open && // If the markers are the same:
        t.sliceSerialize(e[i][1]).charCodeAt(0) === t.sliceSerialize(e[a][1]).charCodeAt(0)) {
          if ((e[i][1]._close || e[a][1]._open) && (e[a][1].end.offset - e[a][1].start.offset) % 3 && !((e[i][1].end.offset - e[i][1].start.offset + e[a][1].end.offset - e[a][1].start.offset) % 3))
            continue;
          m = e[i][1].end.offset - e[i][1].start.offset > 1 && e[a][1].end.offset - e[a][1].start.offset > 1 ? 2 : 1;
          const E = {
            ...e[i][1].end
          }, T = {
            ...e[a][1].start
          };
          b_(E, -m), b_(T, m), c = {
            type: m > 1 ? "strongSequence" : "emphasisSequence",
            start: E,
            end: {
              ...e[i][1].end
            }
          }, d = {
            type: m > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[a][1].start
            },
            end: T
          }, l = {
            type: m > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[i][1].end
            },
            end: {
              ...e[a][1].start
            }
          }, o = {
            type: m > 1 ? "strong" : "emphasis",
            start: {
              ...c.start
            },
            end: {
              ...d.end
            }
          }, e[i][1].end = {
            ...c.start
          }, e[a][1].start = {
            ...d.end
          }, f = [], e[i][1].end.offset - e[i][1].start.offset && (f = An(f, [["enter", e[i][1], t], ["exit", e[i][1], t]])), f = An(f, [["enter", o, t], ["enter", c, t], ["exit", c, t], ["enter", l, t]]), f = An(f, fu(t.parser.constructs.insideSpan.null, e.slice(i + 1, a), t)), f = An(f, [["exit", l, t], ["enter", d, t], ["exit", d, t], ["exit", o, t]]), e[a][1].end.offset - e[a][1].start.offset ? (b = 2, f = An(f, [["enter", e[a][1], t], ["exit", e[a][1], t]])) : b = 0, pn(e, i - 1, a - i + 3, f), a = i + f.length - b - 2;
          break;
        }
    }
  for (a = -1; ++a < e.length; )
    e[a][1].type === "attentionSequence" && (e[a][1].type = "data");
  return e;
}
function SO(e, t) {
  const a = this.parser.constructs.attentionMarkers.null, i = this.previous, o = bi(i);
  let l;
  return c;
  function c(m) {
    return l = m, e.enter("attentionSequence"), d(m);
  }
  function d(m) {
    if (m === l)
      return e.consume(m), d;
    const f = e.exit("attentionSequence"), b = bi(m), E = !b || b === 2 && o || a.includes(m), T = !o || o === 2 && b || a.includes(i);
    return f._open = !!(l === 42 ? E : E && (o || !T)), f._close = !!(l === 42 ? T : T && (b || !E)), t(m);
  }
}
function b_(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const _O = {
  name: "autolink",
  tokenize: AO
};
function AO(e, t, a) {
  let i = 0;
  return o;
  function o(S) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(S), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), l;
  }
  function l(S) {
    return Gt(S) ? (e.consume(S), c) : S === 64 ? a(S) : f(S);
  }
  function c(S) {
    return S === 43 || S === 45 || S === 46 || Dt(S) ? (i = 1, d(S)) : f(S);
  }
  function d(S) {
    return S === 58 ? (e.consume(S), i = 0, m) : (S === 43 || S === 45 || S === 46 || Dt(S)) && i++ < 32 ? (e.consume(S), d) : (i = 0, f(S));
  }
  function m(S) {
    return S === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(S), e.exit("autolinkMarker"), e.exit("autolink"), t) : S === null || S === 32 || S === 60 || Jl(S) ? a(S) : (e.consume(S), m);
  }
  function f(S) {
    return S === 64 ? (e.consume(S), b) : pO(S) ? (e.consume(S), f) : a(S);
  }
  function b(S) {
    return Dt(S) ? E(S) : a(S);
  }
  function E(S) {
    return S === 46 ? (e.consume(S), i = 0, b) : S === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(S), e.exit("autolinkMarker"), e.exit("autolink"), t) : T(S);
  }
  function T(S) {
    if ((S === 45 || Dt(S)) && i++ < 63) {
      const _ = S === 45 ? T : E;
      return e.consume(S), _;
    }
    return a(S);
  }
}
const io = {
  partial: !0,
  tokenize: NO
};
function NO(e, t, a) {
  return i;
  function i(l) {
    return Fe(l) ? je(e, o, "linePrefix")(l) : o(l);
  }
  function o(l) {
    return l === null || ve(l) ? t(l) : a(l);
  }
}
const _1 = {
  continuation: {
    tokenize: vO
  },
  exit: CO,
  name: "blockQuote",
  tokenize: RO
};
function RO(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    if (c === 62) {
      const d = i.containerState;
      return d.open || (e.enter("blockQuote", {
        _container: !0
      }), d.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(c), e.exit("blockQuoteMarker"), l;
    }
    return a(c);
  }
  function l(c) {
    return Fe(c) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(c), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(c));
  }
}
function vO(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return Fe(c) ? je(e, l, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c) : l(c);
  }
  function l(c) {
    return e.attempt(_1, t, a)(c);
  }
}
function CO(e) {
  e.exit("blockQuote");
}
const A1 = {
  name: "characterEscape",
  tokenize: wO
};
function wO(e, t, a) {
  return i;
  function i(l) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(l), e.exit("escapeMarker"), o;
  }
  function o(l) {
    return mO(l) ? (e.enter("characterEscapeValue"), e.consume(l), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : a(l);
  }
}
const N1 = {
  name: "characterReference",
  tokenize: kO
};
function kO(e, t, a) {
  const i = this;
  let o = 0, l, c;
  return d;
  function d(E) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(E), e.exit("characterReferenceMarker"), m;
  }
  function m(E) {
    return E === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(E), e.exit("characterReferenceMarkerNumeric"), f) : (e.enter("characterReferenceValue"), l = 31, c = Dt, b(E));
  }
  function f(E) {
    return E === 88 || E === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(E), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), l = 6, c = fO, b) : (e.enter("characterReferenceValue"), l = 7, c = qp, b(E));
  }
  function b(E) {
    if (E === 59 && o) {
      const T = e.exit("characterReferenceValue");
      return c === Dt && !Xs(i.sliceSerialize(T)) ? a(E) : (e.enter("characterReferenceMarker"), e.consume(E), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return c(E) && o++ < l ? (e.consume(E), b) : a(E);
  }
}
const E_ = {
  partial: !0,
  tokenize: OO
}, y_ = {
  concrete: !0,
  name: "codeFenced",
  tokenize: IO
};
function IO(e, t, a) {
  const i = this, o = {
    partial: !0,
    tokenize: q
  };
  let l = 0, c = 0, d;
  return m;
  function m(D) {
    return f(D);
  }
  function f(D) {
    const G = i.events[i.events.length - 1];
    return l = G && G[1].type === "linePrefix" ? G[2].sliceSerialize(G[1], !0).length : 0, d = D, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), b(D);
  }
  function b(D) {
    return D === d ? (c++, e.consume(D), b) : c < 3 ? a(D) : (e.exit("codeFencedFenceSequence"), Fe(D) ? je(e, E, "whitespace")(D) : E(D));
  }
  function E(D) {
    return D === null || ve(D) ? (e.exit("codeFencedFence"), i.interrupt ? t(D) : e.check(E_, k, Y)(D)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), T(D));
  }
  function T(D) {
    return D === null || ve(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), E(D)) : Fe(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), je(e, S, "whitespace")(D)) : D === 96 && D === d ? a(D) : (e.consume(D), T);
  }
  function S(D) {
    return D === null || ve(D) ? E(D) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), _(D));
  }
  function _(D) {
    return D === null || ve(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), E(D)) : D === 96 && D === d ? a(D) : (e.consume(D), _);
  }
  function k(D) {
    return e.attempt(o, Y, R)(D);
  }
  function R(D) {
    return e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), C;
  }
  function C(D) {
    return l > 0 && Fe(D) ? je(e, L, "linePrefix", l + 1)(D) : L(D);
  }
  function L(D) {
    return D === null || ve(D) ? e.check(E_, k, Y)(D) : (e.enter("codeFlowValue"), x(D));
  }
  function x(D) {
    return D === null || ve(D) ? (e.exit("codeFlowValue"), L(D)) : (e.consume(D), x);
  }
  function Y(D) {
    return e.exit("codeFenced"), t(D);
  }
  function q(D, G, K) {
    let Q = 0;
    return U;
    function U(ce) {
      return D.enter("lineEnding"), D.consume(ce), D.exit("lineEnding"), ee;
    }
    function ee(ce) {
      return D.enter("codeFencedFence"), Fe(ce) ? je(D, ae, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ce) : ae(ce);
    }
    function ae(ce) {
      return ce === d ? (D.enter("codeFencedFenceSequence"), ue(ce)) : K(ce);
    }
    function ue(ce) {
      return ce === d ? (Q++, D.consume(ce), ue) : Q >= c ? (D.exit("codeFencedFenceSequence"), Fe(ce) ? je(D, de, "whitespace")(ce) : de(ce)) : K(ce);
    }
    function de(ce) {
      return ce === null || ve(ce) ? (D.exit("codeFencedFence"), G(ce)) : K(ce);
    }
  }
}
function OO(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return c === null ? a(c) : (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), l);
  }
  function l(c) {
    return i.parser.lazy[i.now().line] ? a(c) : t(c);
  }
}
const lp = {
  name: "codeIndented",
  tokenize: LO
}, xO = {
  partial: !0,
  tokenize: DO
};
function LO(e, t, a) {
  const i = this;
  return o;
  function o(f) {
    return e.enter("codeIndented"), je(e, l, "linePrefix", 5)(f);
  }
  function l(f) {
    const b = i.events[i.events.length - 1];
    return b && b[1].type === "linePrefix" && b[2].sliceSerialize(b[1], !0).length >= 4 ? c(f) : a(f);
  }
  function c(f) {
    return f === null ? m(f) : ve(f) ? e.attempt(xO, c, m)(f) : (e.enter("codeFlowValue"), d(f));
  }
  function d(f) {
    return f === null || ve(f) ? (e.exit("codeFlowValue"), c(f)) : (e.consume(f), d);
  }
  function m(f) {
    return e.exit("codeIndented"), t(f);
  }
}
function DO(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return i.parser.lazy[i.now().line] ? a(c) : ve(c) ? (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), o) : je(e, l, "linePrefix", 5)(c);
  }
  function l(c) {
    const d = i.events[i.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? t(c) : ve(c) ? o(c) : a(c);
  }
}
const MO = {
  name: "codeText",
  previous: BO,
  resolve: UO,
  tokenize: FO
};
function UO(e) {
  let t = e.length - 4, a = 3, i, o;
  if ((e[a][1].type === "lineEnding" || e[a][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (i = a; ++i < t; )
      if (e[i][1].type === "codeTextData") {
        e[a][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", a += 2, t -= 2;
        break;
      }
  }
  for (i = a - 1, t++; ++i <= t; )
    o === void 0 ? i !== t && e[i][1].type !== "lineEnding" && (o = i) : (i === t || e[i][1].type === "lineEnding") && (e[o][1].type = "codeTextData", i !== o + 2 && (e[o][1].end = e[i - 1][1].end, e.splice(o + 2, i - o - 2), t -= i - o - 2, i = o + 2), o = void 0);
  return e;
}
function BO(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function FO(e, t, a) {
  let i = 0, o, l;
  return c;
  function c(E) {
    return e.enter("codeText"), e.enter("codeTextSequence"), d(E);
  }
  function d(E) {
    return E === 96 ? (e.consume(E), i++, d) : (e.exit("codeTextSequence"), m(E));
  }
  function m(E) {
    return E === null ? a(E) : E === 32 ? (e.enter("space"), e.consume(E), e.exit("space"), m) : E === 96 ? (l = e.enter("codeTextSequence"), o = 0, b(E)) : ve(E) ? (e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), m) : (e.enter("codeTextData"), f(E));
  }
  function f(E) {
    return E === null || E === 32 || E === 96 || ve(E) ? (e.exit("codeTextData"), m(E)) : (e.consume(E), f);
  }
  function b(E) {
    return E === 96 ? (e.consume(E), o++, b) : o === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(E)) : (l.type = "codeTextData", f(E));
  }
}
class PO {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, a) {
    const i = a ?? Number.POSITIVE_INFINITY;
    return i < this.left.length ? this.left.slice(t, i) : t > this.left.length ? this.right.slice(this.right.length - i + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - i + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, a, i) {
    const o = a || 0;
    this.setCursor(Math.trunc(t));
    const l = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return i && Is(this.left, i), l.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Is(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Is(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const a = this.left.splice(t, Number.POSITIVE_INFINITY);
        Is(this.right, a.reverse());
      } else {
        const a = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Is(this.left, a.reverse());
      }
  }
}
function Is(e, t) {
  let a = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; a < t.length; )
      e.push(...t.slice(a, a + 1e4)), a += 1e4;
}
function R1(e) {
  const t = {};
  let a = -1, i, o, l, c, d, m, f;
  const b = new PO(e);
  for (; ++a < b.length; ) {
    for (; a in t; )
      a = t[a];
    if (i = b.get(a), a && i[1].type === "chunkFlow" && b.get(a - 1)[1].type === "listItemPrefix" && (m = i[1]._tokenizer.events, l = 0, l < m.length && m[l][1].type === "lineEndingBlank" && (l += 2), l < m.length && m[l][1].type === "content"))
      for (; ++l < m.length && m[l][1].type !== "content"; )
        m[l][1].type === "chunkText" && (m[l][1]._isInFirstContentOfListItem = !0, l++);
    if (i[0] === "enter")
      i[1].contentType && (Object.assign(t, HO(b, a)), a = t[a], f = !0);
    else if (i[1]._container) {
      for (l = a, o = void 0; l--; )
        if (c = b.get(l), c[1].type === "lineEnding" || c[1].type === "lineEndingBlank")
          c[0] === "enter" && (o && (b.get(o)[1].type = "lineEndingBlank"), c[1].type = "lineEnding", o = l);
        else if (!(c[1].type === "linePrefix" || c[1].type === "listItemIndent")) break;
      o && (i[1].end = {
        ...b.get(o)[1].start
      }, d = b.slice(o, a), d.unshift(i), b.splice(o, a - o + 1, d));
    }
  }
  return pn(e, 0, Number.POSITIVE_INFINITY, b.slice(0)), !f;
}
function HO(e, t) {
  const a = e.get(t)[1], i = e.get(t)[2];
  let o = t - 1;
  const l = [];
  let c = a._tokenizer;
  c || (c = i.parser[a.contentType](a.start), a._contentTypeTextTrailing && (c._contentTypeTextTrailing = !0));
  const d = c.events, m = [], f = {};
  let b, E, T = -1, S = a, _ = 0, k = 0;
  const R = [k];
  for (; S; ) {
    for (; e.get(++o)[1] !== S; )
      ;
    l.push(o), S._tokenizer || (b = i.sliceStream(S), S.next || b.push(null), E && c.defineSkip(S.start), S._isInFirstContentOfListItem && (c._gfmTasklistFirstContentOfListItem = !0), c.write(b), S._isInFirstContentOfListItem && (c._gfmTasklistFirstContentOfListItem = void 0)), E = S, S = S.next;
  }
  for (S = a; ++T < d.length; )
    // Find a void token that includes a break.
    d[T][0] === "exit" && d[T - 1][0] === "enter" && d[T][1].type === d[T - 1][1].type && d[T][1].start.line !== d[T][1].end.line && (k = T + 1, R.push(k), S._tokenizer = void 0, S.previous = void 0, S = S.next);
  for (c.events = [], S ? (S._tokenizer = void 0, S.previous = void 0) : R.pop(), T = R.length; T--; ) {
    const C = d.slice(R[T], R[T + 1]), L = l.pop();
    m.push([L, L + C.length - 1]), e.splice(L, 2, C);
  }
  for (m.reverse(), T = -1; ++T < m.length; )
    f[_ + m[T][0]] = _ + m[T][1], _ += m[T][1] - m[T][0] - 1;
  return f;
}
const zO = {
  resolve: jO,
  tokenize: $O
}, GO = {
  partial: !0,
  tokenize: qO
};
function jO(e) {
  return R1(e), e;
}
function $O(e, t) {
  let a;
  return i;
  function i(d) {
    return e.enter("content"), a = e.enter("chunkContent", {
      contentType: "content"
    }), o(d);
  }
  function o(d) {
    return d === null ? l(d) : ve(d) ? e.check(GO, c, l)(d) : (e.consume(d), o);
  }
  function l(d) {
    return e.exit("chunkContent"), e.exit("content"), t(d);
  }
  function c(d) {
    return e.consume(d), e.exit("chunkContent"), a.next = e.enter("chunkContent", {
      contentType: "content",
      previous: a
    }), a = a.next, o;
  }
}
function qO(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), je(e, l, "linePrefix");
  }
  function l(c) {
    if (c === null || ve(c))
      return a(c);
    const d = i.events[i.events.length - 1];
    return !i.parser.constructs.disable.null.includes("codeIndented") && d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? t(c) : e.interrupt(i.parser.constructs.flow, a, t)(c);
  }
}
function v1(e, t, a, i, o, l, c, d, m) {
  const f = m || Number.POSITIVE_INFINITY;
  let b = 0;
  return E;
  function E(C) {
    return C === 60 ? (e.enter(i), e.enter(o), e.enter(l), e.consume(C), e.exit(l), T) : C === null || C === 32 || C === 41 || Jl(C) ? a(C) : (e.enter(i), e.enter(c), e.enter(d), e.enter("chunkString", {
      contentType: "string"
    }), k(C));
  }
  function T(C) {
    return C === 62 ? (e.enter(l), e.consume(C), e.exit(l), e.exit(o), e.exit(i), t) : (e.enter(d), e.enter("chunkString", {
      contentType: "string"
    }), S(C));
  }
  function S(C) {
    return C === 62 ? (e.exit("chunkString"), e.exit(d), T(C)) : C === null || C === 60 || ve(C) ? a(C) : (e.consume(C), C === 92 ? _ : S);
  }
  function _(C) {
    return C === 60 || C === 62 || C === 92 ? (e.consume(C), S) : S(C);
  }
  function k(C) {
    return !b && (C === null || C === 41 || at(C)) ? (e.exit("chunkString"), e.exit(d), e.exit(c), e.exit(i), t(C)) : b < f && C === 40 ? (e.consume(C), b++, k) : C === 41 ? (e.consume(C), b--, k) : C === null || C === 32 || C === 40 || Jl(C) ? a(C) : (e.consume(C), C === 92 ? R : k);
  }
  function R(C) {
    return C === 40 || C === 41 || C === 92 ? (e.consume(C), k) : k(C);
  }
}
function C1(e, t, a, i, o, l) {
  const c = this;
  let d = 0, m;
  return f;
  function f(S) {
    return e.enter(i), e.enter(o), e.consume(S), e.exit(o), e.enter(l), b;
  }
  function b(S) {
    return d > 999 || S === null || S === 91 || S === 93 && !m || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    S === 94 && !d && "_hiddenFootnoteSupport" in c.parser.constructs ? a(S) : S === 93 ? (e.exit(l), e.enter(o), e.consume(S), e.exit(o), e.exit(i), t) : ve(S) ? (e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), b) : (e.enter("chunkString", {
      contentType: "string"
    }), E(S));
  }
  function E(S) {
    return S === null || S === 91 || S === 93 || ve(S) || d++ > 999 ? (e.exit("chunkString"), b(S)) : (e.consume(S), m || (m = !Fe(S)), S === 92 ? T : E);
  }
  function T(S) {
    return S === 91 || S === 92 || S === 93 ? (e.consume(S), d++, E) : E(S);
  }
}
function w1(e, t, a, i, o, l) {
  let c;
  return d;
  function d(T) {
    return T === 34 || T === 39 || T === 40 ? (e.enter(i), e.enter(o), e.consume(T), e.exit(o), c = T === 40 ? 41 : T, m) : a(T);
  }
  function m(T) {
    return T === c ? (e.enter(o), e.consume(T), e.exit(o), e.exit(i), t) : (e.enter(l), f(T));
  }
  function f(T) {
    return T === c ? (e.exit(l), m(c)) : T === null ? a(T) : ve(T) ? (e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), je(e, f, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), b(T));
  }
  function b(T) {
    return T === c || T === null || ve(T) ? (e.exit("chunkString"), f(T)) : (e.consume(T), T === 92 ? E : b);
  }
  function E(T) {
    return T === c || T === 92 ? (e.consume(T), b) : b(T);
  }
}
function Fs(e, t) {
  let a;
  return i;
  function i(o) {
    return ve(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a = !0, i) : Fe(o) ? je(e, i, a ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const YO = {
  name: "definition",
  tokenize: WO
}, VO = {
  partial: !0,
  tokenize: XO
};
function WO(e, t, a) {
  const i = this;
  let o;
  return l;
  function l(S) {
    return e.enter("definition"), c(S);
  }
  function c(S) {
    return C1.call(
      i,
      e,
      d,
      // Note: we dont need to reset the way `markdown-rs` does.
      a,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(S);
  }
  function d(S) {
    return o = On(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1)), S === 58 ? (e.enter("definitionMarker"), e.consume(S), e.exit("definitionMarker"), m) : a(S);
  }
  function m(S) {
    return at(S) ? Fs(e, f)(S) : f(S);
  }
  function f(S) {
    return v1(
      e,
      b,
      // Note: we dont need to reset the way `markdown-rs` does.
      a,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(S);
  }
  function b(S) {
    return e.attempt(VO, E, E)(S);
  }
  function E(S) {
    return Fe(S) ? je(e, T, "whitespace")(S) : T(S);
  }
  function T(S) {
    return S === null || ve(S) ? (e.exit("definition"), i.parser.defined.push(o), t(S)) : a(S);
  }
}
function XO(e, t, a) {
  return i;
  function i(d) {
    return at(d) ? Fs(e, o)(d) : a(d);
  }
  function o(d) {
    return w1(e, l, a, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(d);
  }
  function l(d) {
    return Fe(d) ? je(e, c, "whitespace")(d) : c(d);
  }
  function c(d) {
    return d === null || ve(d) ? t(d) : a(d);
  }
}
const KO = {
  name: "hardBreakEscape",
  tokenize: ZO
};
function ZO(e, t, a) {
  return i;
  function i(l) {
    return e.enter("hardBreakEscape"), e.consume(l), o;
  }
  function o(l) {
    return ve(l) ? (e.exit("hardBreakEscape"), t(l)) : a(l);
  }
}
const QO = {
  name: "headingAtx",
  resolve: JO,
  tokenize: ex
};
function JO(e, t) {
  let a = e.length - 2, i = 3, o, l;
  return e[i][1].type === "whitespace" && (i += 2), a - 2 > i && e[a][1].type === "whitespace" && (a -= 2), e[a][1].type === "atxHeadingSequence" && (i === a - 1 || a - 4 > i && e[a - 2][1].type === "whitespace") && (a -= i + 1 === a ? 2 : 4), a > i && (o = {
    type: "atxHeadingText",
    start: e[i][1].start,
    end: e[a][1].end
  }, l = {
    type: "chunkText",
    start: e[i][1].start,
    end: e[a][1].end,
    contentType: "text"
  }, pn(e, i, a - i + 1, [["enter", o, t], ["enter", l, t], ["exit", l, t], ["exit", o, t]])), e;
}
function ex(e, t, a) {
  let i = 0;
  return o;
  function o(b) {
    return e.enter("atxHeading"), l(b);
  }
  function l(b) {
    return e.enter("atxHeadingSequence"), c(b);
  }
  function c(b) {
    return b === 35 && i++ < 6 ? (e.consume(b), c) : b === null || at(b) ? (e.exit("atxHeadingSequence"), d(b)) : a(b);
  }
  function d(b) {
    return b === 35 ? (e.enter("atxHeadingSequence"), m(b)) : b === null || ve(b) ? (e.exit("atxHeading"), t(b)) : Fe(b) ? je(e, d, "whitespace")(b) : (e.enter("atxHeadingText"), f(b));
  }
  function m(b) {
    return b === 35 ? (e.consume(b), m) : (e.exit("atxHeadingSequence"), d(b));
  }
  function f(b) {
    return b === null || b === 35 || at(b) ? (e.exit("atxHeadingText"), d(b)) : (e.consume(b), f);
  }
}
const tx = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], T_ = ["pre", "script", "style", "textarea"], nx = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: ix,
  tokenize: sx
}, ax = {
  partial: !0,
  tokenize: lx
}, rx = {
  partial: !0,
  tokenize: ox
};
function ix(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function sx(e, t, a) {
  const i = this;
  let o, l, c, d, m;
  return f;
  function f(v) {
    return b(v);
  }
  function b(v) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(v), E;
  }
  function E(v) {
    return v === 33 ? (e.consume(v), T) : v === 47 ? (e.consume(v), l = !0, k) : v === 63 ? (e.consume(v), o = 3, i.interrupt ? t : O) : Gt(v) ? (e.consume(v), c = String.fromCharCode(v), R) : a(v);
  }
  function T(v) {
    return v === 45 ? (e.consume(v), o = 2, S) : v === 91 ? (e.consume(v), o = 5, d = 0, _) : Gt(v) ? (e.consume(v), o = 4, i.interrupt ? t : O) : a(v);
  }
  function S(v) {
    return v === 45 ? (e.consume(v), i.interrupt ? t : O) : a(v);
  }
  function _(v) {
    const he = "CDATA[";
    return v === he.charCodeAt(d++) ? (e.consume(v), d === he.length ? i.interrupt ? t : ae : _) : a(v);
  }
  function k(v) {
    return Gt(v) ? (e.consume(v), c = String.fromCharCode(v), R) : a(v);
  }
  function R(v) {
    if (v === null || v === 47 || v === 62 || at(v)) {
      const he = v === 47, ye = c.toLowerCase();
      return !he && !l && T_.includes(ye) ? (o = 1, i.interrupt ? t(v) : ae(v)) : tx.includes(c.toLowerCase()) ? (o = 6, he ? (e.consume(v), C) : i.interrupt ? t(v) : ae(v)) : (o = 7, i.interrupt && !i.parser.lazy[i.now().line] ? a(v) : l ? L(v) : x(v));
    }
    return v === 45 || Dt(v) ? (e.consume(v), c += String.fromCharCode(v), R) : a(v);
  }
  function C(v) {
    return v === 62 ? (e.consume(v), i.interrupt ? t : ae) : a(v);
  }
  function L(v) {
    return Fe(v) ? (e.consume(v), L) : U(v);
  }
  function x(v) {
    return v === 47 ? (e.consume(v), U) : v === 58 || v === 95 || Gt(v) ? (e.consume(v), Y) : Fe(v) ? (e.consume(v), x) : U(v);
  }
  function Y(v) {
    return v === 45 || v === 46 || v === 58 || v === 95 || Dt(v) ? (e.consume(v), Y) : q(v);
  }
  function q(v) {
    return v === 61 ? (e.consume(v), D) : Fe(v) ? (e.consume(v), q) : x(v);
  }
  function D(v) {
    return v === null || v === 60 || v === 61 || v === 62 || v === 96 ? a(v) : v === 34 || v === 39 ? (e.consume(v), m = v, G) : Fe(v) ? (e.consume(v), D) : K(v);
  }
  function G(v) {
    return v === m ? (e.consume(v), m = null, Q) : v === null || ve(v) ? a(v) : (e.consume(v), G);
  }
  function K(v) {
    return v === null || v === 34 || v === 39 || v === 47 || v === 60 || v === 61 || v === 62 || v === 96 || at(v) ? q(v) : (e.consume(v), K);
  }
  function Q(v) {
    return v === 47 || v === 62 || Fe(v) ? x(v) : a(v);
  }
  function U(v) {
    return v === 62 ? (e.consume(v), ee) : a(v);
  }
  function ee(v) {
    return v === null || ve(v) ? ae(v) : Fe(v) ? (e.consume(v), ee) : a(v);
  }
  function ae(v) {
    return v === 45 && o === 2 ? (e.consume(v), j) : v === 60 && o === 1 ? (e.consume(v), se) : v === 62 && o === 4 ? (e.consume(v), F) : v === 63 && o === 3 ? (e.consume(v), O) : v === 93 && o === 5 ? (e.consume(v), Ne) : ve(v) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(ax, te, ue)(v)) : v === null || ve(v) ? (e.exit("htmlFlowData"), ue(v)) : (e.consume(v), ae);
  }
  function ue(v) {
    return e.check(rx, de, te)(v);
  }
  function de(v) {
    return e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), ce;
  }
  function ce(v) {
    return v === null || ve(v) ? ue(v) : (e.enter("htmlFlowData"), ae(v));
  }
  function j(v) {
    return v === 45 ? (e.consume(v), O) : ae(v);
  }
  function se(v) {
    return v === 47 ? (e.consume(v), c = "", Ee) : ae(v);
  }
  function Ee(v) {
    if (v === 62) {
      const he = c.toLowerCase();
      return T_.includes(he) ? (e.consume(v), F) : ae(v);
    }
    return Gt(v) && c.length < 8 ? (e.consume(v), c += String.fromCharCode(v), Ee) : ae(v);
  }
  function Ne(v) {
    return v === 93 ? (e.consume(v), O) : ae(v);
  }
  function O(v) {
    return v === 62 ? (e.consume(v), F) : v === 45 && o === 2 ? (e.consume(v), O) : ae(v);
  }
  function F(v) {
    return v === null || ve(v) ? (e.exit("htmlFlowData"), te(v)) : (e.consume(v), F);
  }
  function te(v) {
    return e.exit("htmlFlow"), t(v);
  }
}
function ox(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return ve(c) ? (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), l) : a(c);
  }
  function l(c) {
    return i.parser.lazy[i.now().line] ? a(c) : t(c);
  }
}
function lx(e, t, a) {
  return i;
  function i(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(io, t, a);
  }
}
const ux = {
  name: "htmlText",
  tokenize: cx
};
function cx(e, t, a) {
  const i = this;
  let o, l, c;
  return d;
  function d(O) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(O), m;
  }
  function m(O) {
    return O === 33 ? (e.consume(O), f) : O === 47 ? (e.consume(O), q) : O === 63 ? (e.consume(O), x) : Gt(O) ? (e.consume(O), K) : a(O);
  }
  function f(O) {
    return O === 45 ? (e.consume(O), b) : O === 91 ? (e.consume(O), l = 0, _) : Gt(O) ? (e.consume(O), L) : a(O);
  }
  function b(O) {
    return O === 45 ? (e.consume(O), S) : a(O);
  }
  function E(O) {
    return O === null ? a(O) : O === 45 ? (e.consume(O), T) : ve(O) ? (c = E, se(O)) : (e.consume(O), E);
  }
  function T(O) {
    return O === 45 ? (e.consume(O), S) : E(O);
  }
  function S(O) {
    return O === 62 ? j(O) : O === 45 ? T(O) : E(O);
  }
  function _(O) {
    const F = "CDATA[";
    return O === F.charCodeAt(l++) ? (e.consume(O), l === F.length ? k : _) : a(O);
  }
  function k(O) {
    return O === null ? a(O) : O === 93 ? (e.consume(O), R) : ve(O) ? (c = k, se(O)) : (e.consume(O), k);
  }
  function R(O) {
    return O === 93 ? (e.consume(O), C) : k(O);
  }
  function C(O) {
    return O === 62 ? j(O) : O === 93 ? (e.consume(O), C) : k(O);
  }
  function L(O) {
    return O === null || O === 62 ? j(O) : ve(O) ? (c = L, se(O)) : (e.consume(O), L);
  }
  function x(O) {
    return O === null ? a(O) : O === 63 ? (e.consume(O), Y) : ve(O) ? (c = x, se(O)) : (e.consume(O), x);
  }
  function Y(O) {
    return O === 62 ? j(O) : x(O);
  }
  function q(O) {
    return Gt(O) ? (e.consume(O), D) : a(O);
  }
  function D(O) {
    return O === 45 || Dt(O) ? (e.consume(O), D) : G(O);
  }
  function G(O) {
    return ve(O) ? (c = G, se(O)) : Fe(O) ? (e.consume(O), G) : j(O);
  }
  function K(O) {
    return O === 45 || Dt(O) ? (e.consume(O), K) : O === 47 || O === 62 || at(O) ? Q(O) : a(O);
  }
  function Q(O) {
    return O === 47 ? (e.consume(O), j) : O === 58 || O === 95 || Gt(O) ? (e.consume(O), U) : ve(O) ? (c = Q, se(O)) : Fe(O) ? (e.consume(O), Q) : j(O);
  }
  function U(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || Dt(O) ? (e.consume(O), U) : ee(O);
  }
  function ee(O) {
    return O === 61 ? (e.consume(O), ae) : ve(O) ? (c = ee, se(O)) : Fe(O) ? (e.consume(O), ee) : Q(O);
  }
  function ae(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? a(O) : O === 34 || O === 39 ? (e.consume(O), o = O, ue) : ve(O) ? (c = ae, se(O)) : Fe(O) ? (e.consume(O), ae) : (e.consume(O), de);
  }
  function ue(O) {
    return O === o ? (e.consume(O), o = void 0, ce) : O === null ? a(O) : ve(O) ? (c = ue, se(O)) : (e.consume(O), ue);
  }
  function de(O) {
    return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? a(O) : O === 47 || O === 62 || at(O) ? Q(O) : (e.consume(O), de);
  }
  function ce(O) {
    return O === 47 || O === 62 || at(O) ? Q(O) : a(O);
  }
  function j(O) {
    return O === 62 ? (e.consume(O), e.exit("htmlTextData"), e.exit("htmlText"), t) : a(O);
  }
  function se(O) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), Ee;
  }
  function Ee(O) {
    return Fe(O) ? je(e, Ne, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : Ne(O);
  }
  function Ne(O) {
    return e.enter("htmlTextData"), c(O);
  }
}
const Nf = {
  name: "labelEnd",
  resolveAll: mx,
  resolveTo: gx,
  tokenize: hx
}, dx = {
  tokenize: bx
}, px = {
  tokenize: Ex
}, fx = {
  tokenize: yx
};
function mx(e) {
  let t = -1;
  const a = [];
  for (; ++t < e.length; ) {
    const i = e[t][1];
    if (a.push(e[t]), i.type === "labelImage" || i.type === "labelLink" || i.type === "labelEnd") {
      const o = i.type === "labelImage" ? 4 : 2;
      i.type = "data", t += o;
    }
  }
  return e.length !== a.length && pn(e, 0, e.length, a), e;
}
function gx(e, t) {
  let a = e.length, i = 0, o, l, c, d;
  for (; a--; )
    if (o = e[a][1], l) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[a][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (c) {
      if (e[a][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (l = a, o.type !== "labelLink")) {
        i = 2;
        break;
      }
    } else o.type === "labelEnd" && (c = a);
  const m = {
    type: e[l][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[l][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, f = {
    type: "label",
    start: {
      ...e[l][1].start
    },
    end: {
      ...e[c][1].end
    }
  }, b = {
    type: "labelText",
    start: {
      ...e[l + i + 2][1].end
    },
    end: {
      ...e[c - 2][1].start
    }
  };
  return d = [["enter", m, t], ["enter", f, t]], d = An(d, e.slice(l + 1, l + i + 3)), d = An(d, [["enter", b, t]]), d = An(d, fu(t.parser.constructs.insideSpan.null, e.slice(l + i + 4, c - 3), t)), d = An(d, [["exit", b, t], e[c - 2], e[c - 1], ["exit", f, t]]), d = An(d, e.slice(c + 1)), d = An(d, [["exit", m, t]]), pn(e, l, e.length, d), e;
}
function hx(e, t, a) {
  const i = this;
  let o = i.events.length, l, c;
  for (; o--; )
    if ((i.events[o][1].type === "labelImage" || i.events[o][1].type === "labelLink") && !i.events[o][1]._balanced) {
      l = i.events[o][1];
      break;
    }
  return d;
  function d(T) {
    return l ? l._inactive ? E(T) : (c = i.parser.defined.includes(On(i.sliceSerialize({
      start: l.end,
      end: i.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(T), e.exit("labelMarker"), e.exit("labelEnd"), m) : a(T);
  }
  function m(T) {
    return T === 40 ? e.attempt(dx, b, c ? b : E)(T) : T === 91 ? e.attempt(px, b, c ? f : E)(T) : c ? b(T) : E(T);
  }
  function f(T) {
    return e.attempt(fx, b, E)(T);
  }
  function b(T) {
    return t(T);
  }
  function E(T) {
    return l._balanced = !0, a(T);
  }
}
function bx(e, t, a) {
  return i;
  function i(E) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(E), e.exit("resourceMarker"), o;
  }
  function o(E) {
    return at(E) ? Fs(e, l)(E) : l(E);
  }
  function l(E) {
    return E === 41 ? b(E) : v1(e, c, d, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(E);
  }
  function c(E) {
    return at(E) ? Fs(e, m)(E) : b(E);
  }
  function d(E) {
    return a(E);
  }
  function m(E) {
    return E === 34 || E === 39 || E === 40 ? w1(e, f, a, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(E) : b(E);
  }
  function f(E) {
    return at(E) ? Fs(e, b)(E) : b(E);
  }
  function b(E) {
    return E === 41 ? (e.enter("resourceMarker"), e.consume(E), e.exit("resourceMarker"), e.exit("resource"), t) : a(E);
  }
}
function Ex(e, t, a) {
  const i = this;
  return o;
  function o(d) {
    return C1.call(i, e, l, c, "reference", "referenceMarker", "referenceString")(d);
  }
  function l(d) {
    return i.parser.defined.includes(On(i.sliceSerialize(i.events[i.events.length - 1][1]).slice(1, -1))) ? t(d) : a(d);
  }
  function c(d) {
    return a(d);
  }
}
function yx(e, t, a) {
  return i;
  function i(l) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), o;
  }
  function o(l) {
    return l === 93 ? (e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), e.exit("reference"), t) : a(l);
  }
}
const Tx = {
  name: "labelStartImage",
  resolveAll: Nf.resolveAll,
  tokenize: Sx
};
function Sx(e, t, a) {
  const i = this;
  return o;
  function o(d) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(d), e.exit("labelImageMarker"), l;
  }
  function l(d) {
    return d === 91 ? (e.enter("labelMarker"), e.consume(d), e.exit("labelMarker"), e.exit("labelImage"), c) : a(d);
  }
  function c(d) {
    return d === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? a(d) : t(d);
  }
}
const _x = {
  name: "labelStartLink",
  resolveAll: Nf.resolveAll,
  tokenize: Ax
};
function Ax(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(c), e.exit("labelMarker"), e.exit("labelLink"), l;
  }
  function l(c) {
    return c === 94 && "_hiddenFootnoteSupport" in i.parser.constructs ? a(c) : t(c);
  }
}
const up = {
  name: "lineEnding",
  tokenize: Nx
};
function Nx(e, t) {
  return a;
  function a(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), je(e, t, "linePrefix");
  }
}
const ql = {
  name: "thematicBreak",
  tokenize: Rx
};
function Rx(e, t, a) {
  let i = 0, o;
  return l;
  function l(f) {
    return e.enter("thematicBreak"), c(f);
  }
  function c(f) {
    return o = f, d(f);
  }
  function d(f) {
    return f === o ? (e.enter("thematicBreakSequence"), m(f)) : i >= 3 && (f === null || ve(f)) ? (e.exit("thematicBreak"), t(f)) : a(f);
  }
  function m(f) {
    return f === o ? (e.consume(f), i++, m) : (e.exit("thematicBreakSequence"), Fe(f) ? je(e, d, "whitespace")(f) : d(f));
  }
}
const Jt = {
  continuation: {
    tokenize: kx
  },
  exit: Ox,
  name: "list",
  tokenize: wx
}, vx = {
  partial: !0,
  tokenize: xx
}, Cx = {
  partial: !0,
  tokenize: Ix
};
function wx(e, t, a) {
  const i = this, o = i.events[i.events.length - 1];
  let l = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, c = 0;
  return d;
  function d(S) {
    const _ = i.containerState.type || (S === 42 || S === 43 || S === 45 ? "listUnordered" : "listOrdered");
    if (_ === "listUnordered" ? !i.containerState.marker || S === i.containerState.marker : qp(S)) {
      if (i.containerState.type || (i.containerState.type = _, e.enter(_, {
        _container: !0
      })), _ === "listUnordered")
        return e.enter("listItemPrefix"), S === 42 || S === 45 ? e.check(ql, a, f)(S) : f(S);
      if (!i.interrupt || S === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), m(S);
    }
    return a(S);
  }
  function m(S) {
    return qp(S) && ++c < 10 ? (e.consume(S), m) : (!i.interrupt || c < 2) && (i.containerState.marker ? S === i.containerState.marker : S === 41 || S === 46) ? (e.exit("listItemValue"), f(S)) : a(S);
  }
  function f(S) {
    return e.enter("listItemMarker"), e.consume(S), e.exit("listItemMarker"), i.containerState.marker = i.containerState.marker || S, e.check(
      io,
      // Cant be empty when interrupting.
      i.interrupt ? a : b,
      e.attempt(vx, T, E)
    );
  }
  function b(S) {
    return i.containerState.initialBlankLine = !0, l++, T(S);
  }
  function E(S) {
    return Fe(S) ? (e.enter("listItemPrefixWhitespace"), e.consume(S), e.exit("listItemPrefixWhitespace"), T) : a(S);
  }
  function T(S) {
    return i.containerState.size = l + i.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(S);
  }
}
function kx(e, t, a) {
  const i = this;
  return i.containerState._closeFlow = void 0, e.check(io, o, l);
  function o(d) {
    return i.containerState.furtherBlankLines = i.containerState.furtherBlankLines || i.containerState.initialBlankLine, je(e, t, "listItemIndent", i.containerState.size + 1)(d);
  }
  function l(d) {
    return i.containerState.furtherBlankLines || !Fe(d) ? (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, c(d)) : (i.containerState.furtherBlankLines = void 0, i.containerState.initialBlankLine = void 0, e.attempt(Cx, t, c)(d));
  }
  function c(d) {
    return i.containerState._closeFlow = !0, i.interrupt = void 0, je(e, e.attempt(Jt, t, a), "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(d);
  }
}
function Ix(e, t, a) {
  const i = this;
  return je(e, o, "listItemIndent", i.containerState.size + 1);
  function o(l) {
    const c = i.events[i.events.length - 1];
    return c && c[1].type === "listItemIndent" && c[2].sliceSerialize(c[1], !0).length === i.containerState.size ? t(l) : a(l);
  }
}
function Ox(e) {
  e.exit(this.containerState.type);
}
function xx(e, t, a) {
  const i = this;
  return je(e, o, "listItemPrefixWhitespace", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(l) {
    const c = i.events[i.events.length - 1];
    return !Fe(l) && c && c[1].type === "listItemPrefixWhitespace" ? t(l) : a(l);
  }
}
const S_ = {
  name: "setextUnderline",
  resolveTo: Lx,
  tokenize: Dx
};
function Lx(e, t) {
  let a = e.length, i, o, l;
  for (; a--; )
    if (e[a][0] === "enter") {
      if (e[a][1].type === "content") {
        i = a;
        break;
      }
      e[a][1].type === "paragraph" && (o = a);
    } else
      e[a][1].type === "content" && e.splice(a, 1), !l && e[a][1].type === "definition" && (l = a);
  const c = {
    type: "setextHeading",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", l ? (e.splice(o, 0, ["enter", c, t]), e.splice(l + 1, 0, ["exit", e[i][1], t]), e[i][1].end = {
    ...e[l][1].end
  }) : e[i][1] = c, e.push(["exit", c, t]), e;
}
function Dx(e, t, a) {
  const i = this;
  let o;
  return l;
  function l(f) {
    let b = i.events.length, E;
    for (; b--; )
      if (i.events[b][1].type !== "lineEnding" && i.events[b][1].type !== "linePrefix" && i.events[b][1].type !== "content") {
        E = i.events[b][1].type === "paragraph";
        break;
      }
    return !i.parser.lazy[i.now().line] && (i.interrupt || E) ? (e.enter("setextHeadingLine"), o = f, c(f)) : a(f);
  }
  function c(f) {
    return e.enter("setextHeadingLineSequence"), d(f);
  }
  function d(f) {
    return f === o ? (e.consume(f), d) : (e.exit("setextHeadingLineSequence"), Fe(f) ? je(e, m, "lineSuffix")(f) : m(f));
  }
  function m(f) {
    return f === null || ve(f) ? (e.exit("setextHeadingLine"), t(f)) : a(f);
  }
}
const Mx = {
  tokenize: Ux
};
function Ux(e) {
  const t = this, a = e.attempt(
    // Try to parse a blank line.
    io,
    i,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, je(e, e.attempt(this.parser.constructs.flow, o, e.attempt(zO, o)), "linePrefix"))
  );
  return a;
  function i(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(l), e.exit("lineEndingBlank"), t.currentConstruct = void 0, a;
  }
  function o(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), t.currentConstruct = void 0, a;
  }
}
const Bx = {
  resolveAll: I1()
}, Fx = k1("string"), Px = k1("text");
function k1(e) {
  return {
    resolveAll: I1(e === "text" ? Hx : void 0),
    tokenize: t
  };
  function t(a) {
    const i = this, o = this.parser.constructs[e], l = a.attempt(o, c, d);
    return c;
    function c(b) {
      return f(b) ? l(b) : d(b);
    }
    function d(b) {
      if (b === null) {
        a.consume(b);
        return;
      }
      return a.enter("data"), a.consume(b), m;
    }
    function m(b) {
      return f(b) ? (a.exit("data"), l(b)) : (a.consume(b), m);
    }
    function f(b) {
      if (b === null)
        return !0;
      const E = o[b];
      let T = -1;
      if (E)
        for (; ++T < E.length; ) {
          const S = E[T];
          if (!S.previous || S.previous.call(i, i.previous))
            return !0;
        }
      return !1;
    }
  }
}
function I1(e) {
  return t;
  function t(a, i) {
    let o = -1, l;
    for (; ++o <= a.length; )
      l === void 0 ? a[o] && a[o][1].type === "data" && (l = o, o++) : (!a[o] || a[o][1].type !== "data") && (o !== l + 2 && (a[l][1].end = a[o - 1][1].end, a.splice(l + 2, o - l - 2), o = l + 2), l = void 0);
    return e ? e(a, i) : a;
  }
}
function Hx(e, t) {
  let a = 0;
  for (; ++a <= e.length; )
    if ((a === e.length || e[a][1].type === "lineEnding") && e[a - 1][1].type === "data") {
      const i = e[a - 1][1], o = t.sliceStream(i);
      let l = o.length, c = -1, d = 0, m;
      for (; l--; ) {
        const f = o[l];
        if (typeof f == "string") {
          for (c = f.length; f.charCodeAt(c - 1) === 32; )
            d++, c--;
          if (c) break;
          c = -1;
        } else if (f === -2)
          m = !0, d++;
        else if (f !== -1) {
          l++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && a === e.length && (d = 0), d) {
        const f = {
          type: a === e.length || m || d < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: l ? c : i.start._bufferIndex + c,
            _index: i.start._index + l,
            line: i.end.line,
            column: i.end.column - d,
            offset: i.end.offset - d
          },
          end: {
            ...i.end
          }
        };
        i.end = {
          ...f.start
        }, i.start.offset === i.end.offset ? Object.assign(i, f) : (e.splice(a, 0, ["enter", f, t], ["exit", f, t]), a += 2);
      }
      a++;
    }
  return e;
}
const zx = {
  42: Jt,
  43: Jt,
  45: Jt,
  48: Jt,
  49: Jt,
  50: Jt,
  51: Jt,
  52: Jt,
  53: Jt,
  54: Jt,
  55: Jt,
  56: Jt,
  57: Jt,
  62: _1
}, Gx = {
  91: YO
}, jx = {
  [-2]: lp,
  [-1]: lp,
  32: lp
}, $x = {
  35: QO,
  42: ql,
  45: [S_, ql],
  60: nx,
  61: S_,
  95: ql,
  96: y_,
  126: y_
}, qx = {
  38: N1,
  92: A1
}, Yx = {
  [-5]: up,
  [-4]: up,
  [-3]: up,
  33: Tx,
  38: N1,
  42: Yp,
  60: [_O, ux],
  91: _x,
  92: [KO, A1],
  93: Nf,
  95: Yp,
  96: MO
}, Vx = {
  null: [Yp, Bx]
}, Wx = {
  null: [42, 95]
}, Xx = {
  null: []
}, Kx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Wx,
  contentInitial: Gx,
  disable: Xx,
  document: zx,
  flow: $x,
  flowInitial: jx,
  insideSpan: Vx,
  string: qx,
  text: Yx
}, Symbol.toStringTag, { value: "Module" }));
function Zx(e, t, a) {
  let i = {
    _bufferIndex: -1,
    _index: 0,
    line: a && a.line || 1,
    column: a && a.column || 1,
    offset: a && a.offset || 0
  };
  const o = {}, l = [];
  let c = [], d = [];
  const m = {
    attempt: G(q),
    check: G(D),
    consume: L,
    enter: x,
    exit: Y,
    interrupt: G(D, {
      interrupt: !0
    })
  }, f = {
    code: null,
    containerState: {},
    defineSkip: k,
    events: [],
    now: _,
    parser: e,
    previous: null,
    sliceSerialize: T,
    sliceStream: S,
    write: E
  };
  let b = t.tokenize.call(f, m);
  return t.resolveAll && l.push(t), f;
  function E(ee) {
    return c = An(c, ee), R(), c[c.length - 1] !== null ? [] : (K(t, 0), f.events = fu(l, f.events, f), f.events);
  }
  function T(ee, ae) {
    return Jx(S(ee), ae);
  }
  function S(ee) {
    return Qx(c, ee);
  }
  function _() {
    const {
      _bufferIndex: ee,
      _index: ae,
      line: ue,
      column: de,
      offset: ce
    } = i;
    return {
      _bufferIndex: ee,
      _index: ae,
      line: ue,
      column: de,
      offset: ce
    };
  }
  function k(ee) {
    o[ee.line] = ee.column, U();
  }
  function R() {
    let ee;
    for (; i._index < c.length; ) {
      const ae = c[i._index];
      if (typeof ae == "string")
        for (ee = i._index, i._bufferIndex < 0 && (i._bufferIndex = 0); i._index === ee && i._bufferIndex < ae.length; )
          C(ae.charCodeAt(i._bufferIndex));
      else
        C(ae);
    }
  }
  function C(ee) {
    b = b(ee);
  }
  function L(ee) {
    ve(ee) ? (i.line++, i.column = 1, i.offset += ee === -3 ? 2 : 1, U()) : ee !== -1 && (i.column++, i.offset++), i._bufferIndex < 0 ? i._index++ : (i._bufferIndex++, i._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    c[i._index].length && (i._bufferIndex = -1, i._index++)), f.previous = ee;
  }
  function x(ee, ae) {
    const ue = ae || {};
    return ue.type = ee, ue.start = _(), f.events.push(["enter", ue, f]), d.push(ue), ue;
  }
  function Y(ee) {
    const ae = d.pop();
    return ae.end = _(), f.events.push(["exit", ae, f]), ae;
  }
  function q(ee, ae) {
    K(ee, ae.from);
  }
  function D(ee, ae) {
    ae.restore();
  }
  function G(ee, ae) {
    return ue;
    function ue(de, ce, j) {
      let se, Ee, Ne, O;
      return Array.isArray(de) ? (
        /* c8 ignore next 1 */
        te(de)
      ) : "tokenize" in de ? (
        // Looks like a construct.
        te([
          /** @type {Construct} */
          de
        ])
      ) : F(de);
      function F(_e) {
        return Le;
        function Le(Ze) {
          const Ve = Ze !== null && _e[Ze], jt = Ze !== null && _e.null, vn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Ve) ? Ve : Ve ? [Ve] : [],
            ...Array.isArray(jt) ? jt : jt ? [jt] : []
          ];
          return te(vn)(Ze);
        }
      }
      function te(_e) {
        return se = _e, Ee = 0, _e.length === 0 ? j : v(_e[Ee]);
      }
      function v(_e) {
        return Le;
        function Le(Ze) {
          return O = Q(), Ne = _e, _e.partial || (f.currentConstruct = _e), _e.name && f.parser.constructs.disable.null.includes(_e.name) ? ye() : _e.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            ae ? Object.assign(Object.create(f), ae) : f,
            m,
            he,
            ye
          )(Ze);
        }
      }
      function he(_e) {
        return ee(Ne, O), ce;
      }
      function ye(_e) {
        return O.restore(), ++Ee < se.length ? v(se[Ee]) : j;
      }
    }
  }
  function K(ee, ae) {
    ee.resolveAll && !l.includes(ee) && l.push(ee), ee.resolve && pn(f.events, ae, f.events.length - ae, ee.resolve(f.events.slice(ae), f)), ee.resolveTo && (f.events = ee.resolveTo(f.events, f));
  }
  function Q() {
    const ee = _(), ae = f.previous, ue = f.currentConstruct, de = f.events.length, ce = Array.from(d);
    return {
      from: de,
      restore: j
    };
    function j() {
      i = ee, f.previous = ae, f.currentConstruct = ue, f.events.length = de, d = ce, U();
    }
  }
  function U() {
    i.line in o && i.column < 2 && (i.column = o[i.line], i.offset += o[i.line] - 1);
  }
}
function Qx(e, t) {
  const a = t.start._index, i = t.start._bufferIndex, o = t.end._index, l = t.end._bufferIndex;
  let c;
  if (a === o)
    c = [e[a].slice(i, l)];
  else {
    if (c = e.slice(a, o), i > -1) {
      const d = c[0];
      typeof d == "string" ? c[0] = d.slice(i) : c.shift();
    }
    l > 0 && c.push(e[o].slice(0, l));
  }
  return c;
}
function Jx(e, t) {
  let a = -1;
  const i = [];
  let o;
  for (; ++a < e.length; ) {
    const l = e[a];
    let c;
    if (typeof l == "string")
      c = l;
    else switch (l) {
      case -5: {
        c = "\r";
        break;
      }
      case -4: {
        c = `
`;
        break;
      }
      case -3: {
        c = `\r
`;
        break;
      }
      case -2: {
        c = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        c = " ";
        break;
      }
      default:
        c = String.fromCharCode(l);
    }
    o = l === -2, i.push(c);
  }
  return i.join("");
}
function e2(e) {
  const i = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      T1([Kx, ...(e || {}).extensions || []])
    ),
    content: o(gO),
    defined: [],
    document: o(bO),
    flow: o(Mx),
    lazy: {},
    string: o(Fx),
    text: o(Px)
  };
  return i;
  function o(l) {
    return c;
    function c(d) {
      return Zx(i, l, d);
    }
  }
}
function t2(e) {
  for (; !R1(e); )
    ;
  return e;
}
const __ = /[\0\t\n\r]/g;
function n2() {
  let e = 1, t = "", a = !0, i;
  return o;
  function o(l, c, d) {
    const m = [];
    let f, b, E, T, S;
    for (l = t + (typeof l == "string" ? l.toString() : new TextDecoder(c || void 0).decode(l)), E = 0, t = "", a && (l.charCodeAt(0) === 65279 && E++, a = void 0); E < l.length; ) {
      if (__.lastIndex = E, f = __.exec(l), T = f && f.index !== void 0 ? f.index : l.length, S = l.charCodeAt(T), !f) {
        t = l.slice(E);
        break;
      }
      if (S === 10 && E === T && i)
        m.push(-3), i = void 0;
      else
        switch (i && (m.push(-5), i = void 0), E < T && (m.push(l.slice(E, T)), e += T - E), S) {
          case 0: {
            m.push(65533), e++;
            break;
          }
          case 9: {
            for (b = Math.ceil(e / 4) * 4, m.push(-2); e++ < b; ) m.push(-1);
            break;
          }
          case 10: {
            m.push(-4), e = 1;
            break;
          }
          default:
            i = !0, e = 1;
        }
      E = T + 1;
    }
    return d && (i && m.push(-5), t && m.push(t), m.push(null)), m;
  }
}
const a2 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function r2(e) {
  return e.replace(a2, i2);
}
function i2(e, t, a) {
  if (t)
    return t;
  if (a.charCodeAt(0) === 35) {
    const o = a.charCodeAt(1), l = o === 120 || o === 88;
    return S1(a.slice(l ? 2 : 1), l ? 16 : 10);
  }
  return Xs(a) || e;
}
const O1 = {}.hasOwnProperty;
function s2(e, t, a) {
  return typeof t != "string" && (a = t, t = void 0), o2(a)(t2(e2(a).document().write(n2()(e, t, !0))));
}
function o2(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: l(Nr),
      autolinkProtocol: Q,
      autolinkEmail: Q,
      atxHeading: l(_r),
      blockQuote: l(jt),
      characterEscape: Q,
      characterReference: Q,
      codeFenced: l(vn),
      codeFencedFenceInfo: c,
      codeFencedFenceMeta: c,
      codeIndented: l(vn, c),
      codeText: l(xi, c),
      codeTextData: Q,
      data: Q,
      codeFlowValue: Q,
      definition: l(bo),
      definitionDestinationString: c,
      definitionLabelString: c,
      definitionTitleString: c,
      emphasis: l($n),
      hardBreakEscape: l(Ar),
      hardBreakTrailing: l(Ar),
      htmlFlow: l(Eo, c),
      htmlFlowData: Q,
      htmlText: l(Eo, c),
      htmlTextData: Q,
      image: l(yo),
      label: c,
      link: l(Nr),
      listItem: l(Li),
      listItemValue: T,
      listOrdered: l(Rr, E),
      listUnordered: l(Rr),
      paragraph: l(Ou),
      reference: v,
      referenceString: c,
      resourceDestinationString: c,
      resourceTitleString: c,
      setextHeading: l(_r),
      strong: l(xu),
      thematicBreak: l(Lu)
    },
    exit: {
      atxHeading: m(),
      atxHeadingSequence: q,
      autolink: m(),
      autolinkEmail: Ve,
      autolinkProtocol: Ze,
      blockQuote: m(),
      characterEscapeValue: U,
      characterReferenceMarkerHexadecimal: ye,
      characterReferenceMarkerNumeric: ye,
      characterReferenceValue: _e,
      characterReference: Le,
      codeFenced: m(R),
      codeFencedFence: k,
      codeFencedFenceInfo: S,
      codeFencedFenceMeta: _,
      codeFlowValue: U,
      codeIndented: m(C),
      codeText: m(ce),
      codeTextData: U,
      data: U,
      definition: m(),
      definitionDestinationString: Y,
      definitionLabelString: L,
      definitionTitleString: x,
      emphasis: m(),
      hardBreakEscape: m(ae),
      hardBreakTrailing: m(ae),
      htmlFlow: m(ue),
      htmlFlowData: U,
      htmlText: m(de),
      htmlTextData: U,
      image: m(se),
      label: Ne,
      labelText: Ee,
      lineEnding: ee,
      link: m(j),
      listItem: m(),
      listOrdered: m(),
      listUnordered: m(),
      paragraph: m(),
      referenceString: he,
      resourceDestinationString: O,
      resourceTitleString: F,
      resource: te,
      setextHeading: m(K),
      setextHeadingLineSequence: G,
      setextHeadingText: D,
      strong: m(),
      thematicBreak: m()
    }
  };
  x1(t, (e || {}).mdastExtensions || []);
  const a = {};
  return i;
  function i(ie) {
    let be = {
      type: "root",
      children: []
    };
    const we = {
      stack: [be],
      tokenStack: [],
      config: t,
      enter: d,
      exit: f,
      buffer: c,
      resume: b,
      data: a
    }, Me = [];
    let We = -1;
    for (; ++We < ie.length; )
      if (ie[We][1].type === "listOrdered" || ie[We][1].type === "listUnordered")
        if (ie[We][0] === "enter")
          Me.push(We);
        else {
          const nn = Me.pop();
          We = o(ie, nn, We);
        }
    for (We = -1; ++We < ie.length; ) {
      const nn = t[ie[We][0]];
      O1.call(nn, ie[We][1].type) && nn[ie[We][1].type].call(Object.assign({
        sliceSerialize: ie[We][2].sliceSerialize
      }, we), ie[We][1]);
    }
    if (we.tokenStack.length > 0) {
      const nn = we.tokenStack[we.tokenStack.length - 1];
      (nn[1] || A_).call(we, void 0, nn[0]);
    }
    for (be.position = {
      start: Pa(ie.length > 0 ? ie[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Pa(ie.length > 0 ? ie[ie.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, We = -1; ++We < t.transforms.length; )
      be = t.transforms[We](be) || be;
    return be;
  }
  function o(ie, be, we) {
    let Me = be - 1, We = -1, nn = !1, qn, Ht, Tt, $t;
    for (; ++Me <= we; ) {
      const tt = ie[Me];
      switch (tt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          tt[0] === "enter" ? We++ : We--, $t = void 0;
          break;
        }
        case "lineEndingBlank": {
          tt[0] === "enter" && (qn && !$t && !We && !Tt && (Tt = Me), $t = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          $t = void 0;
      }
      if (!We && tt[0] === "enter" && tt[1].type === "listItemPrefix" || We === -1 && tt[0] === "exit" && (tt[1].type === "listUnordered" || tt[1].type === "listOrdered")) {
        if (qn) {
          let ma = Me;
          for (Ht = void 0; ma--; ) {
            const Cn = ie[ma];
            if (Cn[1].type === "lineEnding" || Cn[1].type === "lineEndingBlank") {
              if (Cn[0] === "exit") continue;
              Ht && (ie[Ht][1].type = "lineEndingBlank", nn = !0), Cn[1].type = "lineEnding", Ht = ma;
            } else if (!(Cn[1].type === "linePrefix" || Cn[1].type === "blockQuotePrefix" || Cn[1].type === "blockQuotePrefixWhitespace" || Cn[1].type === "blockQuoteMarker" || Cn[1].type === "listItemIndent")) break;
          }
          Tt && (!Ht || Tt < Ht) && (qn._spread = !0), qn.end = Object.assign({}, Ht ? ie[Ht][1].start : tt[1].end), ie.splice(Ht || Me, 0, ["exit", qn, tt[2]]), Me++, we++;
        }
        if (tt[1].type === "listItemPrefix") {
          const ma = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, tt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          qn = ma, ie.splice(Me, 0, ["enter", ma, tt[2]]), Me++, we++, Tt = void 0, $t = !0;
        }
      }
    }
    return ie[be][1]._spread = nn, we;
  }
  function l(ie, be) {
    return we;
    function we(Me) {
      d.call(this, ie(Me), Me), be && be.call(this, Me);
    }
  }
  function c() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function d(ie, be, we) {
    this.stack[this.stack.length - 1].children.push(ie), this.stack.push(ie), this.tokenStack.push([be, we || void 0]), ie.position = {
      start: Pa(be.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function m(ie) {
    return be;
    function be(we) {
      ie && ie.call(this, we), f.call(this, we);
    }
  }
  function f(ie, be) {
    const we = this.stack.pop(), Me = this.tokenStack.pop();
    if (Me)
      Me[0].type !== ie.type && (be ? be.call(this, ie, Me[0]) : (Me[1] || A_).call(this, ie, Me[0]));
    else throw new Error("Cannot close `" + ie.type + "` (" + Bs({
      start: ie.start,
      end: ie.end
    }) + "): its not open");
    we.position.end = Pa(ie.end);
  }
  function b() {
    return Af(this.stack.pop());
  }
  function E() {
    this.data.expectingFirstListItemValue = !0;
  }
  function T(ie) {
    if (this.data.expectingFirstListItemValue) {
      const be = this.stack[this.stack.length - 2];
      be.start = Number.parseInt(this.sliceSerialize(ie), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function S() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.lang = ie;
  }
  function _() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.meta = ie;
  }
  function k() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function R() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ie.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function C() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ie.replace(/(\r?\n|\r)$/g, "");
  }
  function L(ie) {
    const be = this.resume(), we = this.stack[this.stack.length - 1];
    we.label = be, we.identifier = On(this.sliceSerialize(ie)).toLowerCase();
  }
  function x() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.title = ie;
  }
  function Y() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.url = ie;
  }
  function q(ie) {
    const be = this.stack[this.stack.length - 1];
    if (!be.depth) {
      const we = this.sliceSerialize(ie).length;
      be.depth = we;
    }
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function G(ie) {
    const be = this.stack[this.stack.length - 1];
    be.depth = this.sliceSerialize(ie).codePointAt(0) === 61 ? 1 : 2;
  }
  function K() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Q(ie) {
    const we = this.stack[this.stack.length - 1].children;
    let Me = we[we.length - 1];
    (!Me || Me.type !== "text") && (Me = Pt(), Me.position = {
      start: Pa(ie.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, we.push(Me)), this.stack.push(Me);
  }
  function U(ie) {
    const be = this.stack.pop();
    be.value += this.sliceSerialize(ie), be.position.end = Pa(ie.end);
  }
  function ee(ie) {
    const be = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const we = be.children[be.children.length - 1];
      we.position.end = Pa(ie.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(be.type) && (Q.call(this, ie), U.call(this, ie));
  }
  function ae() {
    this.data.atHardBreak = !0;
  }
  function ue() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ie;
  }
  function de() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ie;
  }
  function ce() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.value = ie;
  }
  function j() {
    const ie = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const be = this.data.referenceType || "shortcut";
      ie.type += "Reference", ie.referenceType = be, delete ie.url, delete ie.title;
    } else
      delete ie.identifier, delete ie.label;
    this.data.referenceType = void 0;
  }
  function se() {
    const ie = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const be = this.data.referenceType || "shortcut";
      ie.type += "Reference", ie.referenceType = be, delete ie.url, delete ie.title;
    } else
      delete ie.identifier, delete ie.label;
    this.data.referenceType = void 0;
  }
  function Ee(ie) {
    const be = this.sliceSerialize(ie), we = this.stack[this.stack.length - 2];
    we.label = r2(be), we.identifier = On(be).toLowerCase();
  }
  function Ne() {
    const ie = this.stack[this.stack.length - 1], be = this.resume(), we = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, we.type === "link") {
      const Me = ie.children;
      we.children = Me;
    } else
      we.alt = be;
  }
  function O() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.url = ie;
  }
  function F() {
    const ie = this.resume(), be = this.stack[this.stack.length - 1];
    be.title = ie;
  }
  function te() {
    this.data.inReference = void 0;
  }
  function v() {
    this.data.referenceType = "collapsed";
  }
  function he(ie) {
    const be = this.resume(), we = this.stack[this.stack.length - 1];
    we.label = be, we.identifier = On(this.sliceSerialize(ie)).toLowerCase(), this.data.referenceType = "full";
  }
  function ye(ie) {
    this.data.characterReferenceType = ie.type;
  }
  function _e(ie) {
    const be = this.sliceSerialize(ie), we = this.data.characterReferenceType;
    let Me;
    we ? (Me = S1(be, we === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Me = Xs(be);
    const We = this.stack[this.stack.length - 1];
    We.value += Me;
  }
  function Le(ie) {
    const be = this.stack.pop();
    be.position.end = Pa(ie.end);
  }
  function Ze(ie) {
    U.call(this, ie);
    const be = this.stack[this.stack.length - 1];
    be.url = this.sliceSerialize(ie);
  }
  function Ve(ie) {
    U.call(this, ie);
    const be = this.stack[this.stack.length - 1];
    be.url = "mailto:" + this.sliceSerialize(ie);
  }
  function jt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function vn() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function xi() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function bo() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function $n() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function _r() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ar() {
    return {
      type: "break"
    };
  }
  function Eo() {
    return {
      type: "html",
      value: ""
    };
  }
  function yo() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Nr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Rr(ie) {
    return {
      type: "list",
      ordered: ie.type === "listOrdered",
      start: null,
      spread: ie._spread,
      children: []
    };
  }
  function Li(ie) {
    return {
      type: "listItem",
      spread: ie._spread,
      checked: null,
      children: []
    };
  }
  function Ou() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function xu() {
    return {
      type: "strong",
      children: []
    };
  }
  function Pt() {
    return {
      type: "text",
      value: ""
    };
  }
  function Lu() {
    return {
      type: "thematicBreak"
    };
  }
}
function Pa(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function x1(e, t) {
  let a = -1;
  for (; ++a < t.length; ) {
    const i = t[a];
    Array.isArray(i) ? x1(e, i) : l2(e, i);
  }
}
function l2(e, t) {
  let a;
  for (a in t)
    if (O1.call(t, a))
      switch (a) {
        case "canContainEols": {
          const i = t[a];
          i && e[a].push(...i);
          break;
        }
        case "transforms": {
          const i = t[a];
          i && e[a].push(...i);
          break;
        }
        case "enter":
        case "exit": {
          const i = t[a];
          i && Object.assign(e[a], i);
          break;
        }
      }
}
function A_(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Bs({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Bs({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Bs({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function u2(e) {
  const t = this;
  t.parser = a;
  function a(i) {
    return s2(i, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function c2(e, t) {
  const a = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function d2(e, t) {
  const a = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, a), [e.applyData(t, a), { type: "text", value: `
` }];
}
function p2(e, t) {
  const a = t.value ? t.value + `
` : "", i = {}, o = t.lang ? t.lang.split(/\s+/) : [];
  o.length > 0 && (i.className = ["language-" + o[0]]);
  let l = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: a }]
  };
  return t.meta && (l.data = { meta: t.meta }), e.patch(t, l), l = e.applyData(t, l), l = { type: "element", tagName: "pre", properties: {}, children: [l] }, e.patch(t, l), l;
}
function f2(e, t) {
  const a = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function m2(e, t) {
  const a = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function g2(e, t) {
  const a = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", i = String(t.identifier).toUpperCase(), o = _i(i.toLowerCase()), l = e.footnoteOrder.indexOf(i);
  let c, d = e.footnoteCounts.get(i);
  d === void 0 ? (d = 0, e.footnoteOrder.push(i), c = e.footnoteOrder.length) : c = l + 1, d += 1, e.footnoteCounts.set(i, d);
  const m = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + a + "fn-" + o,
      id: a + "fnref-" + o + (d > 1 ? "-" + d : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(c) }]
  };
  e.patch(t, m);
  const f = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [m]
  };
  return e.patch(t, f), e.applyData(t, f);
}
function h2(e, t) {
  const a = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function b2(e, t) {
  if (e.options.allowDangerousHtml) {
    const a = { type: "raw", value: t.value };
    return e.patch(t, a), e.applyData(t, a);
  }
}
function L1(e, t) {
  const a = t.referenceType;
  let i = "]";
  if (a === "collapsed" ? i += "[]" : a === "full" && (i += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + i }];
  const o = e.all(t), l = o[0];
  l && l.type === "text" ? l.value = "[" + l.value : o.unshift({ type: "text", value: "[" });
  const c = o[o.length - 1];
  return c && c.type === "text" ? c.value += i : o.push({ type: "text", value: i }), o;
}
function E2(e, t) {
  const a = String(t.identifier).toUpperCase(), i = e.definitionById.get(a);
  if (!i)
    return L1(e, t);
  const o = { src: _i(i.url || ""), alt: t.alt };
  i.title !== null && i.title !== void 0 && (o.title = i.title);
  const l = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, l), e.applyData(t, l);
}
function y2(e, t) {
  const a = { src: _i(t.url) };
  t.alt !== null && t.alt !== void 0 && (a.alt = t.alt), t.title !== null && t.title !== void 0 && (a.title = t.title);
  const i = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function T2(e, t) {
  const a = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, a);
  const i = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [a]
  };
  return e.patch(t, i), e.applyData(t, i);
}
function S2(e, t) {
  const a = String(t.identifier).toUpperCase(), i = e.definitionById.get(a);
  if (!i)
    return L1(e, t);
  const o = { href: _i(i.url || "") };
  i.title !== null && i.title !== void 0 && (o.title = i.title);
  const l = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, l), e.applyData(t, l);
}
function _2(e, t) {
  const a = { href: _i(t.url) };
  t.title !== null && t.title !== void 0 && (a.title = t.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function A2(e, t, a) {
  const i = e.all(t), o = a ? N2(a) : D1(t), l = {}, c = [];
  if (typeof t.checked == "boolean") {
    const b = i[0];
    let E;
    b && b.type === "element" && b.tagName === "p" ? E = b : (E = { type: "element", tagName: "p", properties: {}, children: [] }, i.unshift(E)), E.children.length > 0 && E.children.unshift({ type: "text", value: " " }), E.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), l.className = ["task-list-item"];
  }
  let d = -1;
  for (; ++d < i.length; ) {
    const b = i[d];
    (o || d !== 0 || b.type !== "element" || b.tagName !== "p") && c.push({ type: "text", value: `
` }), b.type === "element" && b.tagName === "p" && !o ? c.push(...b.children) : c.push(b);
  }
  const m = i[i.length - 1];
  m && (o || m.type !== "element" || m.tagName !== "p") && c.push({ type: "text", value: `
` });
  const f = { type: "element", tagName: "li", properties: l, children: c };
  return e.patch(t, f), e.applyData(t, f);
}
function N2(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const a = e.children;
    let i = -1;
    for (; !t && ++i < a.length; )
      t = D1(a[i]);
  }
  return t;
}
function D1(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function R2(e, t) {
  const a = {}, i = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (a.start = t.start); ++o < i.length; ) {
    const c = i[o];
    if (c.type === "element" && c.tagName === "li" && c.properties && Array.isArray(c.properties.className) && c.properties.className.includes("task-list-item")) {
      a.className = ["contains-task-list"];
      break;
    }
  }
  const l = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: a,
    children: e.wrap(i, !0)
  };
  return e.patch(t, l), e.applyData(t, l);
}
function v2(e, t) {
  const a = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function C2(e, t) {
  const a = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, a), e.applyData(t, a);
}
function w2(e, t) {
  const a = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function k2(e, t) {
  const a = e.all(t), i = a.shift(), o = [];
  if (i) {
    const c = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([i], !0)
    };
    e.patch(t.children[0], c), o.push(c);
  }
  if (a.length > 0) {
    const c = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(a, !0)
    }, d = zn(t.children[1]), m = du(t.children[t.children.length - 1]);
    d && m && (c.position = { start: d, end: m }), o.push(c);
  }
  const l = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, l), e.applyData(t, l);
}
function I2(e, t, a) {
  const i = a ? a.children : void 0, l = (i ? i.indexOf(t) : 1) === 0 ? "th" : "td", c = a && a.type === "table" ? a.align : void 0, d = c ? c.length : t.children.length;
  let m = -1;
  const f = [];
  for (; ++m < d; ) {
    const E = t.children[m], T = {}, S = c ? c[m] : void 0;
    S && (T.align = S);
    let _ = { type: "element", tagName: l, properties: T, children: [] };
    E && (_.children = e.all(E), e.patch(E, _), _ = e.applyData(E, _)), f.push(_);
  }
  const b = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(f, !0)
  };
  return e.patch(t, b), e.applyData(t, b);
}
function O2(e, t) {
  const a = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
const N_ = 9, R_ = 32;
function x2(e) {
  const t = String(e), a = /\r?\n|\r/g;
  let i = a.exec(t), o = 0;
  const l = [];
  for (; i; )
    l.push(
      v_(t.slice(o, i.index), o > 0, !0),
      i[0]
    ), o = i.index + i[0].length, i = a.exec(t);
  return l.push(v_(t.slice(o), o > 0, !1)), l.join("");
}
function v_(e, t, a) {
  let i = 0, o = e.length;
  if (t) {
    let l = e.codePointAt(i);
    for (; l === N_ || l === R_; )
      i++, l = e.codePointAt(i);
  }
  if (a) {
    let l = e.codePointAt(o - 1);
    for (; l === N_ || l === R_; )
      o--, l = e.codePointAt(o - 1);
  }
  return o > i ? e.slice(i, o) : "";
}
function L2(e, t) {
  const a = { type: "text", value: x2(String(t.value)) };
  return e.patch(t, a), e.applyData(t, a);
}
function D2(e, t) {
  const a = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, a), e.applyData(t, a);
}
const M2 = {
  blockquote: c2,
  break: d2,
  code: p2,
  delete: f2,
  emphasis: m2,
  footnoteReference: g2,
  heading: h2,
  html: b2,
  imageReference: E2,
  image: y2,
  inlineCode: T2,
  linkReference: S2,
  link: _2,
  listItem: A2,
  list: R2,
  paragraph: v2,
  // @ts-expect-error: root is different, but hard to type.
  root: C2,
  strong: w2,
  table: k2,
  tableCell: O2,
  tableRow: I2,
  text: L2,
  thematicBreak: D2,
  toml: Bl,
  yaml: Bl,
  definition: Bl,
  footnoteDefinition: Bl
};
function Bl() {
}
const M1 = -1, mu = 0, Ps = 1, eu = 2, Rf = 3, vf = 4, Cf = 5, wf = 6, U1 = 7, B1 = 8, C_ = typeof self == "object" ? self : globalThis, U2 = (e, t) => {
  const a = (o, l) => (e.set(l, o), o), i = (o) => {
    if (e.has(o))
      return e.get(o);
    const [l, c] = t[o];
    switch (l) {
      case mu:
      case M1:
        return a(c, o);
      case Ps: {
        const d = a([], o);
        for (const m of c)
          d.push(i(m));
        return d;
      }
      case eu: {
        const d = a({}, o);
        for (const [m, f] of c)
          d[i(m)] = i(f);
        return d;
      }
      case Rf:
        return a(new Date(c), o);
      case vf: {
        const { source: d, flags: m } = c;
        return a(new RegExp(d, m), o);
      }
      case Cf: {
        const d = a(/* @__PURE__ */ new Map(), o);
        for (const [m, f] of c)
          d.set(i(m), i(f));
        return d;
      }
      case wf: {
        const d = a(/* @__PURE__ */ new Set(), o);
        for (const m of c)
          d.add(i(m));
        return d;
      }
      case U1: {
        const { name: d, message: m } = c;
        return a(new C_[d](m), o);
      }
      case B1:
        return a(BigInt(c), o);
      case "BigInt":
        return a(Object(BigInt(c)), o);
      case "ArrayBuffer":
        return a(new Uint8Array(c).buffer, c);
      case "DataView": {
        const { buffer: d } = new Uint8Array(c);
        return a(new DataView(d), c);
      }
    }
    return a(new C_[l](c), o);
  };
  return i;
}, w_ = (e) => U2(/* @__PURE__ */ new Map(), e)(0), pi = "", { toString: B2 } = {}, { keys: F2 } = Object, Os = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [mu, t];
  const a = B2.call(e).slice(8, -1);
  switch (a) {
    case "Array":
      return [Ps, pi];
    case "Object":
      return [eu, pi];
    case "Date":
      return [Rf, pi];
    case "RegExp":
      return [vf, pi];
    case "Map":
      return [Cf, pi];
    case "Set":
      return [wf, pi];
    case "DataView":
      return [Ps, a];
  }
  return a.includes("Array") ? [Ps, a] : a.includes("Error") ? [U1, a] : [eu, a];
}, Fl = ([e, t]) => e === mu && (t === "function" || t === "symbol"), P2 = (e, t, a, i) => {
  const o = (c, d) => {
    const m = i.push(c) - 1;
    return a.set(d, m), m;
  }, l = (c) => {
    if (a.has(c))
      return a.get(c);
    let [d, m] = Os(c);
    switch (d) {
      case mu: {
        let b = c;
        switch (m) {
          case "bigint":
            d = B1, b = c.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + m);
            b = null;
            break;
          case "undefined":
            return o([M1], c);
        }
        return o([d, b], c);
      }
      case Ps: {
        if (m) {
          let T = c;
          return m === "DataView" ? T = new Uint8Array(c.buffer) : m === "ArrayBuffer" && (T = new Uint8Array(c)), o([m, [...T]], c);
        }
        const b = [], E = o([d, b], c);
        for (const T of c)
          b.push(l(T));
        return E;
      }
      case eu: {
        if (m)
          switch (m) {
            case "BigInt":
              return o([m, c.toString()], c);
            case "Boolean":
            case "Number":
            case "String":
              return o([m, c.valueOf()], c);
          }
        if (t && "toJSON" in c)
          return l(c.toJSON());
        const b = [], E = o([d, b], c);
        for (const T of F2(c))
          (e || !Fl(Os(c[T]))) && b.push([l(T), l(c[T])]);
        return E;
      }
      case Rf:
        return o([d, c.toISOString()], c);
      case vf: {
        const { source: b, flags: E } = c;
        return o([d, { source: b, flags: E }], c);
      }
      case Cf: {
        const b = [], E = o([d, b], c);
        for (const [T, S] of c)
          (e || !(Fl(Os(T)) || Fl(Os(S)))) && b.push([l(T), l(S)]);
        return E;
      }
      case wf: {
        const b = [], E = o([d, b], c);
        for (const T of c)
          (e || !Fl(Os(T))) && b.push(l(T));
        return E;
      }
    }
    const { message: f } = c;
    return o([d, { name: m, message: f }], c);
  };
  return l;
}, k_ = (e, { json: t, lossy: a } = {}) => {
  const i = [];
  return P2(!(t || a), !!t, /* @__PURE__ */ new Map(), i)(e), i;
}, hr = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? w_(k_(e, t)) : structuredClone(e)
) : (e, t) => w_(k_(e, t));
function H2(e, t) {
  const a = [{ type: "text", value: "" }];
  return t > 1 && a.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), a;
}
function z2(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function G2(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", a = e.options.footnoteBackContent || H2, i = e.options.footnoteBackLabel || z2, o = e.options.footnoteLabel || "Footnotes", l = e.options.footnoteLabelTagName || "h2", c = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, d = [];
  let m = -1;
  for (; ++m < e.footnoteOrder.length; ) {
    const f = e.footnoteById.get(
      e.footnoteOrder[m]
    );
    if (!f)
      continue;
    const b = e.all(f), E = String(f.identifier).toUpperCase(), T = _i(E.toLowerCase());
    let S = 0;
    const _ = [], k = e.footnoteCounts.get(E);
    for (; k !== void 0 && ++S <= k; ) {
      _.length > 0 && _.push({ type: "text", value: " " });
      let L = typeof a == "string" ? a : a(m, S);
      typeof L == "string" && (L = { type: "text", value: L }), _.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + T + (S > 1 ? "-" + S : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof i == "string" ? i : i(m, S),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(L) ? L : [L]
      });
    }
    const R = b[b.length - 1];
    if (R && R.type === "element" && R.tagName === "p") {
      const L = R.children[R.children.length - 1];
      L && L.type === "text" ? L.value += " " : R.children.push({ type: "text", value: " " }), R.children.push(..._);
    } else
      b.push(..._);
    const C = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + T },
      children: e.wrap(b, !0)
    };
    e.patch(f, C), d.push(C);
  }
  if (d.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: l,
          properties: {
            ...hr(c),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(d, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const gu = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return Y2;
    if (typeof e == "function")
      return hu(e);
    if (typeof e == "object")
      return Array.isArray(e) ? j2(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        $2(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return q2(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function j2(e) {
  const t = [];
  let a = -1;
  for (; ++a < e.length; )
    t[a] = gu(e[a]);
  return hu(i);
  function i(...o) {
    let l = -1;
    for (; ++l < t.length; )
      if (t[l].apply(this, o)) return !0;
    return !1;
  }
}
function $2(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return hu(a);
  function a(i) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      i
    );
    let l;
    for (l in e)
      if (o[l] !== t[l]) return !1;
    return !0;
  }
}
function q2(e) {
  return hu(t);
  function t(a) {
    return a && a.type === e;
  }
}
function hu(e) {
  return t;
  function t(a, i, o) {
    return !!(V2(a) && e.call(
      this,
      a,
      typeof i == "number" ? i : void 0,
      o || void 0
    ));
  }
}
function Y2() {
  return !0;
}
function V2(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const F1 = [], W2 = !0, Vp = !1, X2 = "skip";
function P1(e, t, a, i) {
  let o;
  typeof t == "function" && typeof a != "function" ? (i = a, a = t) : o = t;
  const l = gu(o), c = i ? -1 : 1;
  d(e, void 0, [])();
  function d(m, f, b) {
    const E = (
      /** @type {Record<string, unknown>} */
      m && typeof m == "object" ? m : {}
    );
    if (typeof E.type == "string") {
      const S = (
        // `hast`
        typeof E.tagName == "string" ? E.tagName : (
          // `xast`
          typeof E.name == "string" ? E.name : void 0
        )
      );
      Object.defineProperty(T, "name", {
        value: "node (" + (m.type + (S ? "<" + S + ">" : "")) + ")"
      });
    }
    return T;
    function T() {
      let S = F1, _, k, R;
      if ((!t || l(m, f, b[b.length - 1] || void 0)) && (S = K2(a(m, b)), S[0] === Vp))
        return S;
      if ("children" in m && m.children) {
        const C = (
          /** @type {UnistParent} */
          m
        );
        if (C.children && S[0] !== X2)
          for (k = (i ? C.children.length : -1) + c, R = b.concat(C); k > -1 && k < C.children.length; ) {
            const L = C.children[k];
            if (_ = d(L, k, R)(), _[0] === Vp)
              return _;
            k = typeof _[1] == "number" ? _[1] : k + c;
          }
      }
      return S;
    }
  }
}
function K2(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [W2, e] : e == null ? F1 : [e];
}
function bu(e, t, a, i) {
  let o, l, c;
  typeof t == "function" && typeof a != "function" ? (l = void 0, c = t, o = a) : (l = t, c = a, o = i), P1(e, l, d, o);
  function d(m, f) {
    const b = f[f.length - 1], E = b ? b.children.indexOf(m) : void 0;
    return c(m, E, b);
  }
}
const Wp = {}.hasOwnProperty, Z2 = {};
function Q2(e, t) {
  const a = t || Z2, i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = { ...M2, ...a.handlers }, d = {
    all: f,
    applyData: eL,
    definitionById: i,
    footnoteById: o,
    footnoteCounts: l,
    footnoteOrder: [],
    handlers: c,
    one: m,
    options: a,
    patch: J2,
    wrap: nL
  };
  return bu(e, function(b) {
    if (b.type === "definition" || b.type === "footnoteDefinition") {
      const E = b.type === "definition" ? i : o, T = String(b.identifier).toUpperCase();
      E.has(T) || E.set(T, b);
    }
  }), d;
  function m(b, E) {
    const T = b.type, S = d.handlers[T];
    if (Wp.call(d.handlers, T) && S)
      return S(d, b, E);
    if (d.options.passThrough && d.options.passThrough.includes(T)) {
      if ("children" in b) {
        const { children: k, ...R } = b, C = hr(R);
        return C.children = d.all(b), C;
      }
      return hr(b);
    }
    return (d.options.unknownHandler || tL)(d, b, E);
  }
  function f(b) {
    const E = [];
    if ("children" in b) {
      const T = b.children;
      let S = -1;
      for (; ++S < T.length; ) {
        const _ = d.one(T[S], b);
        if (_) {
          if (S && T[S - 1].type === "break" && (!Array.isArray(_) && _.type === "text" && (_.value = I_(_.value)), !Array.isArray(_) && _.type === "element")) {
            const k = _.children[0];
            k && k.type === "text" && (k.value = I_(k.value));
          }
          Array.isArray(_) ? E.push(..._) : E.push(_);
        }
      }
    }
    return E;
  }
}
function J2(e, t) {
  e.position && (t.position = m1(e));
}
function eL(e, t) {
  let a = t;
  if (e && e.data) {
    const i = e.data.hName, o = e.data.hChildren, l = e.data.hProperties;
    if (typeof i == "string")
      if (a.type === "element")
        a.tagName = i;
      else {
        const c = "children" in a ? a.children : [a];
        a = { type: "element", tagName: i, properties: {}, children: c };
      }
    a.type === "element" && l && Object.assign(a.properties, hr(l)), "children" in a && a.children && o !== null && o !== void 0 && (a.children = o);
  }
  return a;
}
function tL(e, t) {
  const a = t.data || {}, i = "value" in t && !(Wp.call(a, "hProperties") || Wp.call(a, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function nL(e, t) {
  const a = [];
  let i = -1;
  for (t && a.push({ type: "text", value: `
` }); ++i < e.length; )
    i && a.push({ type: "text", value: `
` }), a.push(e[i]);
  return t && e.length > 0 && a.push({ type: "text", value: `
` }), a;
}
function I_(e) {
  let t = 0, a = e.charCodeAt(t);
  for (; a === 9 || a === 32; )
    t++, a = e.charCodeAt(t);
  return e.slice(t);
}
function O_(e, t) {
  const a = Q2(e, t), i = a.one(e, void 0), o = G2(a), l = Array.isArray(i) ? { type: "root", children: i } : i || { type: "root", children: [] };
  return o && l.children.push({ type: "text", value: `
` }, o), l;
}
function aL(e, t) {
  return e && "run" in e ? async function(a, i) {
    const o = (
      /** @type {HastRoot} */
      O_(a, { file: i, ...t })
    );
    await e.run(o, i);
  } : function(a, i) {
    return (
      /** @type {HastRoot} */
      O_(a, { file: i, ...e || t })
    );
  };
}
function x_(e) {
  if (e)
    throw e;
}
var cp, L_;
function rL() {
  if (L_) return cp;
  L_ = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, a = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = function(f) {
    return typeof Array.isArray == "function" ? Array.isArray(f) : t.call(f) === "[object Array]";
  }, l = function(f) {
    if (!f || t.call(f) !== "[object Object]")
      return !1;
    var b = e.call(f, "constructor"), E = f.constructor && f.constructor.prototype && e.call(f.constructor.prototype, "isPrototypeOf");
    if (f.constructor && !b && !E)
      return !1;
    var T;
    for (T in f)
      ;
    return typeof T > "u" || e.call(f, T);
  }, c = function(f, b) {
    a && b.name === "__proto__" ? a(f, b.name, {
      enumerable: !0,
      configurable: !0,
      value: b.newValue,
      writable: !0
    }) : f[b.name] = b.newValue;
  }, d = function(f, b) {
    if (b === "__proto__")
      if (e.call(f, b)) {
        if (i)
          return i(f, b).value;
      } else return;
    return f[b];
  };
  return cp = function m() {
    var f, b, E, T, S, _, k = arguments[0], R = 1, C = arguments.length, L = !1;
    for (typeof k == "boolean" && (L = k, k = arguments[1] || {}, R = 2), (k == null || typeof k != "object" && typeof k != "function") && (k = {}); R < C; ++R)
      if (f = arguments[R], f != null)
        for (b in f)
          E = d(k, b), T = d(f, b), k !== T && (L && T && (l(T) || (S = o(T))) ? (S ? (S = !1, _ = E && o(E) ? E : []) : _ = E && l(E) ? E : {}, c(k, { name: b, newValue: m(L, _, T) })) : typeof T < "u" && c(k, { name: b, newValue: T }));
    return k;
  }, cp;
}
var iL = rL();
const dp = /* @__PURE__ */ iu(iL);
function Xp(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function sL() {
  const e = [], t = { run: a, use: i };
  return t;
  function a(...o) {
    let l = -1;
    const c = o.pop();
    if (typeof c != "function")
      throw new TypeError("Expected function as last argument, not " + c);
    d(null, ...o);
    function d(m, ...f) {
      const b = e[++l];
      let E = -1;
      if (m) {
        c(m);
        return;
      }
      for (; ++E < o.length; )
        (f[E] === null || f[E] === void 0) && (f[E] = o[E]);
      o = f, b ? oL(b, d)(...f) : c(null, ...f);
    }
  }
  function i(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function oL(e, t) {
  let a;
  return i;
  function i(...c) {
    const d = e.length > c.length;
    let m;
    d && c.push(o);
    try {
      m = e.apply(this, c);
    } catch (f) {
      const b = (
        /** @type {Error} */
        f
      );
      if (d && a)
        throw b;
      return o(b);
    }
    d || (m && m.then && typeof m.then == "function" ? m.then(l, o) : m instanceof Error ? o(m) : l(m));
  }
  function o(c, ...d) {
    a || (a = !0, t(c, ...d));
  }
  function l(c) {
    o(null, c);
  }
}
const Pn = { basename: lL, dirname: uL, extname: cL, join: dL, sep: "/" };
function lL(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  so(e);
  let a = 0, i = -1, o = e.length, l;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (l) {
          a = o + 1;
          break;
        }
      } else i < 0 && (l = !0, i = o + 1);
    return i < 0 ? "" : e.slice(a, i);
  }
  if (t === e)
    return "";
  let c = -1, d = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (l) {
        a = o + 1;
        break;
      }
    } else
      c < 0 && (l = !0, c = o + 1), d > -1 && (e.codePointAt(o) === t.codePointAt(d--) ? d < 0 && (i = o) : (d = -1, i = c));
  return a === i ? i = c : i < 0 && (i = e.length), e.slice(a, i);
}
function uL(e) {
  if (so(e), e.length === 0)
    return ".";
  let t = -1, a = e.length, i;
  for (; --a; )
    if (e.codePointAt(a) === 47) {
      if (i) {
        t = a;
        break;
      }
    } else i || (i = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function cL(e) {
  so(e);
  let t = e.length, a = -1, i = 0, o = -1, l = 0, c;
  for (; t--; ) {
    const d = e.codePointAt(t);
    if (d === 47) {
      if (c) {
        i = t + 1;
        break;
      }
      continue;
    }
    a < 0 && (c = !0, a = t + 1), d === 46 ? o < 0 ? o = t : l !== 1 && (l = 1) : o > -1 && (l = -1);
  }
  return o < 0 || a < 0 || // We saw a non-dot character immediately before the dot.
  l === 0 || // The (right-most) trimmed path component is exactly `..`.
  l === 1 && o === a - 1 && o === i + 1 ? "" : e.slice(o, a);
}
function dL(...e) {
  let t = -1, a;
  for (; ++t < e.length; )
    so(e[t]), e[t] && (a = a === void 0 ? e[t] : a + "/" + e[t]);
  return a === void 0 ? "." : pL(a);
}
function pL(e) {
  so(e);
  const t = e.codePointAt(0) === 47;
  let a = fL(e, !t);
  return a.length === 0 && !t && (a = "."), a.length > 0 && e.codePointAt(e.length - 1) === 47 && (a += "/"), t ? "/" + a : a;
}
function fL(e, t) {
  let a = "", i = 0, o = -1, l = 0, c = -1, d, m;
  for (; ++c <= e.length; ) {
    if (c < e.length)
      d = e.codePointAt(c);
    else {
      if (d === 47)
        break;
      d = 47;
    }
    if (d === 47) {
      if (!(o === c - 1 || l === 1)) if (o !== c - 1 && l === 2) {
        if (a.length < 2 || i !== 2 || a.codePointAt(a.length - 1) !== 46 || a.codePointAt(a.length - 2) !== 46) {
          if (a.length > 2) {
            if (m = a.lastIndexOf("/"), m !== a.length - 1) {
              m < 0 ? (a = "", i = 0) : (a = a.slice(0, m), i = a.length - 1 - a.lastIndexOf("/")), o = c, l = 0;
              continue;
            }
          } else if (a.length > 0) {
            a = "", i = 0, o = c, l = 0;
            continue;
          }
        }
        t && (a = a.length > 0 ? a + "/.." : "..", i = 2);
      } else
        a.length > 0 ? a += "/" + e.slice(o + 1, c) : a = e.slice(o + 1, c), i = c - o - 1;
      o = c, l = 0;
    } else d === 46 && l > -1 ? l++ : l = -1;
  }
  return a;
}
function so(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const mL = { cwd: gL };
function gL() {
  return "/";
}
function Kp(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function hL(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Kp(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return bL(e);
}
function bL(e) {
  if (e.hostname !== "") {
    const i = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw i.code = "ERR_INVALID_FILE_URL_HOST", i;
  }
  const t = e.pathname;
  let a = -1;
  for (; ++a < t.length; )
    if (t.codePointAt(a) === 37 && t.codePointAt(a + 1) === 50) {
      const i = t.codePointAt(a + 2);
      if (i === 70 || i === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const pp = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class H1 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let a;
    t ? Kp(t) ? a = { path: t } : typeof t == "string" || EL(t) ? a = { value: t } : a = t : a = {}, this.cwd = "cwd" in a ? "" : mL.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let i = -1;
    for (; ++i < pp.length; ) {
      const l = pp[i];
      l in a && a[l] !== void 0 && a[l] !== null && (this[l] = l === "history" ? [...a[l]] : a[l]);
    }
    let o;
    for (o in a)
      pp.includes(o) || (this[o] = a[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Pn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    mp(t, "basename"), fp(t, "basename"), this.path = Pn.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Pn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    D_(this.basename, "dirname"), this.path = Pn.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Pn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (fp(t, "extname"), D_(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Pn.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Kp(t) && (t = hL(t)), mp(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Pn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    mp(t, "stem"), fp(t, "stem"), this.path = Pn.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, a, i) {
    const o = this.message(t, a, i);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, a, i) {
    const o = this.message(t, a, i);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, a, i) {
    const o = new Mt(
      // @ts-expect-error: the overloads are fine.
      t,
      a,
      i
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function fp(e, t) {
  if (e && e.includes(Pn.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Pn.sep + "`"
    );
}
function mp(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function D_(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function EL(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const yL = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const i = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), o = i[e], l = function() {
      return o.apply(l, arguments);
    };
    return Object.setPrototypeOf(l, i), l;
  })
), TL = {}.hasOwnProperty;
class kf extends yL {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = sL();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new kf()
    );
    let a = -1;
    for (; ++a < this.attachers.length; ) {
      const i = this.attachers[a];
      t.use(...i);
    }
    return t.data(dp(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, a) {
    return typeof t == "string" ? arguments.length === 2 ? (bp("data", this.frozen), this.namespace[t] = a, this) : TL.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (bp("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [a, ...i] = this.attachers[this.freezeIndex];
      if (i[0] === !1)
        continue;
      i[0] === !0 && (i[0] = void 0);
      const o = a.call(t, ...i);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const a = Pl(t), i = this.parser || this.Parser;
    return gp("parse", i), i(String(a), a);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, a) {
    const i = this;
    return this.freeze(), gp("process", this.parser || this.Parser), hp("process", this.compiler || this.Compiler), a ? o(void 0, a) : new Promise(o);
    function o(l, c) {
      const d = Pl(t), m = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        i.parse(d)
      );
      i.run(m, d, function(b, E, T) {
        if (b || !E || !T)
          return f(b);
        const S = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          E
        ), _ = i.stringify(S, T);
        AL(_) ? T.value = _ : T.result = _, f(
          b,
          /** @type {VFileWithOutput<CompileResult>} */
          T
        );
      });
      function f(b, E) {
        b || !E ? c(b) : l ? l(E) : a(void 0, E);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let a = !1, i;
    return this.freeze(), gp("processSync", this.parser || this.Parser), hp("processSync", this.compiler || this.Compiler), this.process(t, o), U_("processSync", "process", a), i;
    function o(l, c) {
      a = !0, x_(l), i = c;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, a, i) {
    M_(t), this.freeze();
    const o = this.transformers;
    return !i && typeof a == "function" && (i = a, a = void 0), i ? l(void 0, i) : new Promise(l);
    function l(c, d) {
      const m = Pl(a);
      o.run(t, m, f);
      function f(b, E, T) {
        const S = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          E || t
        );
        b ? d(b) : c ? c(S) : i(void 0, S, T);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, a) {
    let i = !1, o;
    return this.run(t, a, l), U_("runSync", "run", i), o;
    function l(c, d) {
      x_(c), o = d, i = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, a) {
    this.freeze();
    const i = Pl(a), o = this.compiler || this.Compiler;
    return hp("stringify", o), M_(t), o(t, i);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...a) {
    const i = this.attachers, o = this.namespace;
    if (bp("use", this.frozen), t != null) if (typeof t == "function")
      m(t, a);
    else if (typeof t == "object")
      Array.isArray(t) ? d(t) : c(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function l(f) {
      if (typeof f == "function")
        m(f, []);
      else if (typeof f == "object")
        if (Array.isArray(f)) {
          const [b, ...E] = (
            /** @type {PluginTuple<Array<unknown>>} */
            f
          );
          m(b, E);
        } else
          c(f);
      else
        throw new TypeError("Expected usable value, not `" + f + "`");
    }
    function c(f) {
      if (!("plugins" in f) && !("settings" in f))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      d(f.plugins), f.settings && (o.settings = dp(!0, o.settings, f.settings));
    }
    function d(f) {
      let b = -1;
      if (f != null) if (Array.isArray(f))
        for (; ++b < f.length; ) {
          const E = f[b];
          l(E);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + f + "`");
    }
    function m(f, b) {
      let E = -1, T = -1;
      for (; ++E < i.length; )
        if (i[E][0] === f) {
          T = E;
          break;
        }
      if (T === -1)
        i.push([f, ...b]);
      else if (b.length > 0) {
        let [S, ..._] = b;
        const k = i[T][1];
        Xp(k) && Xp(S) && (S = dp(!0, k, S)), i[T] = [f, S, ..._];
      }
    }
  }
}
const SL = new kf().freeze();
function gp(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function hp(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function bp(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function M_(e) {
  if (!Xp(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function U_(e, t, a) {
  if (!a)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Pl(e) {
  return _L(e) ? e : new H1(e);
}
function _L(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function AL(e) {
  return typeof e == "string" || NL(e);
}
function NL(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const RL = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", B_ = [], F_ = { allowDangerousHtml: !0 }, vL = /^(https?|ircs?|mailto|xmpp)$/i, CL = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function wL(e) {
  const t = kL(e), a = IL(e);
  return OL(t.runSync(t.parse(a), a), e);
}
function kL(e) {
  const t = e.rehypePlugins || B_, a = e.remarkPlugins || B_, i = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...F_ } : F_;
  return SL().use(u2).use(a).use(aL, i).use(t);
}
function IL(e) {
  const t = e.children || "", a = new H1();
  return typeof t == "string" && (a.value = t), a;
}
function OL(e, t) {
  const a = t.allowedElements, i = t.allowElement, o = t.components, l = t.disallowedElements, c = t.skipHtml, d = t.unwrapDisallowed, m = t.urlTransform || xL;
  for (const b of CL)
    Object.hasOwn(t, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + RL + b.id, void 0);
  return bu(e, f), YI(e, {
    Fragment: B.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: B.jsx,
    jsxs: B.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function f(b, E, T) {
    if (b.type === "raw" && T && typeof E == "number")
      return c ? T.children.splice(E, 1) : T.children[E] = { type: "text", value: b.value }, E;
    if (b.type === "element") {
      let S;
      for (S in op)
        if (Object.hasOwn(op, S) && Object.hasOwn(b.properties, S)) {
          const _ = b.properties[S], k = op[S];
          (k === null || k.includes(b.tagName)) && (b.properties[S] = m(String(_ || ""), S, b));
        }
    }
    if (b.type === "element") {
      let S = a ? !a.includes(b.tagName) : l ? l.includes(b.tagName) : !1;
      if (!S && i && typeof E == "number" && (S = !i(b, E, T)), S && T && typeof E == "number")
        return d && b.children ? T.children.splice(E, 1, ...b.children) : T.children.splice(E, 1), E;
    }
  }
}
function xL(e) {
  const t = e.indexOf(":"), a = e.indexOf("?"), i = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || a !== -1 && t > a || i !== -1 && t > i || // It is a protocol, it should be allowed.
    vL.test(e.slice(0, t)) ? e : ""
  );
}
function P_(e, t) {
  const a = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let i = 0, o = a.indexOf(t);
  for (; o !== -1; )
    i++, o = a.indexOf(t, o + t.length);
  return i;
}
function LL(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function DL(e, t, a) {
  const o = gu((a || {}).ignore || []), l = ML(t);
  let c = -1;
  for (; ++c < l.length; )
    P1(e, "text", d);
  function d(f, b) {
    let E = -1, T;
    for (; ++E < b.length; ) {
      const S = b[E], _ = T ? T.children : void 0;
      if (o(
        S,
        _ ? _.indexOf(S) : void 0,
        T
      ))
        return;
      T = S;
    }
    if (T)
      return m(f, b);
  }
  function m(f, b) {
    const E = b[b.length - 1], T = l[c][0], S = l[c][1];
    let _ = 0;
    const R = E.children.indexOf(f);
    let C = !1, L = [];
    T.lastIndex = 0;
    let x = T.exec(f.value);
    for (; x; ) {
      const Y = x.index, q = {
        index: x.index,
        input: x.input,
        stack: [...b, f]
      };
      let D = S(...x, q);
      if (typeof D == "string" && (D = D.length > 0 ? { type: "text", value: D } : void 0), D === !1 ? T.lastIndex = Y + 1 : (_ !== Y && L.push({
        type: "text",
        value: f.value.slice(_, Y)
      }), Array.isArray(D) ? L.push(...D) : D && L.push(D), _ = Y + x[0].length, C = !0), !T.global)
        break;
      x = T.exec(f.value);
    }
    return C ? (_ < f.value.length && L.push({ type: "text", value: f.value.slice(_) }), E.children.splice(R, 1, ...L)) : L = [f], R + L.length;
  }
}
function ML(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const a = !e[0] || Array.isArray(e[0]) ? e : [e];
  let i = -1;
  for (; ++i < a.length; ) {
    const o = a[i];
    t.push([UL(o[0]), BL(o[1])]);
  }
  return t;
}
function UL(e) {
  return typeof e == "string" ? new RegExp(LL(e), "g") : e;
}
function BL(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Ep = "phrasing", yp = ["autolink", "link", "image", "label"];
function FL() {
  return {
    transforms: [qL],
    enter: {
      literalAutolink: HL,
      literalAutolinkEmail: Tp,
      literalAutolinkHttp: Tp,
      literalAutolinkWww: Tp
    },
    exit: {
      literalAutolink: $L,
      literalAutolinkEmail: jL,
      literalAutolinkHttp: zL,
      literalAutolinkWww: GL
    }
  };
}
function PL() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Ep,
        notInConstruct: yp
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Ep,
        notInConstruct: yp
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Ep,
        notInConstruct: yp
      }
    ]
  };
}
function HL(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Tp(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function zL(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function GL(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function jL(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function $L(e) {
  this.exit(e);
}
function qL(e) {
  DL(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, YL],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), VL]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function YL(e, t, a, i, o) {
  let l = "";
  if (!z1(o) || (/^w/i.test(t) && (a = t + a, t = "", l = "http://"), !WL(a)))
    return !1;
  const c = XL(a + i);
  if (!c[0]) return !1;
  const d = {
    type: "link",
    title: null,
    url: l + t + c[0],
    children: [{ type: "text", value: t + c[0] }]
  };
  return c[1] ? [d, { type: "text", value: c[1] }] : d;
}
function VL(e, t, a, i) {
  return (
    // Not an expected previous character.
    !z1(i, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(a) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + a,
      children: [{ type: "text", value: t + "@" + a }]
    }
  );
}
function WL(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function XL(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let a = t[0], i = a.indexOf(")");
  const o = P_(e, "(");
  let l = P_(e, ")");
  for (; i !== -1 && o > l; )
    e += a.slice(0, i + 1), a = a.slice(i + 1), i = a.indexOf(")"), l++;
  return [e, a];
}
function z1(e, t) {
  const a = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || gr(a) || pu(a)) && // If its an email, the previous character should not be a slash.
  (!t || a !== 47);
}
G1.peek = rD;
function KL() {
  this.buffer();
}
function ZL(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function QL() {
  this.buffer();
}
function JL(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function eD(e) {
  const t = this.resume(), a = this.stack[this.stack.length - 1];
  a.type, a.identifier = On(
    this.sliceSerialize(e)
  ).toLowerCase(), a.label = t;
}
function tD(e) {
  this.exit(e);
}
function nD(e) {
  const t = this.resume(), a = this.stack[this.stack.length - 1];
  a.type, a.identifier = On(
    this.sliceSerialize(e)
  ).toLowerCase(), a.label = t;
}
function aD(e) {
  this.exit(e);
}
function rD() {
  return "[";
}
function G1(e, t, a, i) {
  const o = a.createTracker(i);
  let l = o.move("[^");
  const c = a.enter("footnoteReference"), d = a.enter("reference");
  return l += o.move(
    a.safe(a.associationId(e), { after: "]", before: l })
  ), d(), c(), l += o.move("]"), l;
}
function iD() {
  return {
    enter: {
      gfmFootnoteCallString: KL,
      gfmFootnoteCall: ZL,
      gfmFootnoteDefinitionLabelString: QL,
      gfmFootnoteDefinition: JL
    },
    exit: {
      gfmFootnoteCallString: eD,
      gfmFootnoteCall: tD,
      gfmFootnoteDefinitionLabelString: nD,
      gfmFootnoteDefinition: aD
    }
  };
}
function sD(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: a, footnoteReference: G1 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function a(i, o, l, c) {
    const d = l.createTracker(c);
    let m = d.move("[^");
    const f = l.enter("footnoteDefinition"), b = l.enter("label");
    return m += d.move(
      l.safe(l.associationId(i), { before: m, after: "]" })
    ), b(), m += d.move("]:"), i.children && i.children.length > 0 && (d.shift(4), m += d.move(
      (t ? `
` : " ") + l.indentLines(
        l.containerFlow(i, d.current()),
        t ? j1 : oD
      )
    )), f(), m;
  }
}
function oD(e, t, a) {
  return t === 0 ? e : j1(e, t, a);
}
function j1(e, t, a) {
  return (a ? "" : "    ") + e;
}
const lD = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
$1.peek = fD;
function uD() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: dD },
    exit: { strikethrough: pD }
  };
}
function cD() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: lD
      }
    ],
    handlers: { delete: $1 }
  };
}
function dD(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function pD(e) {
  this.exit(e);
}
function $1(e, t, a, i) {
  const o = a.createTracker(i), l = a.enter("strikethrough");
  let c = o.move("~~");
  return c += a.containerPhrasing(e, {
    ...o.current(),
    before: c,
    after: "~"
  }), c += o.move("~~"), l(), c;
}
function fD() {
  return "~";
}
function mD(e) {
  return e.length;
}
function gD(e, t) {
  const a = t || {}, i = (a.align || []).concat(), o = a.stringLength || mD, l = [], c = [], d = [], m = [];
  let f = 0, b = -1;
  for (; ++b < e.length; ) {
    const k = [], R = [];
    let C = -1;
    for (e[b].length > f && (f = e[b].length); ++C < e[b].length; ) {
      const L = hD(e[b][C]);
      if (a.alignDelimiters !== !1) {
        const x = o(L);
        R[C] = x, (m[C] === void 0 || x > m[C]) && (m[C] = x);
      }
      k.push(L);
    }
    c[b] = k, d[b] = R;
  }
  let E = -1;
  if (typeof i == "object" && "length" in i)
    for (; ++E < f; )
      l[E] = H_(i[E]);
  else {
    const k = H_(i);
    for (; ++E < f; )
      l[E] = k;
  }
  E = -1;
  const T = [], S = [];
  for (; ++E < f; ) {
    const k = l[E];
    let R = "", C = "";
    k === 99 ? (R = ":", C = ":") : k === 108 ? R = ":" : k === 114 && (C = ":");
    let L = a.alignDelimiters === !1 ? 1 : Math.max(
      1,
      m[E] - R.length - C.length
    );
    const x = R + "-".repeat(L) + C;
    a.alignDelimiters !== !1 && (L = R.length + L + C.length, L > m[E] && (m[E] = L), S[E] = L), T[E] = x;
  }
  c.splice(1, 0, T), d.splice(1, 0, S), b = -1;
  const _ = [];
  for (; ++b < c.length; ) {
    const k = c[b], R = d[b];
    E = -1;
    const C = [];
    for (; ++E < f; ) {
      const L = k[E] || "";
      let x = "", Y = "";
      if (a.alignDelimiters !== !1) {
        const q = m[E] - (R[E] || 0), D = l[E];
        D === 114 ? x = " ".repeat(q) : D === 99 ? q % 2 ? (x = " ".repeat(q / 2 + 0.5), Y = " ".repeat(q / 2 - 0.5)) : (x = " ".repeat(q / 2), Y = x) : Y = " ".repeat(q);
      }
      a.delimiterStart !== !1 && !E && C.push("|"), a.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(a.alignDelimiters === !1 && L === "") && (a.delimiterStart !== !1 || E) && C.push(" "), a.alignDelimiters !== !1 && C.push(x), C.push(L), a.alignDelimiters !== !1 && C.push(Y), a.padding !== !1 && C.push(" "), (a.delimiterEnd !== !1 || E !== f - 1) && C.push("|");
    }
    _.push(
      a.delimiterEnd === !1 ? C.join("").replace(/ +$/, "") : C.join("")
    );
  }
  return _.join(`
`);
}
function hD(e) {
  return e == null ? "" : String(e);
}
function H_(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const z_ = {}.hasOwnProperty;
function q1(e, t) {
  const a = t || {};
  function i(o, ...l) {
    let c = i.invalid;
    const d = i.handlers;
    if (o && z_.call(o, e)) {
      const m = String(o[e]);
      c = z_.call(d, m) ? d[m] : i.unknown;
    }
    if (c)
      return c.call(this, o, ...l);
  }
  return i.handlers = a.handlers || {}, i.invalid = a.invalid, i.unknown = a.unknown, i;
}
function bD(e, t, a, i) {
  const o = a.enter("blockquote"), l = a.createTracker(i);
  l.move("> "), l.shift(2);
  const c = a.indentLines(
    a.containerFlow(e, l.current()),
    ED
  );
  return o(), c;
}
function ED(e, t, a) {
  return ">" + (a ? "" : " ") + e;
}
function yD(e, t) {
  return G_(e, t.inConstruct, !0) && !G_(e, t.notInConstruct, !1);
}
function G_(e, t, a) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return a;
  let i = -1;
  for (; ++i < t.length; )
    if (e.includes(t[i]))
      return !0;
  return !1;
}
function j_(e, t, a, i) {
  let o = -1;
  for (; ++o < a.unsafe.length; )
    if (a.unsafe[o].character === `
` && yD(a.stack, a.unsafe[o]))
      return /[ \t]/.test(i.before) ? "" : " ";
  return `\\
`;
}
function TD(e, t) {
  const a = String(e);
  let i = a.indexOf(t), o = i, l = 0, c = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; i !== -1; )
    i === o ? ++l > c && (c = l) : l = 1, o = i + t.length, i = a.indexOf(t, o);
  return c;
}
function SD(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function _D(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function AD(e, t, a, i) {
  const o = _D(a), l = e.value || "", c = o === "`" ? "GraveAccent" : "Tilde";
  if (SD(e, a)) {
    const E = a.enter("codeIndented"), T = a.indentLines(l, ND);
    return E(), T;
  }
  const d = a.createTracker(i), m = o.repeat(Math.max(TD(l, o) + 1, 3)), f = a.enter("codeFenced");
  let b = d.move(m);
  if (e.lang) {
    const E = a.enter(`codeFencedLang${c}`);
    b += d.move(
      a.safe(e.lang, {
        before: b,
        after: " ",
        encode: ["`"],
        ...d.current()
      })
    ), E();
  }
  if (e.lang && e.meta) {
    const E = a.enter(`codeFencedMeta${c}`);
    b += d.move(" "), b += d.move(
      a.safe(e.meta, {
        before: b,
        after: `
`,
        encode: ["`"],
        ...d.current()
      })
    ), E();
  }
  return b += d.move(`
`), l && (b += d.move(l + `
`)), b += d.move(m), f(), b;
}
function ND(e, t, a) {
  return (a ? "" : "    ") + e;
}
function If(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function RD(e, t, a, i) {
  const o = If(a), l = o === '"' ? "Quote" : "Apostrophe", c = a.enter("definition");
  let d = a.enter("label");
  const m = a.createTracker(i);
  let f = m.move("[");
  return f += m.move(
    a.safe(a.associationId(e), {
      before: f,
      after: "]",
      ...m.current()
    })
  ), f += m.move("]: "), d(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = a.enter("destinationLiteral"), f += m.move("<"), f += m.move(
    a.safe(e.url, { before: f, after: ">", ...m.current() })
  ), f += m.move(">")) : (d = a.enter("destinationRaw"), f += m.move(
    a.safe(e.url, {
      before: f,
      after: e.title ? " " : `
`,
      ...m.current()
    })
  )), d(), e.title && (d = a.enter(`title${l}`), f += m.move(" " + o), f += m.move(
    a.safe(e.title, {
      before: f,
      after: o,
      ...m.current()
    })
  ), f += m.move(o), d()), c(), f;
}
function vD(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Ks(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function tu(e, t, a) {
  const i = bi(e), o = bi(t);
  return i === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    a === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : i === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Y1.peek = CD;
function Y1(e, t, a, i) {
  const o = vD(a), l = a.enter("emphasis"), c = a.createTracker(i), d = c.move(o);
  let m = c.move(
    a.containerPhrasing(e, {
      after: o,
      before: d,
      ...c.current()
    })
  );
  const f = m.charCodeAt(0), b = tu(
    i.before.charCodeAt(i.before.length - 1),
    f,
    o
  );
  b.inside && (m = Ks(f) + m.slice(1));
  const E = m.charCodeAt(m.length - 1), T = tu(i.after.charCodeAt(0), E, o);
  T.inside && (m = m.slice(0, -1) + Ks(E));
  const S = c.move(o);
  return l(), a.attentionEncodeSurroundingInfo = {
    after: T.outside,
    before: b.outside
  }, d + m + S;
}
function CD(e, t, a) {
  return a.options.emphasis || "*";
}
function wD(e, t) {
  let a = !1;
  return bu(e, function(i) {
    if ("value" in i && /\r?\n|\r/.test(i.value) || i.type === "break")
      return a = !0, Vp;
  }), !!((!e.depth || e.depth < 3) && Af(e) && (t.options.setext || a));
}
function kD(e, t, a, i) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), l = a.createTracker(i);
  if (wD(e, a)) {
    const b = a.enter("headingSetext"), E = a.enter("phrasing"), T = a.containerPhrasing(e, {
      ...l.current(),
      before: `
`,
      after: `
`
    });
    return E(), b(), T + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      T.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(T.lastIndexOf("\r"), T.lastIndexOf(`
`)) + 1)
    );
  }
  const c = "#".repeat(o), d = a.enter("headingAtx"), m = a.enter("phrasing");
  l.move(c + " ");
  let f = a.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...l.current()
  });
  return /^[\t ]/.test(f) && (f = Ks(f.charCodeAt(0)) + f.slice(1)), f = f ? c + " " + f : c, a.options.closeAtx && (f += " " + c), m(), d(), f;
}
V1.peek = ID;
function V1(e) {
  return e.value || "";
}
function ID() {
  return "<";
}
W1.peek = OD;
function W1(e, t, a, i) {
  const o = If(a), l = o === '"' ? "Quote" : "Apostrophe", c = a.enter("image");
  let d = a.enter("label");
  const m = a.createTracker(i);
  let f = m.move("![");
  return f += m.move(
    a.safe(e.alt, { before: f, after: "]", ...m.current() })
  ), f += m.move("]("), d(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = a.enter("destinationLiteral"), f += m.move("<"), f += m.move(
    a.safe(e.url, { before: f, after: ">", ...m.current() })
  ), f += m.move(">")) : (d = a.enter("destinationRaw"), f += m.move(
    a.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...m.current()
    })
  )), d(), e.title && (d = a.enter(`title${l}`), f += m.move(" " + o), f += m.move(
    a.safe(e.title, {
      before: f,
      after: o,
      ...m.current()
    })
  ), f += m.move(o), d()), f += m.move(")"), c(), f;
}
function OD() {
  return "!";
}
X1.peek = xD;
function X1(e, t, a, i) {
  const o = e.referenceType, l = a.enter("imageReference");
  let c = a.enter("label");
  const d = a.createTracker(i);
  let m = d.move("![");
  const f = a.safe(e.alt, {
    before: m,
    after: "]",
    ...d.current()
  });
  m += d.move(f + "]["), c();
  const b = a.stack;
  a.stack = [], c = a.enter("reference");
  const E = a.safe(a.associationId(e), {
    before: m,
    after: "]",
    ...d.current()
  });
  return c(), a.stack = b, l(), o === "full" || !f || f !== E ? m += d.move(E + "]") : o === "shortcut" ? m = m.slice(0, -1) : m += d.move("]"), m;
}
function xD() {
  return "!";
}
K1.peek = LD;
function K1(e, t, a) {
  let i = e.value || "", o = "`", l = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(i); )
    o += "`";
  for (/[^ \r\n]/.test(i) && (/^[ \r\n]/.test(i) && /[ \r\n]$/.test(i) || /^`|`$/.test(i)) && (i = " " + i + " "); ++l < a.unsafe.length; ) {
    const c = a.unsafe[l], d = a.compilePattern(c);
    let m;
    if (c.atBreak)
      for (; m = d.exec(i); ) {
        let f = m.index;
        i.charCodeAt(f) === 10 && i.charCodeAt(f - 1) === 13 && f--, i = i.slice(0, f) + " " + i.slice(m.index + 1);
      }
  }
  return o + i + o;
}
function LD() {
  return "`";
}
function Z1(e, t) {
  const a = Af(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (a === e.url || "mailto:" + a === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
Q1.peek = DD;
function Q1(e, t, a, i) {
  const o = If(a), l = o === '"' ? "Quote" : "Apostrophe", c = a.createTracker(i);
  let d, m;
  if (Z1(e, a)) {
    const b = a.stack;
    a.stack = [], d = a.enter("autolink");
    let E = c.move("<");
    return E += c.move(
      a.containerPhrasing(e, {
        before: E,
        after: ">",
        ...c.current()
      })
    ), E += c.move(">"), d(), a.stack = b, E;
  }
  d = a.enter("link"), m = a.enter("label");
  let f = c.move("[");
  return f += c.move(
    a.containerPhrasing(e, {
      before: f,
      after: "](",
      ...c.current()
    })
  ), f += c.move("]("), m(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (m = a.enter("destinationLiteral"), f += c.move("<"), f += c.move(
    a.safe(e.url, { before: f, after: ">", ...c.current() })
  ), f += c.move(">")) : (m = a.enter("destinationRaw"), f += c.move(
    a.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), m(), e.title && (m = a.enter(`title${l}`), f += c.move(" " + o), f += c.move(
    a.safe(e.title, {
      before: f,
      after: o,
      ...c.current()
    })
  ), f += c.move(o), m()), f += c.move(")"), d(), f;
}
function DD(e, t, a) {
  return Z1(e, a) ? "<" : "[";
}
J1.peek = MD;
function J1(e, t, a, i) {
  const o = e.referenceType, l = a.enter("linkReference");
  let c = a.enter("label");
  const d = a.createTracker(i);
  let m = d.move("[");
  const f = a.containerPhrasing(e, {
    before: m,
    after: "]",
    ...d.current()
  });
  m += d.move(f + "]["), c();
  const b = a.stack;
  a.stack = [], c = a.enter("reference");
  const E = a.safe(a.associationId(e), {
    before: m,
    after: "]",
    ...d.current()
  });
  return c(), a.stack = b, l(), o === "full" || !f || f !== E ? m += d.move(E + "]") : o === "shortcut" ? m = m.slice(0, -1) : m += d.move("]"), m;
}
function MD() {
  return "[";
}
function Of(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function UD(e) {
  const t = Of(e), a = e.options.bulletOther;
  if (!a)
    return t === "*" ? "-" : "*";
  if (a !== "*" && a !== "+" && a !== "-")
    throw new Error(
      "Cannot serialize items with `" + a + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (a === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + a + "`) to be different"
    );
  return a;
}
function BD(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function eN(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function FD(e, t, a, i) {
  const o = a.enter("list"), l = a.bulletCurrent;
  let c = e.ordered ? BD(a) : Of(a);
  const d = e.ordered ? c === "." ? ")" : "." : UD(a);
  let m = t && a.bulletLastUsed ? c === a.bulletLastUsed : !1;
  if (!e.ordered) {
    const b = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (c === "*" || c === "-") && // Empty first list item:
      b && (!b.children || !b.children[0]) && // Directly in two other list items:
      a.stack[a.stack.length - 1] === "list" && a.stack[a.stack.length - 2] === "listItem" && a.stack[a.stack.length - 3] === "list" && a.stack[a.stack.length - 4] === "listItem" && // That are each the first child.
      a.indexStack[a.indexStack.length - 1] === 0 && a.indexStack[a.indexStack.length - 2] === 0 && a.indexStack[a.indexStack.length - 3] === 0 && (m = !0), eN(a) === c && b
    ) {
      let E = -1;
      for (; ++E < e.children.length; ) {
        const T = e.children[E];
        if (T && T.type === "listItem" && T.children && T.children[0] && T.children[0].type === "thematicBreak") {
          m = !0;
          break;
        }
      }
    }
  }
  m && (c = d), a.bulletCurrent = c;
  const f = a.containerFlow(e, i);
  return a.bulletLastUsed = c, a.bulletCurrent = l, o(), f;
}
function PD(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function HD(e, t, a, i) {
  const o = PD(a);
  let l = a.bulletCurrent || Of(a);
  t && t.type === "list" && t.ordered && (l = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (a.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + l);
  let c = l.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (c = Math.ceil(c / 4) * 4);
  const d = a.createTracker(i);
  d.move(l + " ".repeat(c - l.length)), d.shift(c);
  const m = a.enter("listItem"), f = a.indentLines(
    a.containerFlow(e, d.current()),
    b
  );
  return m(), f;
  function b(E, T, S) {
    return T ? (S ? "" : " ".repeat(c)) + E : (S ? l : l + " ".repeat(c - l.length)) + E;
  }
}
function zD(e, t, a, i) {
  const o = a.enter("paragraph"), l = a.enter("phrasing"), c = a.containerPhrasing(e, i);
  return l(), o(), c;
}
const GD = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  gu([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function jD(e, t, a, i) {
  return (e.children.some(function(c) {
    return GD(c);
  }) ? a.containerPhrasing : a.containerFlow).call(a, e, i);
}
function $D(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
tN.peek = qD;
function tN(e, t, a, i) {
  const o = $D(a), l = a.enter("strong"), c = a.createTracker(i), d = c.move(o + o);
  let m = c.move(
    a.containerPhrasing(e, {
      after: o,
      before: d,
      ...c.current()
    })
  );
  const f = m.charCodeAt(0), b = tu(
    i.before.charCodeAt(i.before.length - 1),
    f,
    o
  );
  b.inside && (m = Ks(f) + m.slice(1));
  const E = m.charCodeAt(m.length - 1), T = tu(i.after.charCodeAt(0), E, o);
  T.inside && (m = m.slice(0, -1) + Ks(E));
  const S = c.move(o + o);
  return l(), a.attentionEncodeSurroundingInfo = {
    after: T.outside,
    before: b.outside
  }, d + m + S;
}
function qD(e, t, a) {
  return a.options.strong || "*";
}
function YD(e, t, a, i) {
  return a.safe(e.value, i);
}
function VD(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function WD(e, t, a) {
  const i = (eN(a) + (a.options.ruleSpaces ? " " : "")).repeat(VD(a));
  return a.options.ruleSpaces ? i.slice(0, -1) : i;
}
const nN = {
  blockquote: bD,
  break: j_,
  code: AD,
  definition: RD,
  emphasis: Y1,
  hardBreak: j_,
  heading: kD,
  html: V1,
  image: W1,
  imageReference: X1,
  inlineCode: K1,
  link: Q1,
  linkReference: J1,
  list: FD,
  listItem: HD,
  paragraph: zD,
  root: jD,
  strong: tN,
  text: YD,
  thematicBreak: WD
};
function XD() {
  return {
    enter: {
      table: KD,
      tableData: $_,
      tableHeader: $_,
      tableRow: QD
    },
    exit: {
      codeText: JD,
      table: ZD,
      tableData: Sp,
      tableHeader: Sp,
      tableRow: Sp
    }
  };
}
function KD(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(a) {
        return a === "none" ? null : a;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function ZD(e) {
  this.exit(e), this.data.inTable = void 0;
}
function QD(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Sp(e) {
  this.exit(e);
}
function $_(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function JD(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, e3));
  const a = this.stack[this.stack.length - 1];
  a.type, a.value = t, this.exit(e);
}
function e3(e, t) {
  return t === "|" ? t : e;
}
function t3(e) {
  const t = e || {}, a = t.tableCellPadding, i = t.tablePipeAlign, o = t.stringLength, l = a ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: T,
      table: c,
      tableCell: m,
      tableRow: d
    }
  };
  function c(S, _, k, R) {
    return f(b(S, k, R), S.align);
  }
  function d(S, _, k, R) {
    const C = E(S, k, R), L = f([C]);
    return L.slice(0, L.indexOf(`
`));
  }
  function m(S, _, k, R) {
    const C = k.enter("tableCell"), L = k.enter("phrasing"), x = k.containerPhrasing(S, {
      ...R,
      before: l,
      after: l
    });
    return L(), C(), x;
  }
  function f(S, _) {
    return gD(S, {
      align: _,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: i,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: a,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function b(S, _, k) {
    const R = S.children;
    let C = -1;
    const L = [], x = _.enter("table");
    for (; ++C < R.length; )
      L[C] = E(R[C], _, k);
    return x(), L;
  }
  function E(S, _, k) {
    const R = S.children;
    let C = -1;
    const L = [], x = _.enter("tableRow");
    for (; ++C < R.length; )
      L[C] = m(R[C], S, _, k);
    return x(), L;
  }
  function T(S, _, k) {
    let R = nN.inlineCode(S, _, k);
    return k.stack.includes("tableCell") && (R = R.replace(/\|/g, "\\$&")), R;
  }
}
function n3() {
  return {
    exit: {
      taskListCheckValueChecked: q_,
      taskListCheckValueUnchecked: q_,
      paragraph: r3
    }
  };
}
function a3() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: i3 }
  };
}
function q_(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function r3(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const a = this.stack[this.stack.length - 1];
    a.type;
    const i = a.children[0];
    if (i && i.type === "text") {
      const o = t.children;
      let l = -1, c;
      for (; ++l < o.length; ) {
        const d = o[l];
        if (d.type === "paragraph") {
          c = d;
          break;
        }
      }
      c === a && (i.value = i.value.slice(1), i.value.length === 0 ? a.children.shift() : a.position && i.position && typeof i.position.start.offset == "number" && (i.position.start.column++, i.position.start.offset++, a.position.start = Object.assign({}, i.position.start)));
    }
  }
  this.exit(e);
}
function i3(e, t, a, i) {
  const o = e.children[0], l = typeof e.checked == "boolean" && o && o.type === "paragraph", c = "[" + (e.checked ? "x" : " ") + "] ", d = a.createTracker(i);
  l && d.move(c);
  let m = nN.listItem(e, t, a, {
    ...i,
    ...d.current()
  });
  return l && (m = m.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, f)), m;
  function f(b) {
    return b + c;
  }
}
function s3() {
  return [
    FL(),
    iD(),
    uD(),
    XD(),
    n3()
  ];
}
function o3(e) {
  return {
    extensions: [
      PL(),
      sD(e),
      cD(),
      t3(e),
      a3()
    ]
  };
}
const l3 = {
  tokenize: m3,
  partial: !0
}, aN = {
  tokenize: g3,
  partial: !0
}, rN = {
  tokenize: h3,
  partial: !0
}, iN = {
  tokenize: b3,
  partial: !0
}, u3 = {
  tokenize: E3,
  partial: !0
}, sN = {
  name: "wwwAutolink",
  tokenize: p3,
  previous: lN
}, oN = {
  name: "protocolAutolink",
  tokenize: f3,
  previous: uN
}, fa = {
  name: "emailAutolink",
  tokenize: d3,
  previous: cN
}, Gn = {};
function c3() {
  return {
    text: Gn
  };
}
let dr = 48;
for (; dr < 123; )
  Gn[dr] = fa, dr++, dr === 58 ? dr = 65 : dr === 91 && (dr = 97);
Gn[43] = fa;
Gn[45] = fa;
Gn[46] = fa;
Gn[95] = fa;
Gn[72] = [fa, oN];
Gn[104] = [fa, oN];
Gn[87] = [fa, sN];
Gn[119] = [fa, sN];
function d3(e, t, a) {
  const i = this;
  let o, l;
  return c;
  function c(E) {
    return !Zp(E) || !cN.call(i, i.previous) || xf(i.events) ? a(E) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), d(E));
  }
  function d(E) {
    return Zp(E) ? (e.consume(E), d) : E === 64 ? (e.consume(E), m) : a(E);
  }
  function m(E) {
    return E === 46 ? e.check(u3, b, f)(E) : E === 45 || E === 95 || Dt(E) ? (l = !0, e.consume(E), m) : b(E);
  }
  function f(E) {
    return e.consume(E), o = !0, m;
  }
  function b(E) {
    return l && o && Gt(i.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(E)) : a(E);
  }
}
function p3(e, t, a) {
  const i = this;
  return o;
  function o(c) {
    return c !== 87 && c !== 119 || !lN.call(i, i.previous) || xf(i.events) ? a(c) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(l3, e.attempt(aN, e.attempt(rN, l), a), a)(c));
  }
  function l(c) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(c);
  }
}
function f3(e, t, a) {
  const i = this;
  let o = "", l = !1;
  return c;
  function c(E) {
    return (E === 72 || E === 104) && uN.call(i, i.previous) && !xf(i.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(E), e.consume(E), d) : a(E);
  }
  function d(E) {
    if (Gt(E) && o.length < 5)
      return o += String.fromCodePoint(E), e.consume(E), d;
    if (E === 58) {
      const T = o.toLowerCase();
      if (T === "http" || T === "https")
        return e.consume(E), m;
    }
    return a(E);
  }
  function m(E) {
    return E === 47 ? (e.consume(E), l ? f : (l = !0, m)) : a(E);
  }
  function f(E) {
    return E === null || Jl(E) || at(E) || gr(E) || pu(E) ? a(E) : e.attempt(aN, e.attempt(rN, b), a)(E);
  }
  function b(E) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(E);
  }
}
function m3(e, t, a) {
  let i = 0;
  return o;
  function o(c) {
    return (c === 87 || c === 119) && i < 3 ? (i++, e.consume(c), o) : c === 46 && i === 3 ? (e.consume(c), l) : a(c);
  }
  function l(c) {
    return c === null ? a(c) : t(c);
  }
}
function g3(e, t, a) {
  let i, o, l;
  return c;
  function c(f) {
    return f === 46 || f === 95 ? e.check(iN, m, d)(f) : f === null || at(f) || gr(f) || f !== 45 && pu(f) ? m(f) : (l = !0, e.consume(f), c);
  }
  function d(f) {
    return f === 95 ? i = !0 : (o = i, i = void 0), e.consume(f), c;
  }
  function m(f) {
    return o || i || !l ? a(f) : t(f);
  }
}
function h3(e, t) {
  let a = 0, i = 0;
  return o;
  function o(c) {
    return c === 40 ? (a++, e.consume(c), o) : c === 41 && i < a ? l(c) : c === 33 || c === 34 || c === 38 || c === 39 || c === 41 || c === 42 || c === 44 || c === 46 || c === 58 || c === 59 || c === 60 || c === 63 || c === 93 || c === 95 || c === 126 ? e.check(iN, t, l)(c) : c === null || at(c) || gr(c) ? t(c) : (e.consume(c), o);
  }
  function l(c) {
    return c === 41 && i++, e.consume(c), o;
  }
}
function b3(e, t, a) {
  return i;
  function i(d) {
    return d === 33 || d === 34 || d === 39 || d === 41 || d === 42 || d === 44 || d === 46 || d === 58 || d === 59 || d === 63 || d === 95 || d === 126 ? (e.consume(d), i) : d === 38 ? (e.consume(d), l) : d === 93 ? (e.consume(d), o) : (
      // `<` is an end.
      d === 60 || // So is whitespace.
      d === null || at(d) || gr(d) ? t(d) : a(d)
    );
  }
  function o(d) {
    return d === null || d === 40 || d === 91 || at(d) || gr(d) ? t(d) : i(d);
  }
  function l(d) {
    return Gt(d) ? c(d) : a(d);
  }
  function c(d) {
    return d === 59 ? (e.consume(d), i) : Gt(d) ? (e.consume(d), c) : a(d);
  }
}
function E3(e, t, a) {
  return i;
  function i(l) {
    return e.consume(l), o;
  }
  function o(l) {
    return Dt(l) ? a(l) : t(l);
  }
}
function lN(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || at(e);
}
function uN(e) {
  return !Gt(e);
}
function cN(e) {
  return !(e === 47 || Zp(e));
}
function Zp(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Dt(e);
}
function xf(e) {
  let t = e.length, a = !1;
  for (; t--; ) {
    const i = e[t][1];
    if ((i.type === "labelLink" || i.type === "labelImage") && !i._balanced) {
      a = !0;
      break;
    }
    if (i._gfmAutolinkLiteralWalkedInto) {
      a = !1;
      break;
    }
  }
  return e.length > 0 && !a && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), a;
}
const y3 = {
  tokenize: C3,
  partial: !0
};
function T3() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: N3,
        continuation: {
          tokenize: R3
        },
        exit: v3
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: A3
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: S3,
        resolveTo: _3
      }
    }
  };
}
function S3(e, t, a) {
  const i = this;
  let o = i.events.length;
  const l = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let c;
  for (; o--; ) {
    const m = i.events[o][1];
    if (m.type === "labelImage") {
      c = m;
      break;
    }
    if (m.type === "gfmFootnoteCall" || m.type === "labelLink" || m.type === "label" || m.type === "image" || m.type === "link")
      break;
  }
  return d;
  function d(m) {
    if (!c || !c._balanced)
      return a(m);
    const f = On(i.sliceSerialize({
      start: c.end,
      end: i.now()
    }));
    return f.codePointAt(0) !== 94 || !l.includes(f.slice(1)) ? a(m) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(m), e.exit("gfmFootnoteCallLabelMarker"), t(m));
  }
}
function _3(e, t) {
  let a = e.length;
  for (; a--; )
    if (e[a][1].type === "labelImage" && e[a][0] === "enter") {
      e[a][1];
      break;
    }
  e[a + 1][1].type = "data", e[a + 3][1].type = "gfmFootnoteCallLabelMarker";
  const i = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[a + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[a + 3][1].end),
    end: Object.assign({}, e[a + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const l = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, c = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, l.start),
    end: Object.assign({}, l.end)
  }, d = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[a + 1],
    e[a + 2],
    ["enter", i, t],
    // The `[`
    e[a + 3],
    e[a + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", l, t],
    ["enter", c, t],
    ["exit", c, t],
    ["exit", l, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", i, t]
  ];
  return e.splice(a, e.length - a + 1, ...d), e;
}
function A3(e, t, a) {
  const i = this, o = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let l = 0, c;
  return d;
  function d(E) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(E), e.exit("gfmFootnoteCallLabelMarker"), m;
  }
  function m(E) {
    return E !== 94 ? a(E) : (e.enter("gfmFootnoteCallMarker"), e.consume(E), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", f);
  }
  function f(E) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      E === 93 && !c || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      E === null || E === 91 || at(E)
    )
      return a(E);
    if (E === 93) {
      e.exit("chunkString");
      const T = e.exit("gfmFootnoteCallString");
      return o.includes(On(i.sliceSerialize(T))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(E), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : a(E);
    }
    return at(E) || (c = !0), l++, e.consume(E), E === 92 ? b : f;
  }
  function b(E) {
    return E === 91 || E === 92 || E === 93 ? (e.consume(E), l++, f) : f(E);
  }
}
function N3(e, t, a) {
  const i = this, o = i.parser.gfmFootnotes || (i.parser.gfmFootnotes = []);
  let l, c = 0, d;
  return m;
  function m(_) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(_), e.exit("gfmFootnoteDefinitionLabelMarker"), f;
  }
  function f(_) {
    return _ === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(_), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", b) : a(_);
  }
  function b(_) {
    if (
      // Too long.
      c > 999 || // Closing brace with nothing.
      _ === 93 && !d || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      _ === null || _ === 91 || at(_)
    )
      return a(_);
    if (_ === 93) {
      e.exit("chunkString");
      const k = e.exit("gfmFootnoteDefinitionLabelString");
      return l = On(i.sliceSerialize(k)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(_), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), T;
    }
    return at(_) || (d = !0), c++, e.consume(_), _ === 92 ? E : b;
  }
  function E(_) {
    return _ === 91 || _ === 92 || _ === 93 ? (e.consume(_), c++, b) : b(_);
  }
  function T(_) {
    return _ === 58 ? (e.enter("definitionMarker"), e.consume(_), e.exit("definitionMarker"), o.includes(l) || o.push(l), je(e, S, "gfmFootnoteDefinitionWhitespace")) : a(_);
  }
  function S(_) {
    return t(_);
  }
}
function R3(e, t, a) {
  return e.check(io, t, e.attempt(y3, t, a));
}
function v3(e) {
  e.exit("gfmFootnoteDefinition");
}
function C3(e, t, a) {
  const i = this;
  return je(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(l) {
    const c = i.events[i.events.length - 1];
    return c && c[1].type === "gfmFootnoteDefinitionIndent" && c[2].sliceSerialize(c[1], !0).length === 4 ? t(l) : a(l);
  }
}
function w3(e) {
  let a = (e || {}).singleTilde;
  const i = {
    name: "strikethrough",
    tokenize: l,
    resolveAll: o
  };
  return a == null && (a = !0), {
    text: {
      126: i
    },
    insideSpan: {
      null: [i]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function o(c, d) {
    let m = -1;
    for (; ++m < c.length; )
      if (c[m][0] === "enter" && c[m][1].type === "strikethroughSequenceTemporary" && c[m][1]._close) {
        let f = m;
        for (; f--; )
          if (c[f][0] === "exit" && c[f][1].type === "strikethroughSequenceTemporary" && c[f][1]._open && // If the sizes are the same:
          c[m][1].end.offset - c[m][1].start.offset === c[f][1].end.offset - c[f][1].start.offset) {
            c[m][1].type = "strikethroughSequence", c[f][1].type = "strikethroughSequence";
            const b = {
              type: "strikethrough",
              start: Object.assign({}, c[f][1].start),
              end: Object.assign({}, c[m][1].end)
            }, E = {
              type: "strikethroughText",
              start: Object.assign({}, c[f][1].end),
              end: Object.assign({}, c[m][1].start)
            }, T = [["enter", b, d], ["enter", c[f][1], d], ["exit", c[f][1], d], ["enter", E, d]], S = d.parser.constructs.insideSpan.null;
            S && pn(T, T.length, 0, fu(S, c.slice(f + 1, m), d)), pn(T, T.length, 0, [["exit", E, d], ["enter", c[m][1], d], ["exit", c[m][1], d], ["exit", b, d]]), pn(c, f - 1, m - f + 3, T), m = f + T.length - 2;
            break;
          }
      }
    for (m = -1; ++m < c.length; )
      c[m][1].type === "strikethroughSequenceTemporary" && (c[m][1].type = "data");
    return c;
  }
  function l(c, d, m) {
    const f = this.previous, b = this.events;
    let E = 0;
    return T;
    function T(_) {
      return f === 126 && b[b.length - 1][1].type !== "characterEscape" ? m(_) : (c.enter("strikethroughSequenceTemporary"), S(_));
    }
    function S(_) {
      const k = bi(f);
      if (_ === 126)
        return E > 1 ? m(_) : (c.consume(_), E++, S);
      if (E < 2 && !a) return m(_);
      const R = c.exit("strikethroughSequenceTemporary"), C = bi(_);
      return R._open = !C || C === 2 && !!k, R._close = !k || k === 2 && !!C, d(_);
    }
  }
}
class k3 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, a, i) {
    I3(this, t, a, i);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(l, c) {
      return l[0] - c[0];
    }), this.map.length === 0)
      return;
    let a = this.map.length;
    const i = [];
    for (; a > 0; )
      a -= 1, i.push(t.slice(this.map[a][0] + this.map[a][1]), this.map[a][2]), t.length = this.map[a][0];
    i.push(t.slice()), t.length = 0;
    let o = i.pop();
    for (; o; ) {
      for (const l of o)
        t.push(l);
      o = i.pop();
    }
    this.map.length = 0;
  }
}
function I3(e, t, a, i) {
  let o = 0;
  if (!(a === 0 && i.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += a, e.map[o][2].push(...i);
        return;
      }
      o += 1;
    }
    e.map.push([t, a, i]);
  }
}
function O3(e, t) {
  let a = !1;
  const i = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (a) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && i.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const l = i.length - 1;
          i[l] = i[l] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (a = !0);
    t += 1;
  }
  return i;
}
function x3() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: L3,
        resolveAll: D3
      }
    }
  };
}
function L3(e, t, a) {
  const i = this;
  let o = 0, l = 0, c;
  return d;
  function d(U) {
    let ee = i.events.length - 1;
    for (; ee > -1; ) {
      const de = i.events[ee][1].type;
      if (de === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      de === "linePrefix") ee--;
      else break;
    }
    const ae = ee > -1 ? i.events[ee][1].type : null, ue = ae === "tableHead" || ae === "tableRow" ? D : m;
    return ue === D && i.parser.lazy[i.now().line] ? a(U) : ue(U);
  }
  function m(U) {
    return e.enter("tableHead"), e.enter("tableRow"), f(U);
  }
  function f(U) {
    return U === 124 || (c = !0, l += 1), b(U);
  }
  function b(U) {
    return U === null ? a(U) : ve(U) ? l > 1 ? (l = 0, i.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(U), e.exit("lineEnding"), S) : a(U) : Fe(U) ? je(e, b, "whitespace")(U) : (l += 1, c && (c = !1, o += 1), U === 124 ? (e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), c = !0, b) : (e.enter("data"), E(U)));
  }
  function E(U) {
    return U === null || U === 124 || at(U) ? (e.exit("data"), b(U)) : (e.consume(U), U === 92 ? T : E);
  }
  function T(U) {
    return U === 92 || U === 124 ? (e.consume(U), E) : E(U);
  }
  function S(U) {
    return i.interrupt = !1, i.parser.lazy[i.now().line] ? a(U) : (e.enter("tableDelimiterRow"), c = !1, Fe(U) ? je(e, _, "linePrefix", i.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(U) : _(U));
  }
  function _(U) {
    return U === 45 || U === 58 ? R(U) : U === 124 ? (c = !0, e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), k) : q(U);
  }
  function k(U) {
    return Fe(U) ? je(e, R, "whitespace")(U) : R(U);
  }
  function R(U) {
    return U === 58 ? (l += 1, c = !0, e.enter("tableDelimiterMarker"), e.consume(U), e.exit("tableDelimiterMarker"), C) : U === 45 ? (l += 1, C(U)) : U === null || ve(U) ? Y(U) : q(U);
  }
  function C(U) {
    return U === 45 ? (e.enter("tableDelimiterFiller"), L(U)) : q(U);
  }
  function L(U) {
    return U === 45 ? (e.consume(U), L) : U === 58 ? (c = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(U), e.exit("tableDelimiterMarker"), x) : (e.exit("tableDelimiterFiller"), x(U));
  }
  function x(U) {
    return Fe(U) ? je(e, Y, "whitespace")(U) : Y(U);
  }
  function Y(U) {
    return U === 124 ? _(U) : U === null || ve(U) ? !c || o !== l ? q(U) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(U)) : q(U);
  }
  function q(U) {
    return a(U);
  }
  function D(U) {
    return e.enter("tableRow"), G(U);
  }
  function G(U) {
    return U === 124 ? (e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), G) : U === null || ve(U) ? (e.exit("tableRow"), t(U)) : Fe(U) ? je(e, G, "whitespace")(U) : (e.enter("data"), K(U));
  }
  function K(U) {
    return U === null || U === 124 || at(U) ? (e.exit("data"), G(U)) : (e.consume(U), U === 92 ? Q : K);
  }
  function Q(U) {
    return U === 92 || U === 124 ? (e.consume(U), K) : K(U);
  }
}
function D3(e, t) {
  let a = -1, i = !0, o = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], d = !1, m = 0, f, b, E;
  const T = new k3();
  for (; ++a < e.length; ) {
    const S = e[a], _ = S[1];
    S[0] === "enter" ? _.type === "tableHead" ? (d = !1, m !== 0 && (Y_(T, t, m, f, b), b = void 0, m = 0), f = {
      type: "table",
      start: Object.assign({}, _.start),
      // Note: correct end is set later.
      end: Object.assign({}, _.end)
    }, T.add(a, 0, [["enter", f, t]])) : _.type === "tableRow" || _.type === "tableDelimiterRow" ? (i = !0, E = void 0, l = [0, 0, 0, 0], c = [0, a + 1, 0, 0], d && (d = !1, b = {
      type: "tableBody",
      start: Object.assign({}, _.start),
      // Note: correct end is set later.
      end: Object.assign({}, _.end)
    }, T.add(a, 0, [["enter", b, t]])), o = _.type === "tableDelimiterRow" ? 2 : b ? 3 : 1) : o && (_.type === "data" || _.type === "tableDelimiterMarker" || _.type === "tableDelimiterFiller") ? (i = !1, c[2] === 0 && (l[1] !== 0 && (c[0] = c[1], E = Hl(T, t, l, o, void 0, E), l = [0, 0, 0, 0]), c[2] = a)) : _.type === "tableCellDivider" && (i ? i = !1 : (l[1] !== 0 && (c[0] = c[1], E = Hl(T, t, l, o, void 0, E)), l = c, c = [l[1], a, 0, 0])) : _.type === "tableHead" ? (d = !0, m = a) : _.type === "tableRow" || _.type === "tableDelimiterRow" ? (m = a, l[1] !== 0 ? (c[0] = c[1], E = Hl(T, t, l, o, a, E)) : c[1] !== 0 && (E = Hl(T, t, c, o, a, E)), o = 0) : o && (_.type === "data" || _.type === "tableDelimiterMarker" || _.type === "tableDelimiterFiller") && (c[3] = a);
  }
  for (m !== 0 && Y_(T, t, m, f, b), T.consume(t.events), a = -1; ++a < t.events.length; ) {
    const S = t.events[a];
    S[0] === "enter" && S[1].type === "table" && (S[1]._align = O3(t.events, a));
  }
  return e;
}
function Hl(e, t, a, i, o, l) {
  const c = i === 1 ? "tableHeader" : i === 2 ? "tableDelimiter" : "tableData", d = "tableContent";
  a[0] !== 0 && (l.end = Object.assign({}, fi(t.events, a[0])), e.add(a[0], 0, [["exit", l, t]]));
  const m = fi(t.events, a[1]);
  if (l = {
    type: c,
    start: Object.assign({}, m),
    // Note: correct end is set later.
    end: Object.assign({}, m)
  }, e.add(a[1], 0, [["enter", l, t]]), a[2] !== 0) {
    const f = fi(t.events, a[2]), b = fi(t.events, a[3]), E = {
      type: d,
      start: Object.assign({}, f),
      end: Object.assign({}, b)
    };
    if (e.add(a[2], 0, [["enter", E, t]]), i !== 2) {
      const T = t.events[a[2]], S = t.events[a[3]];
      if (T[1].end = Object.assign({}, S[1].end), T[1].type = "chunkText", T[1].contentType = "text", a[3] > a[2] + 1) {
        const _ = a[2] + 1, k = a[3] - a[2] - 1;
        e.add(_, k, []);
      }
    }
    e.add(a[3] + 1, 0, [["exit", E, t]]);
  }
  return o !== void 0 && (l.end = Object.assign({}, fi(t.events, o)), e.add(o, 0, [["exit", l, t]]), l = void 0), l;
}
function Y_(e, t, a, i, o) {
  const l = [], c = fi(t.events, a);
  o && (o.end = Object.assign({}, c), l.push(["exit", o, t])), i.end = Object.assign({}, c), l.push(["exit", i, t]), e.add(a + 1, 0, l);
}
function fi(e, t) {
  const a = e[t], i = a[0] === "enter" ? "start" : "end";
  return a[1][i];
}
const M3 = {
  name: "tasklistCheck",
  tokenize: B3
};
function U3() {
  return {
    text: {
      91: M3
    }
  };
}
function B3(e, t, a) {
  const i = this;
  return o;
  function o(m) {
    return (
      // Exit if theres stuff before.
      i.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !i._gfmTasklistFirstContentOfListItem ? a(m) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(m), e.exit("taskListCheckMarker"), l)
    );
  }
  function l(m) {
    return at(m) ? (e.enter("taskListCheckValueUnchecked"), e.consume(m), e.exit("taskListCheckValueUnchecked"), c) : m === 88 || m === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(m), e.exit("taskListCheckValueChecked"), c) : a(m);
  }
  function c(m) {
    return m === 93 ? (e.enter("taskListCheckMarker"), e.consume(m), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), d) : a(m);
  }
  function d(m) {
    return ve(m) ? t(m) : Fe(m) ? e.check({
      tokenize: F3
    }, t, a)(m) : a(m);
  }
}
function F3(e, t, a) {
  return je(e, i, "whitespace");
  function i(o) {
    return o === null ? a(o) : t(o);
  }
}
function P3(e) {
  return T1([
    c3(),
    T3(),
    w3(e),
    x3(),
    U3()
  ]);
}
const H3 = {};
function z3(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), a = e || H3, i = t.data(), o = i.micromarkExtensions || (i.micromarkExtensions = []), l = i.fromMarkdownExtensions || (i.fromMarkdownExtensions = []), c = i.toMarkdownExtensions || (i.toMarkdownExtensions = []);
  o.push(P3(a)), l.push(s3()), c.push(o3(a));
}
const V_ = /[#.]/g;
function G3(e, t) {
  const a = e || "", i = {};
  let o = 0, l, c;
  for (; o < a.length; ) {
    V_.lastIndex = o;
    const d = V_.exec(a), m = a.slice(o, d ? d.index : a.length);
    m && (l ? l === "#" ? i.id = m : Array.isArray(i.className) ? i.className.push(m) : i.className = [m] : c = m, o += m.length), d && (l = d[0], o++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: c || t || "div",
    properties: i,
    children: []
  };
}
function dN(e, t, a) {
  const i = a ? Y3(a) : void 0;
  function o(l, c, ...d) {
    let m;
    if (l == null) {
      m = { type: "root", children: [] };
      const f = (
        /** @type {Child} */
        c
      );
      d.unshift(f);
    } else {
      m = G3(l, t);
      const f = m.tagName.toLowerCase(), b = i ? i.get(f) : void 0;
      if (m.tagName = b || f, j3(c))
        d.unshift(c);
      else
        for (const [E, T] of Object.entries(c))
          $3(e, m.properties, E, T);
    }
    for (const f of d)
      Qp(m.children, f);
    return m.type === "element" && m.tagName === "template" && (m.content = { type: "root", children: m.children }, m.children = []), m;
  }
  return o;
}
function j3(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), a = Object.keys(e);
  for (const i of a) {
    const o = t[i];
    if (o && typeof o == "object") {
      if (!Array.isArray(o)) return !0;
      const l = (
        /** @type {ReadonlyArray<unknown>} */
        o
      );
      for (const c of l)
        if (typeof c != "number" && typeof c != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function $3(e, t, a, i) {
  const o = cu(e, a);
  let l;
  if (i != null) {
    if (typeof i == "number") {
      if (Number.isNaN(i)) return;
      l = i;
    } else typeof i == "boolean" ? l = i : typeof i == "string" ? o.spaceSeparated ? l = s_(i) : o.commaSeparated ? l = t_(i) : o.commaOrSpaceSeparated ? l = s_(t_(i).join(" ")) : l = W_(o, o.property, i) : Array.isArray(i) ? l = [...i] : l = o.property === "style" ? q3(i) : String(i);
    if (Array.isArray(l)) {
      const c = [];
      for (const d of l)
        c.push(
          /** @type {number | string} */
          W_(o, o.property, d)
        );
      l = c;
    }
    o.property === "className" && Array.isArray(t.className) && (l = t.className.concat(
      /** @type {Array<number | string> | number | string} */
      l
    )), t[o.property] = l;
  }
}
function Qp(e, t) {
  if (t != null) if (typeof t == "number" || typeof t == "string")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (const a of t)
      Qp(e, a);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? Qp(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function W_(e, t, a) {
  if (typeof a == "string") {
    if (e.number && a && !Number.isNaN(Number(a)))
      return Number(a);
    if ((e.boolean || e.overloadedBoolean) && (a === "" || Vs(a) === Vs(t)))
      return !0;
  }
  return a;
}
function q3(e) {
  const t = [];
  for (const [a, i] of Object.entries(e))
    t.push([a, i].join(": "));
  return t.join("; ");
}
function Y3(e) {
  const t = /* @__PURE__ */ new Map();
  for (const a of e)
    t.set(a.toLowerCase(), a);
  return t;
}
const V3 = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], pN = dN(ro, "div"), W3 = dN(qa, "g", V3);
function X3(e) {
  const t = String(e), a = [];
  return { toOffset: o, toPoint: i };
  function i(l) {
    if (typeof l == "number" && l > -1 && l <= t.length) {
      let c = 0;
      for (; ; ) {
        let d = a[c];
        if (d === void 0) {
          const m = X_(t, a[c - 1]);
          d = m === -1 ? t.length + 1 : m + 1, a[c] = d;
        }
        if (d > l)
          return {
            line: c + 1,
            column: l - (c > 0 ? a[c - 1] : 0) + 1,
            offset: l
          };
        c++;
      }
    }
  }
  function o(l) {
    if (l && typeof l.line == "number" && typeof l.column == "number" && !Number.isNaN(l.line) && !Number.isNaN(l.column)) {
      for (; a.length < l.line; ) {
        const d = a[a.length - 1], m = X_(t, d), f = m === -1 ? t.length + 1 : m + 1;
        if (d === f) break;
        a.push(f);
      }
      const c = (l.line > 1 ? a[l.line - 2] : 0) + l.column - 1;
      if (c < a[l.line - 1]) return c;
    }
  }
}
function X_(e, t) {
  const a = e.indexOf("\r", t), i = e.indexOf(`
`, t);
  return i === -1 ? a : a === -1 || a + 1 === i ? i : a < i ? a : i;
}
const fr = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, fN = {}.hasOwnProperty, K3 = Object.prototype;
function Z3(e, t) {
  const a = t || {};
  return Lf(
    {
      file: a.file || void 0,
      location: !1,
      schema: a.space === "svg" ? qa : ro,
      verbose: a.verbose || !1
    },
    e
  );
}
function Lf(e, t) {
  let a;
  switch (t.nodeName) {
    case "#comment": {
      const i = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return a = { type: "comment", value: i.data }, Yl(e, i, a), a;
    }
    case "#document":
    case "#document-fragment": {
      const i = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), o = "mode" in i ? i.mode === "quirks" || i.mode === "limited-quirks" : !1;
      if (a = {
        type: "root",
        children: mN(e, t.childNodes),
        data: { quirksMode: o }
      }, e.file && e.location) {
        const l = String(e.file), c = X3(l), d = c.toPoint(0), m = c.toPoint(l.length);
        a.position = { start: d, end: m };
      }
      return a;
    }
    case "#documentType": {
      const i = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return a = { type: "doctype" }, Yl(e, i, a), a;
    }
    case "#text": {
      const i = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return a = { type: "text", value: i.value }, Yl(e, i, a), a;
    }
    // Element.
    default:
      return a = Q3(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), a;
  }
}
function mN(e, t) {
  let a = -1;
  const i = [];
  for (; ++a < t.length; ) {
    const o = (
      /** @type {RootContent} */
      Lf(e, t[a])
    );
    i.push(o);
  }
  return i;
}
function Q3(e, t) {
  const a = e.schema;
  e.schema = t.namespaceURI === fr.svg ? qa : ro;
  let i = -1;
  const o = {};
  for (; ++i < t.attrs.length; ) {
    const d = t.attrs[i], m = (d.prefix ? d.prefix + ":" : "") + d.name;
    fN.call(K3, m) || (o[m] = d.value);
  }
  const c = (e.schema.space === "svg" ? W3 : pN)(t.tagName, o, mN(e, t.childNodes));
  if (Yl(e, t, c), c.tagName === "template") {
    const d = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), m = d.sourceCodeLocation, f = m && m.startTag && mi(m.startTag), b = m && m.endTag && mi(m.endTag), E = (
      /** @type {Root} */
      Lf(e, d.content)
    );
    f && b && e.file && (E.position = { start: f.end, end: b.start }), c.content = E;
  }
  return e.schema = a, c;
}
function Yl(e, t, a) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const i = J3(e, a, t.sourceCodeLocation);
    i && (e.location = !0, a.position = i);
  }
}
function J3(e, t, a) {
  const i = mi(a);
  if (t.type === "element") {
    const o = t.children[t.children.length - 1];
    if (i && !a.endTag && o && o.position && o.position.end && (i.end = Object.assign({}, o.position.end)), e.verbose) {
      const l = {};
      let c;
      if (a.attrs)
        for (c in a.attrs)
          fN.call(a.attrs, c) && (l[cu(e.schema, c).property] = mi(
            a.attrs[c]
          ));
      a.startTag;
      const d = mi(a.startTag), m = a.endTag ? mi(a.endTag) : void 0, f = { opening: d };
      m && (f.closing = m), f.properties = l, t.data = { position: f };
    }
  }
  return i;
}
function mi(e) {
  const t = K_({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), a = K_({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || a ? { start: t, end: a } : void 0;
}
function K_(e) {
  return e.line && e.column ? e : void 0;
}
const eM = {}, tM = {}.hasOwnProperty, gN = q1("type", { handlers: { root: aM, element: lM, text: sM, comment: oM, doctype: iM } });
function nM(e, t) {
  const i = (t || eM).space;
  return gN(e, i === "svg" ? qa : ro);
}
function aM(e, t) {
  const a = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return a.childNodes = Df(e.children, a, t), Ai(e, a), a;
}
function rM(e, t) {
  const a = { nodeName: "#document-fragment", childNodes: [] };
  return a.childNodes = Df(e.children, a, t), Ai(e, a), a;
}
function iM(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return Ai(e, t), t;
}
function sM(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return Ai(e, t), t;
}
function oM(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return Ai(e, t), t;
}
function lM(e, t) {
  const a = t;
  let i = a;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && a.space === "html" && (i = qa);
  const o = [];
  let l;
  if (e.properties) {
    for (l in e.properties)
      if (l !== "children" && tM.call(e.properties, l)) {
        const m = uM(
          i,
          l,
          e.properties[l]
        );
        m && o.push(m);
      }
  }
  const c = i.space, d = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: o,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: fr[c],
    childNodes: [],
    parentNode: null
  };
  return d.childNodes = Df(e.children, d, i), Ai(e, d), e.tagName === "template" && e.content && (d.content = rM(e.content, i)), d;
}
function uM(e, t, a) {
  const i = cu(e, t);
  if (a === !1 || a === null || a === void 0 || typeof a == "number" && Number.isNaN(a) || !a && i.boolean)
    return;
  Array.isArray(a) && (a = i.commaSeparated ? r1(a) : p1(a));
  const o = {
    name: i.attribute,
    value: a === !0 ? "" : String(a)
  };
  if (i.space && i.space !== "html" && i.space !== "svg") {
    const l = o.name.indexOf(":");
    l < 0 ? o.prefix = "" : (o.name = o.name.slice(l + 1), o.prefix = i.attribute.slice(0, l)), o.namespace = fr[i.space];
  }
  return o;
}
function Df(e, t, a) {
  let i = -1;
  const o = [];
  if (e)
    for (; ++i < e.length; ) {
      const l = gN(e[i], a);
      l.parentNode = t, o.push(l);
    }
  return o;
}
function Ai(e, t) {
  const a = e.position;
  a && a.start && a.end && (a.start.offset, a.end.offset, t.sourceCodeLocation = {
    startLine: a.start.line,
    startCol: a.start.column,
    startOffset: a.start.offset,
    endLine: a.end.line,
    endCol: a.end.column,
    endOffset: a.end.offset
  });
}
const cM = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], dM = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), lt = "";
var w;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(w || (w = {}));
const Qt = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function hN(e) {
  return e >= 55296 && e <= 57343;
}
function pM(e) {
  return e >= 56320 && e <= 57343;
}
function fM(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function bN(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function EN(e) {
  return e >= 64976 && e <= 65007 || dM.has(e);
}
var ne;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(ne || (ne = {}));
const mM = 65536;
class gM {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = mM, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, a) {
    const { line: i, col: o, offset: l } = this, c = o + a, d = l + a;
    return {
      code: t,
      startLine: i,
      endLine: i,
      startCol: c,
      endCol: c,
      startOffset: d,
      endOffset: d
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const a = this.html.charCodeAt(this.pos + 1);
      if (pM(a))
        return this.pos++, this._addGap(), fM(t, a);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, w.EOF;
    return this._err(ne.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, a) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = a;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, a) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (a)
      return this.html.startsWith(t, this.pos);
    for (let i = 0; i < t.length; i++)
      if ((this.html.charCodeAt(this.pos + i) | 32) !== t.charCodeAt(i))
        return !1;
    return !0;
  }
  peek(t) {
    const a = this.pos + t;
    if (a >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, w.EOF;
    const i = this.html.charCodeAt(a);
    return i === w.CARRIAGE_RETURN ? w.LINE_FEED : i;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, w.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === w.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, w.LINE_FEED) : t === w.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, hN(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === w.LINE_FEED || t === w.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    bN(t) ? this._err(ne.controlCharacterInInputStream) : EN(t) && this._err(ne.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var De;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(De || (De = {}));
function yN(e, t) {
  for (let a = e.attrs.length - 1; a >= 0; a--)
    if (e.attrs[a].name === t)
      return e.attrs[a].value;
  return null;
}
const hM = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), bM = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function EM(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = bM.get(e)) !== null && t !== void 0 ? t : e;
}
var vt;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(vt || (vt = {}));
const yM = 32;
var ja;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(ja || (ja = {}));
function Jp(e) {
  return e >= vt.ZERO && e <= vt.NINE;
}
function TM(e) {
  return e >= vt.UPPER_A && e <= vt.UPPER_F || e >= vt.LOWER_A && e <= vt.LOWER_F;
}
function SM(e) {
  return e >= vt.UPPER_A && e <= vt.UPPER_Z || e >= vt.LOWER_A && e <= vt.LOWER_Z || Jp(e);
}
function _M(e) {
  return e === vt.EQUALS || SM(e);
}
var Nt;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(Nt || (Nt = {}));
var ca;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(ca || (ca = {}));
class AM {
  constructor(t, a, i) {
    this.decodeTree = t, this.emitCodePoint = a, this.errors = i, this.state = Nt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ca.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = Nt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, a) {
    switch (this.state) {
      case Nt.EntityStart:
        return t.charCodeAt(a) === vt.NUM ? (this.state = Nt.NumericStart, this.consumed += 1, this.stateNumericStart(t, a + 1)) : (this.state = Nt.NamedEntity, this.stateNamedEntity(t, a));
      case Nt.NumericStart:
        return this.stateNumericStart(t, a);
      case Nt.NumericDecimal:
        return this.stateNumericDecimal(t, a);
      case Nt.NumericHex:
        return this.stateNumericHex(t, a);
      case Nt.NamedEntity:
        return this.stateNamedEntity(t, a);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, a) {
    return a >= t.length ? -1 : (t.charCodeAt(a) | yM) === vt.LOWER_X ? (this.state = Nt.NumericHex, this.consumed += 1, this.stateNumericHex(t, a + 1)) : (this.state = Nt.NumericDecimal, this.stateNumericDecimal(t, a));
  }
  addToNumericResult(t, a, i, o) {
    if (a !== i) {
      const l = i - a;
      this.result = this.result * Math.pow(o, l) + Number.parseInt(t.substr(a, l), o), this.consumed += l;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, a) {
    const i = a;
    for (; a < t.length; ) {
      const o = t.charCodeAt(a);
      if (Jp(o) || TM(o))
        a += 1;
      else
        return this.addToNumericResult(t, i, a, 16), this.emitNumericEntity(o, 3);
    }
    return this.addToNumericResult(t, i, a, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, a) {
    const i = a;
    for (; a < t.length; ) {
      const o = t.charCodeAt(a);
      if (Jp(o))
        a += 1;
      else
        return this.addToNumericResult(t, i, a, 10), this.emitNumericEntity(o, 2);
    }
    return this.addToNumericResult(t, i, a, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, a) {
    var i;
    if (this.consumed <= a)
      return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === vt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === ca.Strict)
      return 0;
    return this.emitCodePoint(EM(this.result), this.consumed), this.errors && (t !== vt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, a) {
    const { decodeTree: i } = this;
    let o = i[this.treeIndex], l = (o & ja.VALUE_LENGTH) >> 14;
    for (; a < t.length; a++, this.excess++) {
      const c = t.charCodeAt(a);
      if (this.treeIndex = NM(i, o, this.treeIndex + Math.max(1, l), c), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === ca.Attribute && // We shouldn't have consumed any characters after the entity,
        (l === 0 || // And there should be no invalid characters.
        _M(c)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (o = i[this.treeIndex], l = (o & ja.VALUE_LENGTH) >> 14, l !== 0) {
        if (c === vt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, l, this.consumed + this.excess);
        this.decodeMode !== ca.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: a, decodeTree: i } = this, o = (i[a] & ja.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(a, o, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, a, i) {
    const { decodeTree: o } = this;
    return this.emitCodePoint(a === 1 ? o[t] & ~ja.VALUE_LENGTH : o[t + 1], i), a === 3 && this.emitCodePoint(o[t + 2], i), i;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case Nt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ca.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Nt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Nt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Nt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Nt.EntityStart:
        return 0;
    }
  }
}
function NM(e, t, a, i) {
  const o = (t & ja.BRANCH_LENGTH) >> 7, l = t & ja.JUMP_TABLE;
  if (o === 0)
    return l !== 0 && i === l ? a : -1;
  if (l) {
    const m = i - l;
    return m < 0 || m >= o ? -1 : e[a + m] - 1;
  }
  let c = a, d = c + o - 1;
  for (; c <= d; ) {
    const m = c + d >>> 1, f = e[m];
    if (f < i)
      c = m + 1;
    else if (f > i)
      d = m - 1;
    else
      return e[m + o];
  }
  return -1;
}
var pe;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(pe || (pe = {}));
var mr;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(mr || (mr = {}));
var Nn;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(Nn || (Nn = {}));
var V;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(V || (V = {}));
var h;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(h || (h = {}));
const RM = /* @__PURE__ */ new Map([
  [V.A, h.A],
  [V.ADDRESS, h.ADDRESS],
  [V.ANNOTATION_XML, h.ANNOTATION_XML],
  [V.APPLET, h.APPLET],
  [V.AREA, h.AREA],
  [V.ARTICLE, h.ARTICLE],
  [V.ASIDE, h.ASIDE],
  [V.B, h.B],
  [V.BASE, h.BASE],
  [V.BASEFONT, h.BASEFONT],
  [V.BGSOUND, h.BGSOUND],
  [V.BIG, h.BIG],
  [V.BLOCKQUOTE, h.BLOCKQUOTE],
  [V.BODY, h.BODY],
  [V.BR, h.BR],
  [V.BUTTON, h.BUTTON],
  [V.CAPTION, h.CAPTION],
  [V.CENTER, h.CENTER],
  [V.CODE, h.CODE],
  [V.COL, h.COL],
  [V.COLGROUP, h.COLGROUP],
  [V.DD, h.DD],
  [V.DESC, h.DESC],
  [V.DETAILS, h.DETAILS],
  [V.DIALOG, h.DIALOG],
  [V.DIR, h.DIR],
  [V.DIV, h.DIV],
  [V.DL, h.DL],
  [V.DT, h.DT],
  [V.EM, h.EM],
  [V.EMBED, h.EMBED],
  [V.FIELDSET, h.FIELDSET],
  [V.FIGCAPTION, h.FIGCAPTION],
  [V.FIGURE, h.FIGURE],
  [V.FONT, h.FONT],
  [V.FOOTER, h.FOOTER],
  [V.FOREIGN_OBJECT, h.FOREIGN_OBJECT],
  [V.FORM, h.FORM],
  [V.FRAME, h.FRAME],
  [V.FRAMESET, h.FRAMESET],
  [V.H1, h.H1],
  [V.H2, h.H2],
  [V.H3, h.H3],
  [V.H4, h.H4],
  [V.H5, h.H5],
  [V.H6, h.H6],
  [V.HEAD, h.HEAD],
  [V.HEADER, h.HEADER],
  [V.HGROUP, h.HGROUP],
  [V.HR, h.HR],
  [V.HTML, h.HTML],
  [V.I, h.I],
  [V.IMG, h.IMG],
  [V.IMAGE, h.IMAGE],
  [V.INPUT, h.INPUT],
  [V.IFRAME, h.IFRAME],
  [V.KEYGEN, h.KEYGEN],
  [V.LABEL, h.LABEL],
  [V.LI, h.LI],
  [V.LINK, h.LINK],
  [V.LISTING, h.LISTING],
  [V.MAIN, h.MAIN],
  [V.MALIGNMARK, h.MALIGNMARK],
  [V.MARQUEE, h.MARQUEE],
  [V.MATH, h.MATH],
  [V.MENU, h.MENU],
  [V.META, h.META],
  [V.MGLYPH, h.MGLYPH],
  [V.MI, h.MI],
  [V.MO, h.MO],
  [V.MN, h.MN],
  [V.MS, h.MS],
  [V.MTEXT, h.MTEXT],
  [V.NAV, h.NAV],
  [V.NOBR, h.NOBR],
  [V.NOFRAMES, h.NOFRAMES],
  [V.NOEMBED, h.NOEMBED],
  [V.NOSCRIPT, h.NOSCRIPT],
  [V.OBJECT, h.OBJECT],
  [V.OL, h.OL],
  [V.OPTGROUP, h.OPTGROUP],
  [V.OPTION, h.OPTION],
  [V.P, h.P],
  [V.PARAM, h.PARAM],
  [V.PLAINTEXT, h.PLAINTEXT],
  [V.PRE, h.PRE],
  [V.RB, h.RB],
  [V.RP, h.RP],
  [V.RT, h.RT],
  [V.RTC, h.RTC],
  [V.RUBY, h.RUBY],
  [V.S, h.S],
  [V.SCRIPT, h.SCRIPT],
  [V.SEARCH, h.SEARCH],
  [V.SECTION, h.SECTION],
  [V.SELECT, h.SELECT],
  [V.SOURCE, h.SOURCE],
  [V.SMALL, h.SMALL],
  [V.SPAN, h.SPAN],
  [V.STRIKE, h.STRIKE],
  [V.STRONG, h.STRONG],
  [V.STYLE, h.STYLE],
  [V.SUB, h.SUB],
  [V.SUMMARY, h.SUMMARY],
  [V.SUP, h.SUP],
  [V.TABLE, h.TABLE],
  [V.TBODY, h.TBODY],
  [V.TEMPLATE, h.TEMPLATE],
  [V.TEXTAREA, h.TEXTAREA],
  [V.TFOOT, h.TFOOT],
  [V.TD, h.TD],
  [V.TH, h.TH],
  [V.THEAD, h.THEAD],
  [V.TITLE, h.TITLE],
  [V.TR, h.TR],
  [V.TRACK, h.TRACK],
  [V.TT, h.TT],
  [V.U, h.U],
  [V.UL, h.UL],
  [V.SVG, h.SVG],
  [V.VAR, h.VAR],
  [V.WBR, h.WBR],
  [V.XMP, h.XMP]
]);
function Ni(e) {
  var t;
  return (t = RM.get(e)) !== null && t !== void 0 ? t : h.UNKNOWN;
}
const fe = h, vM = {
  [pe.HTML]: /* @__PURE__ */ new Set([
    fe.ADDRESS,
    fe.APPLET,
    fe.AREA,
    fe.ARTICLE,
    fe.ASIDE,
    fe.BASE,
    fe.BASEFONT,
    fe.BGSOUND,
    fe.BLOCKQUOTE,
    fe.BODY,
    fe.BR,
    fe.BUTTON,
    fe.CAPTION,
    fe.CENTER,
    fe.COL,
    fe.COLGROUP,
    fe.DD,
    fe.DETAILS,
    fe.DIR,
    fe.DIV,
    fe.DL,
    fe.DT,
    fe.EMBED,
    fe.FIELDSET,
    fe.FIGCAPTION,
    fe.FIGURE,
    fe.FOOTER,
    fe.FORM,
    fe.FRAME,
    fe.FRAMESET,
    fe.H1,
    fe.H2,
    fe.H3,
    fe.H4,
    fe.H5,
    fe.H6,
    fe.HEAD,
    fe.HEADER,
    fe.HGROUP,
    fe.HR,
    fe.HTML,
    fe.IFRAME,
    fe.IMG,
    fe.INPUT,
    fe.LI,
    fe.LINK,
    fe.LISTING,
    fe.MAIN,
    fe.MARQUEE,
    fe.MENU,
    fe.META,
    fe.NAV,
    fe.NOEMBED,
    fe.NOFRAMES,
    fe.NOSCRIPT,
    fe.OBJECT,
    fe.OL,
    fe.P,
    fe.PARAM,
    fe.PLAINTEXT,
    fe.PRE,
    fe.SCRIPT,
    fe.SECTION,
    fe.SELECT,
    fe.SOURCE,
    fe.STYLE,
    fe.SUMMARY,
    fe.TABLE,
    fe.TBODY,
    fe.TD,
    fe.TEMPLATE,
    fe.TEXTAREA,
    fe.TFOOT,
    fe.TH,
    fe.THEAD,
    fe.TITLE,
    fe.TR,
    fe.TRACK,
    fe.UL,
    fe.WBR,
    fe.XMP
  ]),
  [pe.MATHML]: /* @__PURE__ */ new Set([fe.MI, fe.MO, fe.MN, fe.MS, fe.MTEXT, fe.ANNOTATION_XML]),
  [pe.SVG]: /* @__PURE__ */ new Set([fe.TITLE, fe.FOREIGN_OBJECT, fe.DESC]),
  [pe.XLINK]: /* @__PURE__ */ new Set(),
  [pe.XML]: /* @__PURE__ */ new Set(),
  [pe.XMLNS]: /* @__PURE__ */ new Set()
}, ef = /* @__PURE__ */ new Set([fe.H1, fe.H2, fe.H3, fe.H4, fe.H5, fe.H6]);
V.STYLE, V.SCRIPT, V.XMP, V.IFRAME, V.NOEMBED, V.NOFRAMES, V.PLAINTEXT;
var I;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(I || (I = {}));
const mt = {
  DATA: I.DATA,
  RCDATA: I.RCDATA,
  RAWTEXT: I.RAWTEXT,
  SCRIPT_DATA: I.SCRIPT_DATA,
  PLAINTEXT: I.PLAINTEXT,
  CDATA_SECTION: I.CDATA_SECTION
};
function CM(e) {
  return e >= w.DIGIT_0 && e <= w.DIGIT_9;
}
function Ms(e) {
  return e >= w.LATIN_CAPITAL_A && e <= w.LATIN_CAPITAL_Z;
}
function wM(e) {
  return e >= w.LATIN_SMALL_A && e <= w.LATIN_SMALL_Z;
}
function Ha(e) {
  return wM(e) || Ms(e);
}
function Z_(e) {
  return Ha(e) || CM(e);
}
function zl(e) {
  return e + 32;
}
function TN(e) {
  return e === w.SPACE || e === w.LINE_FEED || e === w.TABULATION || e === w.FORM_FEED;
}
function Q_(e) {
  return TN(e) || e === w.SOLIDUS || e === w.GREATER_THAN_SIGN;
}
function kM(e) {
  return e === w.NULL ? ne.nullCharacterReference : e > 1114111 ? ne.characterReferenceOutsideUnicodeRange : hN(e) ? ne.surrogateCharacterReference : EN(e) ? ne.noncharacterCharacterReference : bN(e) || e === w.CARRIAGE_RETURN ? ne.controlCharacterReference : null;
}
class IM {
  constructor(t, a) {
    this.options = t, this.handler = a, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = I.DATA, this.returnState = I.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new gM(a), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new AM(hM, (i, o) => {
      this.preprocessor.pos = this.entityStartPos + o - 1, this._flushCodePointConsumedAsCharacterReference(i);
    }, a.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(ne.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (i) => {
        this._err(ne.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + i);
      },
      validateNumericCharacterReference: (i) => {
        const o = kM(i);
        o && this._err(o, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, a = 0) {
    var i, o;
    (o = (i = this.handler).onParseError) === null || o === void 0 || o.call(i, this.preprocessor.getError(t, a));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, a, i) {
    this.active = !0, this.preprocessor.write(t, a), this._runParsingLoop(), this.paused || i == null || i();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let a = 0; a < t; a++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, a) {
    return this.preprocessor.startsWith(t, a) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: De.START_TAG,
      tagName: "",
      tagID: h.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: De.END_TAG,
      tagName: "",
      tagID: h.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: De.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: De.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, a) {
    this.currentCharacterToken = {
      type: t,
      chars: a,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, a;
    const i = this.currentToken;
    if (yN(i, this.currentAttr.name) === null) {
      if (i.attrs.push(this.currentAttr), i.location && this.currentLocation) {
        const o = (t = (a = i.location).attrs) !== null && t !== void 0 ? t : a.attrs = /* @__PURE__ */ Object.create(null);
        o[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(ne.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Ni(t.tagName), t.type === De.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(ne.endTagWithAttributes), t.selfClosing && this._err(ne.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case De.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case De.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case De.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: De.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, a) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += a;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, a);
  }
  _emitCodePoint(t) {
    const a = TN(t) ? De.WHITESPACE_CHARACTER : t === w.NULL ? De.NULL_CHARACTER : De.CHARACTER;
    this._appendCharToCurrentCharacterToken(a, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(De.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = I.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? ca.Attribute : ca.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === I.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === I.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === I.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case I.DATA: {
        this._stateData(t);
        break;
      }
      case I.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case I.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case I.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case I.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case I.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case I.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case I.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case I.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case I.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case I.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case I.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case I.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case I.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case I.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case I.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case I.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case I.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case I.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case I.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case I.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case I.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case I.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case I.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case I.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case I.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case I.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case I.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case I.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case I.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case I.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case I.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case I.COMMENT: {
        this._stateComment(t);
        break;
      }
      case I.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case I.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case I.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case I.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case I.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case I.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case I.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case I.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case I.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case I.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case I.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case I.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case I.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case I.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case I.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case I.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case I.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case I.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case I.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case I.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case I.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case I.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case I.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case I.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case I.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case I.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case I.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case I.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case w.LESS_THAN_SIGN: {
        this.state = I.TAG_OPEN;
        break;
      }
      case w.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case w.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case w.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case w.LESS_THAN_SIGN: {
        this.state = I.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Ha(t))
      this._createStartTagToken(), this.state = I.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case w.EXCLAMATION_MARK: {
          this.state = I.MARKUP_DECLARATION_OPEN;
          break;
        }
        case w.SOLIDUS: {
          this.state = I.END_TAG_OPEN;
          break;
        }
        case w.QUESTION_MARK: {
          this._err(ne.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = I.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case w.EOF: {
          this._err(ne.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(ne.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = I.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Ha(t))
      this._createEndTagToken(), this.state = I.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case w.GREATER_THAN_SIGN: {
          this._err(ne.missingEndTagName), this.state = I.DATA;
          break;
        }
        case w.EOF: {
          this._err(ne.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(ne.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = I.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case w.SOLIDUS: {
        this.state = I.SELF_CLOSING_START_TAG;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.tagName += lt;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        a.tagName += String.fromCodePoint(Ms(t) ? zl(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === w.SOLIDUS ? this.state = I.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = I.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Ha(t) ? (this.state = I.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = I.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const a = this.currentToken;
    switch (a.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = I.BEFORE_ATTRIBUTE_NAME, !1;
      case w.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = I.SELF_CLOSING_START_TAG, !1;
      case w.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = I.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = I.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === w.SOLIDUS ? this.state = I.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = I.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Ha(t) ? (this.state = I.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = I.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = I.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case w.SOLIDUS: {
        this.state = I.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case w.EXCLAMATION_MARK: {
        this.state = I.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = I.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Ha(t) ? (this.state = I.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = I.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = I.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === w.HYPHEN_MINUS ? (this.state = I.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = I.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === w.HYPHEN_MINUS ? (this.state = I.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = I.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.state = I.SCRIPT_DATA_ESCAPED, this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = I.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.state = I.SCRIPT_DATA_ESCAPED, this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = I.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === w.SOLIDUS ? this.state = I.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ha(t) ? (this._emitChars("<"), this.state = I.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = I.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Ha(t) ? (this.state = I.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = I.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = I.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(Qt.SCRIPT, !1) && Q_(this.preprocessor.peek(Qt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < Qt.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = I.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case w.LESS_THAN_SIGN: {
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(lt);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === w.SOLIDUS ? (this.state = I.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(Qt.SCRIPT, !1) && Q_(this.preprocessor.peek(Qt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let a = 0; a < Qt.SCRIPT.length; a++)
        this._emitCodePoint(this._consume());
      this.state = I.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = I.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.SOLIDUS:
      case w.GREATER_THAN_SIGN:
      case w.EOF: {
        this.state = I.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case w.EQUALS_SIGN: {
        this._err(ne.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = I.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = I.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
      case w.SOLIDUS:
      case w.GREATER_THAN_SIGN:
      case w.EOF: {
        this._leaveAttrName(), this.state = I.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case w.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = I.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case w.QUOTATION_MARK:
      case w.APOSTROPHE:
      case w.LESS_THAN_SIGN: {
        this._err(ne.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.currentAttr.name += lt;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Ms(t) ? zl(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.SOLIDUS: {
        this.state = I.SELF_CLOSING_START_TAG;
        break;
      }
      case w.EQUALS_SIGN: {
        this.state = I.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = I.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.QUOTATION_MARK: {
        this.state = I.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        this.state = I.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.missingAttributeValue), this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = I.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case w.QUOTATION_MARK: {
        this.state = I.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case w.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.currentAttr.value += lt;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case w.APOSTROPHE: {
        this.state = I.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case w.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.currentAttr.value += lt;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this._leaveAttrValue(), this.state = I.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case w.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), this.currentAttr.value += lt;
        break;
      }
      case w.QUOTATION_MARK:
      case w.APOSTROPHE:
      case w.LESS_THAN_SIGN:
      case w.EQUALS_SIGN:
      case w.GRAVE_ACCENT: {
        this._err(ne.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this._leaveAttrValue(), this.state = I.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case w.SOLIDUS: {
        this._leaveAttrValue(), this.state = I.SELF_CLOSING_START_TAG;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingWhitespaceBetweenAttributes), this.state = I.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case w.GREATER_THAN_SIGN: {
        const a = this.currentToken;
        a.selfClosing = !0, this.state = I.DATA, this.emitCurrentTagToken();
        break;
      }
      case w.EOF: {
        this._err(ne.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.unexpectedSolidusInTag), this.state = I.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const a = this.currentToken;
    switch (t) {
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentComment(a);
        break;
      }
      case w.EOF: {
        this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.data += lt;
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(Qt.DASH_DASH, !0) ? (this._createCommentToken(Qt.DASH_DASH.length + 1), this.state = I.COMMENT_START) : this._consumeSequenceIfMatch(Qt.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(Qt.DOCTYPE.length + 1), this.state = I.DOCTYPE) : this._consumeSequenceIfMatch(Qt.CDATA_START, !0) ? this.inForeignNode ? this.state = I.CDATA_SECTION : (this._err(ne.cdataInHtmlContent), this._createCommentToken(Qt.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = I.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(ne.incorrectlyOpenedComment), this._createCommentToken(2), this.state = I.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.COMMENT_START_DASH;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptClosingOfEmptyComment), this.state = I.DATA;
        const a = this.currentToken;
        this.emitCurrentComment(a);
        break;
      }
      default:
        this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const a = this.currentToken;
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.COMMENT_END;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptClosingOfEmptyComment), this.state = I.DATA, this.emitCurrentComment(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const a = this.currentToken;
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.COMMENT_END_DASH;
        break;
      }
      case w.LESS_THAN_SIGN: {
        a.data += "<", this.state = I.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.data += lt;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const a = this.currentToken;
    switch (t) {
      case w.EXCLAMATION_MARK: {
        a.data += "!", this.state = I.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case w.LESS_THAN_SIGN: {
        a.data += "<";
        break;
      }
      default:
        this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === w.HYPHEN_MINUS ? this.state = I.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = I.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === w.HYPHEN_MINUS ? this.state = I.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = I.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== w.GREATER_THAN_SIGN && t !== w.EOF && this._err(ne.nestedComment), this.state = I.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const a = this.currentToken;
    switch (t) {
      case w.HYPHEN_MINUS: {
        this.state = I.COMMENT_END;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "-", this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const a = this.currentToken;
    switch (t) {
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentComment(a);
        break;
      }
      case w.EXCLAMATION_MARK: {
        this.state = I.COMMENT_END_BANG;
        break;
      }
      case w.HYPHEN_MINUS: {
        a.data += "-";
        break;
      }
      case w.EOF: {
        this._err(ne.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--", this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const a = this.currentToken;
    switch (t) {
      case w.HYPHEN_MINUS: {
        a.data += "--!", this.state = I.COMMENT_END_DASH;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.incorrectlyClosedComment), this.state = I.DATA, this.emitCurrentComment(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInComment), this.emitCurrentComment(a), this._emitEOFToken();
        break;
      }
      default:
        a.data += "--!", this.state = I.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.BEFORE_DOCTYPE_NAME;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), this._createDoctypeToken(null);
        const a = this.currentToken;
        a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingWhitespaceBeforeDoctypeName), this.state = I.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (Ms(t))
      this._createDoctypeToken(String.fromCharCode(zl(t))), this.state = I.DOCTYPE_NAME;
    else
      switch (t) {
        case w.SPACE:
        case w.LINE_FEED:
        case w.TABULATION:
        case w.FORM_FEED:
          break;
        case w.NULL: {
          this._err(ne.unexpectedNullCharacter), this._createDoctypeToken(lt), this.state = I.DOCTYPE_NAME;
          break;
        }
        case w.GREATER_THAN_SIGN: {
          this._err(ne.missingDoctypeName), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = I.DATA;
          break;
        }
        case w.EOF: {
          this._err(ne.eofInDoctype), this._createDoctypeToken(null);
          const a = this.currentToken;
          a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = I.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.AFTER_DOCTYPE_NAME;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.name += lt;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.name += String.fromCodePoint(Ms(t) ? zl(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Qt.PUBLIC, !1) ? this.state = I.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Qt.SYSTEM, !1) ? this.state = I.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(ne.invalidCharacterSequenceAfterDoctypeName), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case w.QUOTATION_MARK: {
        this._err(ne.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = I.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        this._err(ne.missingWhitespaceAfterDoctypePublicKeyword), a.publicId = "", this.state = I.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.QUOTATION_MARK: {
        a.publicId = "", this.state = I.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        a.publicId = "", this.state = I.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.missingDoctypePublicIdentifier), a.forceQuirks = !0, this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypePublicIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case w.QUOTATION_MARK: {
        this.state = I.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.publicId += lt;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case w.APOSTROPHE: {
        this.state = I.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.publicId += lt;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptDoctypePublicIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.QUOTATION_MARK: {
        this._err(ne.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        this._err(ne.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.QUOTATION_MARK: {
        a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED: {
        this.state = I.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case w.QUOTATION_MARK: {
        this._err(ne.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        this._err(ne.missingWhitespaceAfterDoctypeSystemKeyword), a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.QUOTATION_MARK: {
        a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case w.APOSTROPHE: {
        a.systemId = "", this.state = I.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.missingDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.DATA, this.emitCurrentDoctype(a);
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.missingQuoteBeforeDoctypeSystemIdentifier), a.forceQuirks = !0, this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case w.QUOTATION_MARK: {
        this.state = I.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.systemId += lt;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const a = this.currentToken;
    switch (t) {
      case w.APOSTROPHE: {
        this.state = I.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter), a.systemId += lt;
        break;
      }
      case w.GREATER_THAN_SIGN: {
        this._err(ne.abruptDoctypeSystemIdentifier), a.forceQuirks = !0, this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        a.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const a = this.currentToken;
    switch (t) {
      case w.SPACE:
      case w.LINE_FEED:
      case w.TABULATION:
      case w.FORM_FEED:
        break;
      case w.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInDoctype), a.forceQuirks = !0, this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
      default:
        this._err(ne.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = I.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const a = this.currentToken;
    switch (t) {
      case w.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(a), this.state = I.DATA;
        break;
      }
      case w.NULL: {
        this._err(ne.unexpectedNullCharacter);
        break;
      }
      case w.EOF: {
        this.emitCurrentDoctype(a), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case w.RIGHT_SQUARE_BRACKET: {
        this.state = I.CDATA_SECTION_BRACKET;
        break;
      }
      case w.EOF: {
        this._err(ne.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === w.RIGHT_SQUARE_BRACKET ? this.state = I.CDATA_SECTION_END : (this._emitChars("]"), this.state = I.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case w.GREATER_THAN_SIGN: {
        this.state = I.DATA;
        break;
      }
      case w.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = I.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(w.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Z_(this.preprocessor.peek(1)) ? I.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    Z_(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === w.SEMICOLON && this._err(ne.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const SN = /* @__PURE__ */ new Set([h.DD, h.DT, h.LI, h.OPTGROUP, h.OPTION, h.P, h.RB, h.RP, h.RT, h.RTC]), J_ = /* @__PURE__ */ new Set([
  ...SN,
  h.CAPTION,
  h.COLGROUP,
  h.TBODY,
  h.TD,
  h.TFOOT,
  h.TH,
  h.THEAD,
  h.TR
]), nu = /* @__PURE__ */ new Set([
  h.APPLET,
  h.CAPTION,
  h.HTML,
  h.MARQUEE,
  h.OBJECT,
  h.TABLE,
  h.TD,
  h.TEMPLATE,
  h.TH
]), OM = /* @__PURE__ */ new Set([...nu, h.OL, h.UL]), xM = /* @__PURE__ */ new Set([...nu, h.BUTTON]), eA = /* @__PURE__ */ new Set([h.ANNOTATION_XML, h.MI, h.MN, h.MO, h.MS, h.MTEXT]), tA = /* @__PURE__ */ new Set([h.DESC, h.FOREIGN_OBJECT, h.TITLE]), LM = /* @__PURE__ */ new Set([h.TR, h.TEMPLATE, h.HTML]), DM = /* @__PURE__ */ new Set([h.TBODY, h.TFOOT, h.THEAD, h.TEMPLATE, h.HTML]), MM = /* @__PURE__ */ new Set([h.TABLE, h.TEMPLATE, h.HTML]), UM = /* @__PURE__ */ new Set([h.TD, h.TH]);
class BM {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, a, i) {
    this.treeAdapter = a, this.handler = i, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = h.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === h.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === pe.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, a) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = a, this.currentTagId = a, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, a, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, a) {
    const i = this._indexOf(t);
    this.items[i] = a, i === this.stackTop && (this.current = a);
  }
  insertAfter(t, a, i) {
    const o = this._indexOf(t) + 1;
    this.items.splice(o, 0, a), this.tagIDs.splice(o, 0, i), this.stackTop++, o === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, o === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let a = this.stackTop + 1;
    do
      a = this.tagIDs.lastIndexOf(t, a - 1);
    while (a > 0 && this.treeAdapter.getNamespaceURI(this.items[a]) !== pe.HTML);
    this.shortenToLength(Math.max(a, 0));
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const a = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(a, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const a = this._indexOf(t);
    this.shortenToLength(Math.max(a, 0));
  }
  popUntilPopped(t, a) {
    const i = this._indexOfTagNames(t, a);
    this.shortenToLength(Math.max(i, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(ef, pe.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(UM, pe.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, a) {
    for (let i = this.stackTop; i >= 0; i--)
      if (t.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === a)
        return i;
    return -1;
  }
  clearBackTo(t, a) {
    const i = this._indexOfTagNames(t, a);
    this.shortenToLength(i + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(MM, pe.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(DM, pe.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(LM, pe.HTML);
  }
  remove(t) {
    const a = this._indexOf(t);
    a >= 0 && (a === this.stackTop ? this.pop() : (this.items.splice(a, 1), this.tagIDs.splice(a, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === h.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const a = this._indexOf(t) - 1;
    return a >= 0 ? this.items[a] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === h.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, a) {
    for (let i = this.stackTop; i >= 0; i--) {
      const o = this.tagIDs[i];
      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
        case pe.HTML: {
          if (o === t)
            return !0;
          if (a.has(o))
            return !1;
          break;
        }
        case pe.SVG: {
          if (tA.has(o))
            return !1;
          break;
        }
        case pe.MATHML: {
          if (eA.has(o))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, nu);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, OM);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, xM);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const a = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case pe.HTML: {
          if (ef.has(a))
            return !0;
          if (nu.has(a))
            return !1;
          break;
        }
        case pe.SVG: {
          if (tA.has(a))
            return !1;
          break;
        }
        case pe.MATHML: {
          if (eA.has(a))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let a = this.stackTop; a >= 0; a--)
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === pe.HTML)
        switch (this.tagIDs[a]) {
          case t:
            return !0;
          case h.TABLE:
          case h.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === pe.HTML)
        switch (this.tagIDs[t]) {
          case h.TBODY:
          case h.THEAD:
          case h.TFOOT:
            return !0;
          case h.TABLE:
          case h.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let a = this.stackTop; a >= 0; a--)
      if (this.treeAdapter.getNamespaceURI(this.items[a]) === pe.HTML)
        switch (this.tagIDs[a]) {
          case t:
            return !0;
          case h.OPTION:
          case h.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && SN.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && J_.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== t && J_.has(this.currentTagId); )
      this.pop();
  }
}
const _p = 3;
var Hn;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(Hn || (Hn = {}));
const nA = { type: Hn.Marker };
class FM {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, a) {
    const i = [], o = a.length, l = this.treeAdapter.getTagName(t), c = this.treeAdapter.getNamespaceURI(t);
    for (let d = 0; d < this.entries.length; d++) {
      const m = this.entries[d];
      if (m.type === Hn.Marker)
        break;
      const { element: f } = m;
      if (this.treeAdapter.getTagName(f) === l && this.treeAdapter.getNamespaceURI(f) === c) {
        const b = this.treeAdapter.getAttrList(f);
        b.length === o && i.push({ idx: d, attrs: b });
      }
    }
    return i;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < _p)
      return;
    const a = this.treeAdapter.getAttrList(t), i = this._getNoahArkConditionCandidates(t, a);
    if (i.length < _p)
      return;
    const o = new Map(a.map((c) => [c.name, c.value]));
    let l = 0;
    for (let c = 0; c < i.length; c++) {
      const d = i[c];
      d.attrs.every((m) => o.get(m.name) === m.value) && (l += 1, l >= _p && this.entries.splice(d.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(nA);
  }
  pushElement(t, a) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: Hn.Element,
      element: t,
      token: a
    });
  }
  insertElementAfterBookmark(t, a) {
    const i = this.entries.indexOf(this.bookmark);
    this.entries.splice(i, 0, {
      type: Hn.Element,
      element: t,
      token: a
    });
  }
  removeEntry(t) {
    const a = this.entries.indexOf(t);
    a !== -1 && this.entries.splice(a, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(nA);
    t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const a = this.entries.find((i) => i.type === Hn.Marker || this.treeAdapter.getTagName(i.element) === t);
    return a && a.type === Hn.Element ? a : null;
  }
  getElementEntry(t) {
    return this.entries.find((a) => a.type === Hn.Element && a.element === t);
  }
}
const za = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Nn.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, a) {
    return {
      nodeName: e,
      tagName: e,
      attrs: a,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, a) {
    const i = e.childNodes.indexOf(a);
    e.childNodes.splice(i, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, a, i) {
    const o = e.childNodes.find((l) => l.nodeName === "#documentType");
    if (o)
      o.name = t, o.publicId = a, o.systemId = i;
    else {
      const l = {
        nodeName: "#documentType",
        name: t,
        publicId: a,
        systemId: i,
        parentNode: null
      };
      za.appendChild(e, l);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const a = e.childNodes[e.childNodes.length - 1];
      if (za.isTextNode(a)) {
        a.value += t;
        return;
      }
    }
    za.appendChild(e, za.createTextNode(t));
  },
  insertTextBefore(e, t, a) {
    const i = e.childNodes[e.childNodes.indexOf(a) - 1];
    i && za.isTextNode(i) ? i.value += t : za.insertBefore(e, za.createTextNode(t), a);
  },
  adoptAttributes(e, t) {
    const a = new Set(e.attrs.map((i) => i.name));
    for (let i = 0; i < t.length; i++)
      a.has(t[i].name) || e.attrs.push(t[i]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, _N = "html", PM = "about:legacy-compat", HM = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", AN = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], zM = [
  ...AN,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], GM = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), NN = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], jM = [
  ...NN,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function aA(e, t) {
  return t.some((a) => e.startsWith(a));
}
function $M(e) {
  return e.name === _N && e.publicId === null && (e.systemId === null || e.systemId === PM);
}
function qM(e) {
  if (e.name !== _N)
    return Nn.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === HM)
    return Nn.QUIRKS;
  let { publicId: a } = e;
  if (a !== null) {
    if (a = a.toLowerCase(), GM.has(a))
      return Nn.QUIRKS;
    let i = t === null ? zM : AN;
    if (aA(a, i))
      return Nn.QUIRKS;
    if (i = t === null ? NN : jM, aA(a, i))
      return Nn.LIMITED_QUIRKS;
  }
  return Nn.NO_QUIRKS;
}
const rA = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, YM = "definitionurl", VM = "definitionURL", WM = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), XM = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: pe.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: pe.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: pe.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: pe.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: pe.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: pe.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: pe.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: pe.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: pe.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: pe.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: pe.XMLNS }]
]), KM = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), ZM = /* @__PURE__ */ new Set([
  h.B,
  h.BIG,
  h.BLOCKQUOTE,
  h.BODY,
  h.BR,
  h.CENTER,
  h.CODE,
  h.DD,
  h.DIV,
  h.DL,
  h.DT,
  h.EM,
  h.EMBED,
  h.H1,
  h.H2,
  h.H3,
  h.H4,
  h.H5,
  h.H6,
  h.HEAD,
  h.HR,
  h.I,
  h.IMG,
  h.LI,
  h.LISTING,
  h.MENU,
  h.META,
  h.NOBR,
  h.OL,
  h.P,
  h.PRE,
  h.RUBY,
  h.S,
  h.SMALL,
  h.SPAN,
  h.STRONG,
  h.STRIKE,
  h.SUB,
  h.SUP,
  h.TABLE,
  h.TT,
  h.U,
  h.UL,
  h.VAR
]);
function QM(e) {
  const t = e.tagID;
  return t === h.FONT && e.attrs.some(({ name: i }) => i === mr.COLOR || i === mr.SIZE || i === mr.FACE) || ZM.has(t);
}
function RN(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === YM) {
      e.attrs[t].name = VM;
      break;
    }
}
function vN(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = WM.get(e.attrs[t].name);
    a != null && (e.attrs[t].name = a);
  }
}
function Mf(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const a = XM.get(e.attrs[t].name);
    a && (e.attrs[t].prefix = a.prefix, e.attrs[t].name = a.name, e.attrs[t].namespace = a.namespace);
  }
}
function JM(e) {
  const t = KM.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = Ni(e.tagName));
}
function e6(e, t) {
  return t === pe.MATHML && (e === h.MI || e === h.MO || e === h.MN || e === h.MS || e === h.MTEXT);
}
function t6(e, t, a) {
  if (t === pe.MATHML && e === h.ANNOTATION_XML) {
    for (let i = 0; i < a.length; i++)
      if (a[i].name === mr.ENCODING) {
        const o = a[i].value.toLowerCase();
        return o === rA.TEXT_HTML || o === rA.APPLICATION_XML;
      }
  }
  return t === pe.SVG && (e === h.FOREIGN_OBJECT || e === h.DESC || e === h.TITLE);
}
function n6(e, t, a, i) {
  return (!i || i === pe.HTML) && t6(e, t, a) || (!i || i === pe.MATHML) && e6(e, t);
}
const a6 = "hidden", r6 = 8, i6 = 3;
var M;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(M || (M = {}));
const s6 = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, CN = /* @__PURE__ */ new Set([h.TABLE, h.TBODY, h.TFOOT, h.THEAD, h.TR]), iA = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: za,
  onParseError: null
};
class sA {
  constructor(t, a, i = null, o = null) {
    this.fragmentContext = i, this.scriptHandler = o, this.currentToken = null, this.stopped = !1, this.insertionMode = M.INITIAL, this.originalInsertionMode = M.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...iA,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = a ?? this.treeAdapter.createDocument(), this.tokenizer = new IM(this.options, this), this.activeFormattingElements = new FM(this.treeAdapter), this.fragmentContextID = i ? Ni(this.treeAdapter.getTagName(i)) : h.UNKNOWN, this._setContextModes(i ?? this.document, this.fragmentContextID), this.openElements = new BM(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, a) {
    const i = new this(a);
    return i.tokenizer.write(t, !0), i.document;
  }
  static getFragmentParser(t, a) {
    const i = {
      ...iA,
      ...a
    };
    t ?? (t = i.treeAdapter.createElement(V.TEMPLATE, pe.HTML, []));
    const o = i.treeAdapter.createElement("documentmock", pe.HTML, []), l = new this(i, o, t);
    return l.fragmentContextID === h.TEMPLATE && l.tmplInsertionModeStack.unshift(M.IN_TEMPLATE), l._initTokenizerForFragmentParsing(), l._insertFakeRootElement(), l._resetInsertionMode(), l._findFormInFragmentContext(), l;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), a = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, a), a;
  }
  //Errors
  /** @internal */
  _err(t, a, i) {
    var o;
    if (!this.onParseError)
      return;
    const l = (o = t.location) !== null && o !== void 0 ? o : s6, c = {
      code: a,
      startLine: l.startLine,
      startCol: l.startCol,
      startOffset: l.startOffset,
      endLine: i ? l.startLine : l.endLine,
      endCol: i ? l.startCol : l.endCol,
      endOffset: i ? l.startOffset : l.endOffset
    };
    this.onParseError(c);
  }
  //Stack events
  /** @internal */
  onItemPush(t, a, i) {
    var o, l;
    (l = (o = this.treeAdapter).onItemPush) === null || l === void 0 || l.call(o, t), i && this.openElements.stackTop > 0 && this._setContextModes(t, a);
  }
  /** @internal */
  onItemPop(t, a) {
    var i, o;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (o = (i = this.treeAdapter).onItemPop) === null || o === void 0 || o.call(i, t, this.openElements.current), a) {
      let l, c;
      this.openElements.stackTop === 0 && this.fragmentContext ? (l = this.fragmentContext, c = this.fragmentContextID) : { current: l, currentTagId: c } = this.openElements, this._setContextModes(l, c);
    }
  }
  _setContextModes(t, a) {
    const i = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === pe.HTML;
    this.currentNotInHTML = !i, this.tokenizer.inForeignNode = !i && t !== void 0 && a !== void 0 && !this._isIntegrationPoint(a, t);
  }
  /** @protected */
  _switchToTextParsing(t, a) {
    this._insertElement(t, pe.HTML), this.tokenizer.state = a, this.originalInsertionMode = this.insertionMode, this.insertionMode = M.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = M.TEXT, this.originalInsertionMode = M.IN_BODY, this.tokenizer.state = mt.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === V.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== pe.HTML))
      switch (this.fragmentContextID) {
        case h.TITLE:
        case h.TEXTAREA: {
          this.tokenizer.state = mt.RCDATA;
          break;
        }
        case h.STYLE:
        case h.XMP:
        case h.IFRAME:
        case h.NOEMBED:
        case h.NOFRAMES:
        case h.NOSCRIPT: {
          this.tokenizer.state = mt.RAWTEXT;
          break;
        }
        case h.SCRIPT: {
          this.tokenizer.state = mt.SCRIPT_DATA;
          break;
        }
        case h.PLAINTEXT: {
          this.tokenizer.state = mt.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const a = t.name || "", i = t.publicId || "", o = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, a, i, o), t.location) {
      const c = this.treeAdapter.getChildNodes(this.document).find((d) => this.treeAdapter.isDocumentTypeNode(d));
      c && this.treeAdapter.setNodeSourceCodeLocation(c, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, a) {
    if (this.options.sourceCodeLocationInfo) {
      const i = a && {
        ...a,
        startTag: a
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, i);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const i = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(i ?? this.document, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, a) {
    const i = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(i, t.location);
  }
  /** @protected */
  _insertElement(t, a) {
    const i = this.treeAdapter.createElement(t.tagName, a, t.attrs);
    this._attachElementToTree(i, t.location), this.openElements.push(i, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, a) {
    const i = this.treeAdapter.createElement(t, pe.HTML, []);
    this._attachElementToTree(i, null), this.openElements.push(i, a);
  }
  /** @protected */
  _insertTemplate(t) {
    const a = this.treeAdapter.createElement(t.tagName, pe.HTML, t.attrs), i = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(a, i), this._attachElementToTree(a, t.location), this.openElements.push(a, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(V.HTML, pe.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, h.HTML);
  }
  /** @protected */
  _appendCommentNode(t, a) {
    const i = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(a, i), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let a, i;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: a, beforeElement: i } = this._findFosterParentingLocation(), i ? this.treeAdapter.insertTextBefore(a, t.chars, i) : this.treeAdapter.insertText(a, t.chars)) : (a = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(a, t.chars)), !t.location)
      return;
    const o = this.treeAdapter.getChildNodes(a), l = i ? o.lastIndexOf(i) : o.length, c = o[l - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(c)) {
      const { endLine: m, endCol: f, endOffset: b } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(c, { endLine: m, endCol: f, endOffset: b });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(c, t.location);
  }
  /** @protected */
  _adoptNodes(t, a) {
    for (let i = this.treeAdapter.getFirstChild(t); i; i = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(i), this.treeAdapter.appendChild(a, i);
  }
  /** @protected */
  _setEndLocation(t, a) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && a.location) {
      const i = a.location, o = this.treeAdapter.getTagName(t), l = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        a.type === De.END_TAG && o === a.tagName ? {
          endTag: { ...i },
          endLine: i.endLine,
          endCol: i.endCol,
          endOffset: i.endOffset
        } : {
          endLine: i.startLine,
          endCol: i.startCol,
          endOffset: i.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, l);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let a, i;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, i = this.fragmentContextID) : { current: a, currentTagId: i } = this.openElements, t.tagID === h.SVG && this.treeAdapter.getTagName(a) === V.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(a) === pe.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === h.MGLYPH || t.tagID === h.MALIGNMARK) && i !== void 0 && !this._isIntegrationPoint(i, a, pe.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case De.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case De.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case De.COMMENT: {
        this.onComment(t);
        break;
      }
      case De.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case De.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case De.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case De.EOF: {
        this.onEof(t);
        break;
      }
      case De.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, a, i) {
    const o = this.treeAdapter.getNamespaceURI(a), l = this.treeAdapter.getAttrList(a);
    return n6(t, o, l, i);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const a = this.activeFormattingElements.entries.findIndex((o) => o.type === Hn.Marker || this.openElements.contains(o.element)), i = a === -1 ? t - 1 : a - 1;
      for (let o = i; o >= 0; o--) {
        const l = this.activeFormattingElements.entries[o];
        this._insertElement(l.token, this.treeAdapter.getNamespaceURI(l.element)), l.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = M.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(h.P), this.openElements.popUntilTagNamePopped(h.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case h.TR: {
          this.insertionMode = M.IN_ROW;
          return;
        }
        case h.TBODY:
        case h.THEAD:
        case h.TFOOT: {
          this.insertionMode = M.IN_TABLE_BODY;
          return;
        }
        case h.CAPTION: {
          this.insertionMode = M.IN_CAPTION;
          return;
        }
        case h.COLGROUP: {
          this.insertionMode = M.IN_COLUMN_GROUP;
          return;
        }
        case h.TABLE: {
          this.insertionMode = M.IN_TABLE;
          return;
        }
        case h.BODY: {
          this.insertionMode = M.IN_BODY;
          return;
        }
        case h.FRAMESET: {
          this.insertionMode = M.IN_FRAMESET;
          return;
        }
        case h.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case h.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case h.HTML: {
          this.insertionMode = this.headElement ? M.AFTER_HEAD : M.BEFORE_HEAD;
          return;
        }
        case h.TD:
        case h.TH: {
          if (t > 0) {
            this.insertionMode = M.IN_CELL;
            return;
          }
          break;
        }
        case h.HEAD: {
          if (t > 0) {
            this.insertionMode = M.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = M.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let a = t - 1; a > 0; a--) {
        const i = this.openElements.tagIDs[a];
        if (i === h.TEMPLATE)
          break;
        if (i === h.TABLE) {
          this.insertionMode = M.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = M.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return CN.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const a = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case h.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(a) === pe.HTML)
            return { parent: this.treeAdapter.getTemplateContent(a), beforeElement: null };
          break;
        }
        case h.TABLE: {
          const i = this.treeAdapter.getParentNode(a);
          return i ? { parent: i, beforeElement: a } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const a = this._findFosterParentingLocation();
    a.beforeElement ? this.treeAdapter.insertBefore(a.parent, t, a.beforeElement) : this.treeAdapter.appendChild(a.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, a) {
    const i = this.treeAdapter.getNamespaceURI(t);
    return vM[i].has(a);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      UU(this, t);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL: {
        xs(this, t);
        break;
      }
      case M.BEFORE_HTML: {
        Hs(this, t);
        break;
      }
      case M.BEFORE_HEAD: {
        zs(this, t);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, t);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        js(this, t);
        break;
      }
      case M.AFTER_HEAD: {
        $s(this, t);
        break;
      }
      case M.IN_BODY:
      case M.IN_CAPTION:
      case M.IN_CELL:
      case M.IN_TEMPLATE: {
        kN(this, t);
        break;
      }
      case M.TEXT:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        Ap(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        MN(this, t);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        au(this, t);
        break;
      }
      case M.AFTER_BODY: {
        ru(this, t);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        Vl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      MU(this, t);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL: {
        xs(this, t);
        break;
      }
      case M.BEFORE_HTML: {
        Hs(this, t);
        break;
      }
      case M.BEFORE_HEAD: {
        zs(this, t);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, t);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        js(this, t);
        break;
      }
      case M.AFTER_HEAD: {
        $s(this, t);
        break;
      }
      case M.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        Ap(this, t);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        au(this, t);
        break;
      }
      case M.AFTER_BODY: {
        ru(this, t);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        Vl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      tf(this, t);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL:
      case M.BEFORE_HTML:
      case M.BEFORE_HEAD:
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD:
      case M.IN_BODY:
      case M.IN_TABLE:
      case M.IN_CAPTION:
      case M.IN_COLUMN_GROUP:
      case M.IN_TABLE_BODY:
      case M.IN_ROW:
      case M.IN_CELL:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE:
      case M.IN_TEMPLATE:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET: {
        tf(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Ls(this, t);
        break;
      }
      case M.AFTER_BODY: {
        f6(this, t);
        break;
      }
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        m6(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case M.INITIAL: {
        g6(this, t);
        break;
      }
      case M.BEFORE_HEAD:
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD: {
        this._err(t, ne.misplacedDoctype);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Ls(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, ne.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? BU(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        xs(this, t);
        break;
      }
      case M.BEFORE_HTML: {
        h6(this, t);
        break;
      }
      case M.BEFORE_HEAD: {
        E6(this, t);
        break;
      }
      case M.IN_HEAD: {
        Dn(this, t);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        S6(this, t);
        break;
      }
      case M.AFTER_HEAD: {
        A6(this, t);
        break;
      }
      case M.IN_BODY: {
        Ut(this, t);
        break;
      }
      case M.IN_TABLE: {
        Ei(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Ls(this, t);
        break;
      }
      case M.IN_CAPTION: {
        yU(this, t);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        Ff(this, t);
        break;
      }
      case M.IN_TABLE_BODY: {
        Tu(this, t);
        break;
      }
      case M.IN_ROW: {
        Su(this, t);
        break;
      }
      case M.IN_CELL: {
        _U(this, t);
        break;
      }
      case M.IN_SELECT: {
        FN(this, t);
        break;
      }
      case M.IN_SELECT_IN_TABLE: {
        NU(this, t);
        break;
      }
      case M.IN_TEMPLATE: {
        vU(this, t);
        break;
      }
      case M.AFTER_BODY: {
        wU(this, t);
        break;
      }
      case M.IN_FRAMESET: {
        kU(this, t);
        break;
      }
      case M.AFTER_FRAMESET: {
        OU(this, t);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        LU(this, t);
        break;
      }
      case M.AFTER_AFTER_FRAMESET: {
        DU(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? FU(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        xs(this, t);
        break;
      }
      case M.BEFORE_HTML: {
        b6(this, t);
        break;
      }
      case M.BEFORE_HEAD: {
        y6(this, t);
        break;
      }
      case M.IN_HEAD: {
        T6(this, t);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        _6(this, t);
        break;
      }
      case M.AFTER_HEAD: {
        N6(this, t);
        break;
      }
      case M.IN_BODY: {
        yu(this, t);
        break;
      }
      case M.TEXT: {
        uU(this, t);
        break;
      }
      case M.IN_TABLE: {
        Zs(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Ls(this, t);
        break;
      }
      case M.IN_CAPTION: {
        TU(this, t);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        SU(this, t);
        break;
      }
      case M.IN_TABLE_BODY: {
        nf(this, t);
        break;
      }
      case M.IN_ROW: {
        BN(this, t);
        break;
      }
      case M.IN_CELL: {
        AU(this, t);
        break;
      }
      case M.IN_SELECT: {
        PN(this, t);
        break;
      }
      case M.IN_SELECT_IN_TABLE: {
        RU(this, t);
        break;
      }
      case M.IN_TEMPLATE: {
        CU(this, t);
        break;
      }
      case M.AFTER_BODY: {
        zN(this, t);
        break;
      }
      case M.IN_FRAMESET: {
        IU(this, t);
        break;
      }
      case M.AFTER_FRAMESET: {
        xU(this, t);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        Vl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        xs(this, t);
        break;
      }
      case M.BEFORE_HTML: {
        Hs(this, t);
        break;
      }
      case M.BEFORE_HEAD: {
        zs(this, t);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, t);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        js(this, t);
        break;
      }
      case M.AFTER_HEAD: {
        $s(this, t);
        break;
      }
      case M.IN_BODY:
      case M.IN_TABLE:
      case M.IN_CAPTION:
      case M.IN_COLUMN_GROUP:
      case M.IN_TABLE_BODY:
      case M.IN_ROW:
      case M.IN_CELL:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE: {
        LN(this, t);
        break;
      }
      case M.TEXT: {
        cU(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Ls(this, t);
        break;
      }
      case M.IN_TEMPLATE: {
        HN(this, t);
        break;
      }
      case M.AFTER_BODY:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET:
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        Bf(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === w.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD:
      case M.TEXT:
      case M.IN_COLUMN_GROUP:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case M.IN_BODY:
      case M.IN_CAPTION:
      case M.IN_CELL:
      case M.IN_TEMPLATE:
      case M.AFTER_BODY:
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        wN(this, t);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        Ap(this, t);
        break;
      }
      case M.IN_TABLE_TEXT: {
        DN(this, t);
        break;
      }
    }
  }
}
function o6(e, t) {
  let a = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return a ? e.openElements.contains(a.element) ? e.openElements.hasInScope(t.tagID) || (a = null) : (e.activeFormattingElements.removeEntry(a), a = null) : xN(e, t), a;
}
function l6(e, t) {
  let a = null, i = e.openElements.stackTop;
  for (; i >= 0; i--) {
    const o = e.openElements.items[i];
    if (o === t.element)
      break;
    e._isSpecialElement(o, e.openElements.tagIDs[i]) && (a = o);
  }
  return a || (e.openElements.shortenToLength(Math.max(i, 0)), e.activeFormattingElements.removeEntry(t)), a;
}
function u6(e, t, a) {
  let i = t, o = e.openElements.getCommonAncestor(t);
  for (let l = 0, c = o; c !== a; l++, c = o) {
    o = e.openElements.getCommonAncestor(c);
    const d = e.activeFormattingElements.getElementEntry(c), m = d && l >= i6;
    !d || m ? (m && e.activeFormattingElements.removeEntry(d), e.openElements.remove(c)) : (c = c6(e, d), i === t && (e.activeFormattingElements.bookmark = d), e.treeAdapter.detachNode(i), e.treeAdapter.appendChild(c, i), i = c);
  }
  return i;
}
function c6(e, t) {
  const a = e.treeAdapter.getNamespaceURI(t.element), i = e.treeAdapter.createElement(t.token.tagName, a, t.token.attrs);
  return e.openElements.replace(t.element, i), t.element = i, i;
}
function d6(e, t, a) {
  const i = e.treeAdapter.getTagName(t), o = Ni(i);
  if (e._isElementCausesFosterParenting(o))
    e._fosterParentElement(a);
  else {
    const l = e.treeAdapter.getNamespaceURI(t);
    o === h.TEMPLATE && l === pe.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, a);
  }
}
function p6(e, t, a) {
  const i = e.treeAdapter.getNamespaceURI(a.element), { token: o } = a, l = e.treeAdapter.createElement(o.tagName, i, o.attrs);
  e._adoptNodes(t, l), e.treeAdapter.appendChild(t, l), e.activeFormattingElements.insertElementAfterBookmark(l, o), e.activeFormattingElements.removeEntry(a), e.openElements.remove(a.element), e.openElements.insertAfter(t, l, o.tagID);
}
function Uf(e, t) {
  for (let a = 0; a < r6; a++) {
    const i = o6(e, t);
    if (!i)
      break;
    const o = l6(e, i);
    if (!o)
      break;
    e.activeFormattingElements.bookmark = i;
    const l = u6(e, o, i.element), c = e.openElements.getCommonAncestor(i.element);
    e.treeAdapter.detachNode(l), c && d6(e, c, l), p6(e, o, i);
  }
}
function tf(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function f6(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function m6(e, t) {
  e._appendCommentNode(t, e.document);
}
function Bf(e, t) {
  if (e.stopped = !0, t.location) {
    const a = e.fragmentContext ? 0 : 2;
    for (let i = e.openElements.stackTop; i >= a; i--)
      e._setEndLocation(e.openElements.items[i], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const i = e.openElements.items[0], o = e.treeAdapter.getNodeSourceCodeLocation(i);
      if (o && !o.endTag && (e._setEndLocation(i, t), e.openElements.stackTop >= 1)) {
        const l = e.openElements.items[1], c = e.treeAdapter.getNodeSourceCodeLocation(l);
        c && !c.endTag && e._setEndLocation(l, t);
      }
    }
  }
}
function g6(e, t) {
  e._setDocumentType(t);
  const a = t.forceQuirks ? Nn.QUIRKS : qM(t);
  $M(t) || e._err(t, ne.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, a), e.insertionMode = M.BEFORE_HTML;
}
function xs(e, t) {
  e._err(t, ne.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Nn.QUIRKS), e.insertionMode = M.BEFORE_HTML, e._processToken(t);
}
function h6(e, t) {
  t.tagID === h.HTML ? (e._insertElement(t, pe.HTML), e.insertionMode = M.BEFORE_HEAD) : Hs(e, t);
}
function b6(e, t) {
  const a = t.tagID;
  (a === h.HTML || a === h.HEAD || a === h.BODY || a === h.BR) && Hs(e, t);
}
function Hs(e, t) {
  e._insertFakeRootElement(), e.insertionMode = M.BEFORE_HEAD, e._processToken(t);
}
function E6(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.HEAD: {
      e._insertElement(t, pe.HTML), e.headElement = e.openElements.current, e.insertionMode = M.IN_HEAD;
      break;
    }
    default:
      zs(e, t);
  }
}
function y6(e, t) {
  const a = t.tagID;
  a === h.HEAD || a === h.BODY || a === h.HTML || a === h.BR ? zs(e, t) : e._err(t, ne.endTagWithoutMatchingOpenElement);
}
function zs(e, t) {
  e._insertFakeElement(V.HEAD, h.HEAD), e.headElement = e.openElements.current, e.insertionMode = M.IN_HEAD, e._processToken(t);
}
function Dn(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.BASE:
    case h.BASEFONT:
    case h.BGSOUND:
    case h.LINK:
    case h.META: {
      e._appendElement(t, pe.HTML), t.ackSelfClosing = !0;
      break;
    }
    case h.TITLE: {
      e._switchToTextParsing(t, mt.RCDATA);
      break;
    }
    case h.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, mt.RAWTEXT) : (e._insertElement(t, pe.HTML), e.insertionMode = M.IN_HEAD_NO_SCRIPT);
      break;
    }
    case h.NOFRAMES:
    case h.STYLE: {
      e._switchToTextParsing(t, mt.RAWTEXT);
      break;
    }
    case h.SCRIPT: {
      e._switchToTextParsing(t, mt.SCRIPT_DATA);
      break;
    }
    case h.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = M.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(M.IN_TEMPLATE);
      break;
    }
    case h.HEAD: {
      e._err(t, ne.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Gs(e, t);
  }
}
function T6(e, t) {
  switch (t.tagID) {
    case h.HEAD: {
      e.openElements.pop(), e.insertionMode = M.AFTER_HEAD;
      break;
    }
    case h.BODY:
    case h.BR:
    case h.HTML: {
      Gs(e, t);
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
    default:
      e._err(t, ne.endTagWithoutMatchingOpenElement);
  }
}
function Tr(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== h.TEMPLATE && e._err(t, ne.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(h.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, ne.endTagWithoutMatchingOpenElement);
}
function Gs(e, t) {
  e.openElements.pop(), e.insertionMode = M.AFTER_HEAD, e._processToken(t);
}
function S6(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.BASEFONT:
    case h.BGSOUND:
    case h.HEAD:
    case h.LINK:
    case h.META:
    case h.NOFRAMES:
    case h.STYLE: {
      Dn(e, t);
      break;
    }
    case h.NOSCRIPT: {
      e._err(t, ne.nestedNoscriptInHead);
      break;
    }
    default:
      js(e, t);
  }
}
function _6(e, t) {
  switch (t.tagID) {
    case h.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = M.IN_HEAD;
      break;
    }
    case h.BR: {
      js(e, t);
      break;
    }
    default:
      e._err(t, ne.endTagWithoutMatchingOpenElement);
  }
}
function js(e, t) {
  const a = t.type === De.EOF ? ne.openElementsLeftAfterEof : ne.disallowedContentInNoscriptInHead;
  e._err(t, a), e.openElements.pop(), e.insertionMode = M.IN_HEAD, e._processToken(t);
}
function A6(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.BODY: {
      e._insertElement(t, pe.HTML), e.framesetOk = !1, e.insertionMode = M.IN_BODY;
      break;
    }
    case h.FRAMESET: {
      e._insertElement(t, pe.HTML), e.insertionMode = M.IN_FRAMESET;
      break;
    }
    case h.BASE:
    case h.BASEFONT:
    case h.BGSOUND:
    case h.LINK:
    case h.META:
    case h.NOFRAMES:
    case h.SCRIPT:
    case h.STYLE:
    case h.TEMPLATE:
    case h.TITLE: {
      e._err(t, ne.abandonedHeadElementChild), e.openElements.push(e.headElement, h.HEAD), Dn(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case h.HEAD: {
      e._err(t, ne.misplacedStartTagForHeadElement);
      break;
    }
    default:
      $s(e, t);
  }
}
function N6(e, t) {
  switch (t.tagID) {
    case h.BODY:
    case h.HTML:
    case h.BR: {
      $s(e, t);
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
    default:
      e._err(t, ne.endTagWithoutMatchingOpenElement);
  }
}
function $s(e, t) {
  e._insertFakeElement(V.BODY, h.BODY), e.insertionMode = M.IN_BODY, Eu(e, t);
}
function Eu(e, t) {
  switch (t.type) {
    case De.CHARACTER: {
      kN(e, t);
      break;
    }
    case De.WHITESPACE_CHARACTER: {
      wN(e, t);
      break;
    }
    case De.COMMENT: {
      tf(e, t);
      break;
    }
    case De.START_TAG: {
      Ut(e, t);
      break;
    }
    case De.END_TAG: {
      yu(e, t);
      break;
    }
    case De.EOF: {
      LN(e, t);
      break;
    }
  }
}
function wN(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function kN(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function R6(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function v6(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  a && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(a, t.attrs));
}
function C6(e, t) {
  const a = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && a && (e.treeAdapter.detachNode(a), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_FRAMESET);
}
function w6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML);
}
function k6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && ef.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, pe.HTML);
}
function I6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function O6(e, t) {
  const a = e.openElements.tmplCount > 0;
  (!e.formElement || a) && (e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML), a || (e.formElement = e.openElements.current));
}
function x6(e, t) {
  e.framesetOk = !1;
  const a = t.tagID;
  for (let i = e.openElements.stackTop; i >= 0; i--) {
    const o = e.openElements.tagIDs[i];
    if (a === h.LI && o === h.LI || (a === h.DD || a === h.DT) && (o === h.DD || o === h.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(o), e.openElements.popUntilTagNamePopped(o);
      break;
    }
    if (o !== h.ADDRESS && o !== h.DIV && o !== h.P && e._isSpecialElement(e.openElements.items[i], o))
      break;
  }
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML);
}
function L6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML), e.tokenizer.state = mt.PLAINTEXT;
}
function D6(e, t) {
  e.openElements.hasInScope(h.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(h.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML), e.framesetOk = !1;
}
function M6(e, t) {
  const a = e.activeFormattingElements.getElementEntryInScopeWithTagName(V.A);
  a && (Uf(e, t), e.openElements.remove(a.element), e.activeFormattingElements.removeEntry(a)), e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function U6(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function B6(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(h.NOBR) && (Uf(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, pe.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function F6(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function P6(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Nn.QUIRKS && e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._insertElement(t, pe.HTML), e.framesetOk = !1, e.insertionMode = M.IN_TABLE;
}
function IN(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, pe.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function ON(e) {
  const t = yN(e, mr.TYPE);
  return t != null && t.toLowerCase() === a6;
}
function H6(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, pe.HTML), ON(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function z6(e, t) {
  e._appendElement(t, pe.HTML), t.ackSelfClosing = !0;
}
function G6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._appendElement(t, pe.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function j6(e, t) {
  t.tagName = V.IMG, t.tagID = h.IMG, IN(e, t);
}
function $6(e, t) {
  e._insertElement(t, pe.HTML), e.skipNextNewLine = !0, e.tokenizer.state = mt.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = M.TEXT;
}
function q6(e, t) {
  e.openElements.hasInButtonScope(h.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, mt.RAWTEXT);
}
function Y6(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, mt.RAWTEXT);
}
function oA(e, t) {
  e._switchToTextParsing(t, mt.RAWTEXT);
}
function V6(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === M.IN_TABLE || e.insertionMode === M.IN_CAPTION || e.insertionMode === M.IN_TABLE_BODY || e.insertionMode === M.IN_ROW || e.insertionMode === M.IN_CELL ? M.IN_SELECT_IN_TABLE : M.IN_SELECT;
}
function W6(e, t) {
  e.openElements.currentTagId === h.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML);
}
function X6(e, t) {
  e.openElements.hasInScope(h.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, pe.HTML);
}
function K6(e, t) {
  e.openElements.hasInScope(h.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(h.RTC), e._insertElement(t, pe.HTML);
}
function Z6(e, t) {
  e._reconstructActiveFormattingElements(), RN(t), Mf(t), t.selfClosing ? e._appendElement(t, pe.MATHML) : e._insertElement(t, pe.MATHML), t.ackSelfClosing = !0;
}
function Q6(e, t) {
  e._reconstructActiveFormattingElements(), vN(t), Mf(t), t.selfClosing ? e._appendElement(t, pe.SVG) : e._insertElement(t, pe.SVG), t.ackSelfClosing = !0;
}
function lA(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, pe.HTML);
}
function Ut(e, t) {
  switch (t.tagID) {
    case h.I:
    case h.S:
    case h.B:
    case h.U:
    case h.EM:
    case h.TT:
    case h.BIG:
    case h.CODE:
    case h.FONT:
    case h.SMALL:
    case h.STRIKE:
    case h.STRONG: {
      U6(e, t);
      break;
    }
    case h.A: {
      M6(e, t);
      break;
    }
    case h.H1:
    case h.H2:
    case h.H3:
    case h.H4:
    case h.H5:
    case h.H6: {
      k6(e, t);
      break;
    }
    case h.P:
    case h.DL:
    case h.OL:
    case h.UL:
    case h.DIV:
    case h.DIR:
    case h.NAV:
    case h.MAIN:
    case h.MENU:
    case h.ASIDE:
    case h.CENTER:
    case h.FIGURE:
    case h.FOOTER:
    case h.HEADER:
    case h.HGROUP:
    case h.DIALOG:
    case h.DETAILS:
    case h.ADDRESS:
    case h.ARTICLE:
    case h.SEARCH:
    case h.SECTION:
    case h.SUMMARY:
    case h.FIELDSET:
    case h.BLOCKQUOTE:
    case h.FIGCAPTION: {
      w6(e, t);
      break;
    }
    case h.LI:
    case h.DD:
    case h.DT: {
      x6(e, t);
      break;
    }
    case h.BR:
    case h.IMG:
    case h.WBR:
    case h.AREA:
    case h.EMBED:
    case h.KEYGEN: {
      IN(e, t);
      break;
    }
    case h.HR: {
      G6(e, t);
      break;
    }
    case h.RB:
    case h.RTC: {
      X6(e, t);
      break;
    }
    case h.RT:
    case h.RP: {
      K6(e, t);
      break;
    }
    case h.PRE:
    case h.LISTING: {
      I6(e, t);
      break;
    }
    case h.XMP: {
      q6(e, t);
      break;
    }
    case h.SVG: {
      Q6(e, t);
      break;
    }
    case h.HTML: {
      R6(e, t);
      break;
    }
    case h.BASE:
    case h.LINK:
    case h.META:
    case h.STYLE:
    case h.TITLE:
    case h.SCRIPT:
    case h.BGSOUND:
    case h.BASEFONT:
    case h.TEMPLATE: {
      Dn(e, t);
      break;
    }
    case h.BODY: {
      v6(e, t);
      break;
    }
    case h.FORM: {
      O6(e, t);
      break;
    }
    case h.NOBR: {
      B6(e, t);
      break;
    }
    case h.MATH: {
      Z6(e, t);
      break;
    }
    case h.TABLE: {
      P6(e, t);
      break;
    }
    case h.INPUT: {
      H6(e, t);
      break;
    }
    case h.PARAM:
    case h.TRACK:
    case h.SOURCE: {
      z6(e, t);
      break;
    }
    case h.IMAGE: {
      j6(e, t);
      break;
    }
    case h.BUTTON: {
      D6(e, t);
      break;
    }
    case h.APPLET:
    case h.OBJECT:
    case h.MARQUEE: {
      F6(e, t);
      break;
    }
    case h.IFRAME: {
      Y6(e, t);
      break;
    }
    case h.SELECT: {
      V6(e, t);
      break;
    }
    case h.OPTION:
    case h.OPTGROUP: {
      W6(e, t);
      break;
    }
    case h.NOEMBED:
    case h.NOFRAMES: {
      oA(e, t);
      break;
    }
    case h.FRAMESET: {
      C6(e, t);
      break;
    }
    case h.TEXTAREA: {
      $6(e, t);
      break;
    }
    case h.NOSCRIPT: {
      e.options.scriptingEnabled ? oA(e, t) : lA(e, t);
      break;
    }
    case h.PLAINTEXT: {
      L6(e, t);
      break;
    }
    case h.COL:
    case h.TH:
    case h.TD:
    case h.TR:
    case h.HEAD:
    case h.FRAME:
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD:
    case h.CAPTION:
    case h.COLGROUP:
      break;
    default:
      lA(e, t);
  }
}
function J6(e, t) {
  if (e.openElements.hasInScope(h.BODY) && (e.insertionMode = M.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const a = e.openElements.tryPeekProperlyNestedBodyElement();
    a && e._setEndLocation(a, t);
  }
}
function eU(e, t) {
  e.openElements.hasInScope(h.BODY) && (e.insertionMode = M.AFTER_BODY, zN(e, t));
}
function tU(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a));
}
function nU(e) {
  const t = e.openElements.tmplCount > 0, { formElement: a } = e;
  t || (e.formElement = null), (a || t) && e.openElements.hasInScope(h.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(h.FORM) : a && e.openElements.remove(a));
}
function aU(e) {
  e.openElements.hasInButtonScope(h.P) || e._insertFakeElement(V.P, h.P), e._closePElement();
}
function rU(e) {
  e.openElements.hasInListItemScope(h.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(h.LI), e.openElements.popUntilTagNamePopped(h.LI));
}
function iU(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a));
}
function sU(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function oU(e, t) {
  const a = t.tagID;
  e.openElements.hasInScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker());
}
function lU(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(V.BR, h.BR), e.openElements.pop(), e.framesetOk = !1;
}
function xN(e, t) {
  const a = t.tagName, i = t.tagID;
  for (let o = e.openElements.stackTop; o > 0; o--) {
    const l = e.openElements.items[o], c = e.openElements.tagIDs[o];
    if (i === c && (i !== h.UNKNOWN || e.treeAdapter.getTagName(l) === a)) {
      e.openElements.generateImpliedEndTagsWithExclusion(i), e.openElements.stackTop >= o && e.openElements.shortenToLength(o);
      break;
    }
    if (e._isSpecialElement(l, c))
      break;
  }
}
function yu(e, t) {
  switch (t.tagID) {
    case h.A:
    case h.B:
    case h.I:
    case h.S:
    case h.U:
    case h.EM:
    case h.TT:
    case h.BIG:
    case h.CODE:
    case h.FONT:
    case h.NOBR:
    case h.SMALL:
    case h.STRIKE:
    case h.STRONG: {
      Uf(e, t);
      break;
    }
    case h.P: {
      aU(e);
      break;
    }
    case h.DL:
    case h.UL:
    case h.OL:
    case h.DIR:
    case h.DIV:
    case h.NAV:
    case h.PRE:
    case h.MAIN:
    case h.MENU:
    case h.ASIDE:
    case h.BUTTON:
    case h.CENTER:
    case h.FIGURE:
    case h.FOOTER:
    case h.HEADER:
    case h.HGROUP:
    case h.DIALOG:
    case h.ADDRESS:
    case h.ARTICLE:
    case h.DETAILS:
    case h.SEARCH:
    case h.SECTION:
    case h.SUMMARY:
    case h.LISTING:
    case h.FIELDSET:
    case h.BLOCKQUOTE:
    case h.FIGCAPTION: {
      tU(e, t);
      break;
    }
    case h.LI: {
      rU(e);
      break;
    }
    case h.DD:
    case h.DT: {
      iU(e, t);
      break;
    }
    case h.H1:
    case h.H2:
    case h.H3:
    case h.H4:
    case h.H5:
    case h.H6: {
      sU(e);
      break;
    }
    case h.BR: {
      lU(e);
      break;
    }
    case h.BODY: {
      J6(e, t);
      break;
    }
    case h.HTML: {
      eU(e, t);
      break;
    }
    case h.FORM: {
      nU(e);
      break;
    }
    case h.APPLET:
    case h.OBJECT:
    case h.MARQUEE: {
      oU(e, t);
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
    default:
      xN(e, t);
  }
}
function LN(e, t) {
  e.tmplInsertionModeStack.length > 0 ? HN(e, t) : Bf(e, t);
}
function uU(e, t) {
  var a;
  t.tagID === h.SCRIPT && ((a = e.scriptHandler) === null || a === void 0 || a.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function cU(e, t) {
  e._err(t, ne.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Ap(e, t) {
  if (e.openElements.currentTagId !== void 0 && CN.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = M.IN_TABLE_TEXT, t.type) {
      case De.CHARACTER: {
        MN(e, t);
        break;
      }
      case De.WHITESPACE_CHARACTER: {
        DN(e, t);
        break;
      }
    }
  else
    oo(e, t);
}
function dU(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_CAPTION;
}
function pU(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_COLUMN_GROUP;
}
function fU(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(V.COLGROUP, h.COLGROUP), e.insertionMode = M.IN_COLUMN_GROUP, Ff(e, t);
}
function mU(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_TABLE_BODY;
}
function gU(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(V.TBODY, h.TBODY), e.insertionMode = M.IN_TABLE_BODY, Tu(e, t);
}
function hU(e, t) {
  e.openElements.hasInTableScope(h.TABLE) && (e.openElements.popUntilTagNamePopped(h.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function bU(e, t) {
  ON(t) ? e._appendElement(t, pe.HTML) : oo(e, t), t.ackSelfClosing = !0;
}
function EU(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, pe.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Ei(e, t) {
  switch (t.tagID) {
    case h.TD:
    case h.TH:
    case h.TR: {
      gU(e, t);
      break;
    }
    case h.STYLE:
    case h.SCRIPT:
    case h.TEMPLATE: {
      Dn(e, t);
      break;
    }
    case h.COL: {
      fU(e, t);
      break;
    }
    case h.FORM: {
      EU(e, t);
      break;
    }
    case h.TABLE: {
      hU(e, t);
      break;
    }
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD: {
      mU(e, t);
      break;
    }
    case h.INPUT: {
      bU(e, t);
      break;
    }
    case h.CAPTION: {
      dU(e, t);
      break;
    }
    case h.COLGROUP: {
      pU(e, t);
      break;
    }
    default:
      oo(e, t);
  }
}
function Zs(e, t) {
  switch (t.tagID) {
    case h.TABLE: {
      e.openElements.hasInTableScope(h.TABLE) && (e.openElements.popUntilTagNamePopped(h.TABLE), e._resetInsertionMode());
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
    case h.BODY:
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.HTML:
    case h.TBODY:
    case h.TD:
    case h.TFOOT:
    case h.TH:
    case h.THEAD:
    case h.TR:
      break;
    default:
      oo(e, t);
  }
}
function oo(e, t) {
  const a = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Eu(e, t), e.fosterParentingEnabled = a;
}
function DN(e, t) {
  e.pendingCharacterTokens.push(t);
}
function MN(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Ls(e, t) {
  let a = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; a < e.pendingCharacterTokens.length; a++)
      oo(e, e.pendingCharacterTokens[a]);
  else
    for (; a < e.pendingCharacterTokens.length; a++)
      e._insertCharacters(e.pendingCharacterTokens[a]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const UN = /* @__PURE__ */ new Set([h.CAPTION, h.COL, h.COLGROUP, h.TBODY, h.TD, h.TFOOT, h.TH, h.THEAD, h.TR]);
function yU(e, t) {
  const a = t.tagID;
  UN.has(a) ? e.openElements.hasInTableScope(h.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(h.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = M.IN_TABLE, Ei(e, t)) : Ut(e, t);
}
function TU(e, t) {
  const a = t.tagID;
  switch (a) {
    case h.CAPTION:
    case h.TABLE: {
      e.openElements.hasInTableScope(h.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(h.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = M.IN_TABLE, a === h.TABLE && Zs(e, t));
      break;
    }
    case h.BODY:
    case h.COL:
    case h.COLGROUP:
    case h.HTML:
    case h.TBODY:
    case h.TD:
    case h.TFOOT:
    case h.TH:
    case h.THEAD:
    case h.TR:
      break;
    default:
      yu(e, t);
  }
}
function Ff(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.COL: {
      e._appendElement(t, pe.HTML), t.ackSelfClosing = !0;
      break;
    }
    case h.TEMPLATE: {
      Dn(e, t);
      break;
    }
    default:
      au(e, t);
  }
}
function SU(e, t) {
  switch (t.tagID) {
    case h.COLGROUP: {
      e.openElements.currentTagId === h.COLGROUP && (e.openElements.pop(), e.insertionMode = M.IN_TABLE);
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
    case h.COL:
      break;
    default:
      au(e, t);
  }
}
function au(e, t) {
  e.openElements.currentTagId === h.COLGROUP && (e.openElements.pop(), e.insertionMode = M.IN_TABLE, e._processToken(t));
}
function Tu(e, t) {
  switch (t.tagID) {
    case h.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_ROW;
      break;
    }
    case h.TH:
    case h.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(V.TR, h.TR), e.insertionMode = M.IN_ROW, Su(e, t);
      break;
    }
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE, Ei(e, t));
      break;
    }
    default:
      Ei(e, t);
  }
}
function nf(e, t) {
  const a = t.tagID;
  switch (t.tagID) {
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD: {
      e.openElements.hasInTableScope(a) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE);
      break;
    }
    case h.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE, Zs(e, t));
      break;
    }
    case h.BODY:
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.HTML:
    case h.TD:
    case h.TH:
    case h.TR:
      break;
    default:
      Zs(e, t);
  }
}
function Su(e, t) {
  switch (t.tagID) {
    case h.TH:
    case h.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, pe.HTML), e.insertionMode = M.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD:
    case h.TR: {
      e.openElements.hasInTableScope(h.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE_BODY, Tu(e, t));
      break;
    }
    default:
      Ei(e, t);
  }
}
function BN(e, t) {
  switch (t.tagID) {
    case h.TR: {
      e.openElements.hasInTableScope(h.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE_BODY);
      break;
    }
    case h.TABLE: {
      e.openElements.hasInTableScope(h.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE_BODY, nf(e, t));
      break;
    }
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(h.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = M.IN_TABLE_BODY, nf(e, t));
      break;
    }
    case h.BODY:
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.HTML:
    case h.TD:
    case h.TH:
      break;
    default:
      Zs(e, t);
  }
}
function _U(e, t) {
  const a = t.tagID;
  UN.has(a) ? (e.openElements.hasInTableScope(h.TD) || e.openElements.hasInTableScope(h.TH)) && (e._closeTableCell(), Su(e, t)) : Ut(e, t);
}
function AU(e, t) {
  const a = t.tagID;
  switch (a) {
    case h.TD:
    case h.TH: {
      e.openElements.hasInTableScope(a) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(a), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = M.IN_ROW);
      break;
    }
    case h.TABLE:
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD:
    case h.TR: {
      e.openElements.hasInTableScope(a) && (e._closeTableCell(), BN(e, t));
      break;
    }
    case h.BODY:
    case h.CAPTION:
    case h.COL:
    case h.COLGROUP:
    case h.HTML:
      break;
    default:
      yu(e, t);
  }
}
function FN(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.OPTION: {
      e.openElements.currentTagId === h.OPTION && e.openElements.pop(), e._insertElement(t, pe.HTML);
      break;
    }
    case h.OPTGROUP: {
      e.openElements.currentTagId === h.OPTION && e.openElements.pop(), e.openElements.currentTagId === h.OPTGROUP && e.openElements.pop(), e._insertElement(t, pe.HTML);
      break;
    }
    case h.HR: {
      e.openElements.currentTagId === h.OPTION && e.openElements.pop(), e.openElements.currentTagId === h.OPTGROUP && e.openElements.pop(), e._appendElement(t, pe.HTML), t.ackSelfClosing = !0;
      break;
    }
    case h.INPUT:
    case h.KEYGEN:
    case h.TEXTAREA:
    case h.SELECT: {
      e.openElements.hasInSelectScope(h.SELECT) && (e.openElements.popUntilTagNamePopped(h.SELECT), e._resetInsertionMode(), t.tagID !== h.SELECT && e._processStartTag(t));
      break;
    }
    case h.SCRIPT:
    case h.TEMPLATE: {
      Dn(e, t);
      break;
    }
  }
}
function PN(e, t) {
  switch (t.tagID) {
    case h.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === h.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === h.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === h.OPTGROUP && e.openElements.pop();
      break;
    }
    case h.OPTION: {
      e.openElements.currentTagId === h.OPTION && e.openElements.pop();
      break;
    }
    case h.SELECT: {
      e.openElements.hasInSelectScope(h.SELECT) && (e.openElements.popUntilTagNamePopped(h.SELECT), e._resetInsertionMode());
      break;
    }
    case h.TEMPLATE: {
      Tr(e, t);
      break;
    }
  }
}
function NU(e, t) {
  const a = t.tagID;
  a === h.CAPTION || a === h.TABLE || a === h.TBODY || a === h.TFOOT || a === h.THEAD || a === h.TR || a === h.TD || a === h.TH ? (e.openElements.popUntilTagNamePopped(h.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : FN(e, t);
}
function RU(e, t) {
  const a = t.tagID;
  a === h.CAPTION || a === h.TABLE || a === h.TBODY || a === h.TFOOT || a === h.THEAD || a === h.TR || a === h.TD || a === h.TH ? e.openElements.hasInTableScope(a) && (e.openElements.popUntilTagNamePopped(h.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : PN(e, t);
}
function vU(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case h.BASE:
    case h.BASEFONT:
    case h.BGSOUND:
    case h.LINK:
    case h.META:
    case h.NOFRAMES:
    case h.SCRIPT:
    case h.STYLE:
    case h.TEMPLATE:
    case h.TITLE: {
      Dn(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case h.CAPTION:
    case h.COLGROUP:
    case h.TBODY:
    case h.TFOOT:
    case h.THEAD: {
      e.tmplInsertionModeStack[0] = M.IN_TABLE, e.insertionMode = M.IN_TABLE, Ei(e, t);
      break;
    }
    case h.COL: {
      e.tmplInsertionModeStack[0] = M.IN_COLUMN_GROUP, e.insertionMode = M.IN_COLUMN_GROUP, Ff(e, t);
      break;
    }
    case h.TR: {
      e.tmplInsertionModeStack[0] = M.IN_TABLE_BODY, e.insertionMode = M.IN_TABLE_BODY, Tu(e, t);
      break;
    }
    case h.TD:
    case h.TH: {
      e.tmplInsertionModeStack[0] = M.IN_ROW, e.insertionMode = M.IN_ROW, Su(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = M.IN_BODY, e.insertionMode = M.IN_BODY, Ut(e, t);
  }
}
function CU(e, t) {
  t.tagID === h.TEMPLATE && Tr(e, t);
}
function HN(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(h.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Bf(e, t);
}
function wU(e, t) {
  t.tagID === h.HTML ? Ut(e, t) : ru(e, t);
}
function zN(e, t) {
  var a;
  if (t.tagID === h.HTML) {
    if (e.fragmentContext || (e.insertionMode = M.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === h.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const i = e.openElements.items[1];
      i && !(!((a = e.treeAdapter.getNodeSourceCodeLocation(i)) === null || a === void 0) && a.endTag) && e._setEndLocation(i, t);
    }
  } else
    ru(e, t);
}
function ru(e, t) {
  e.insertionMode = M.IN_BODY, Eu(e, t);
}
function kU(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.FRAMESET: {
      e._insertElement(t, pe.HTML);
      break;
    }
    case h.FRAME: {
      e._appendElement(t, pe.HTML), t.ackSelfClosing = !0;
      break;
    }
    case h.NOFRAMES: {
      Dn(e, t);
      break;
    }
  }
}
function IU(e, t) {
  t.tagID === h.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== h.FRAMESET && (e.insertionMode = M.AFTER_FRAMESET));
}
function OU(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.NOFRAMES: {
      Dn(e, t);
      break;
    }
  }
}
function xU(e, t) {
  t.tagID === h.HTML && (e.insertionMode = M.AFTER_AFTER_FRAMESET);
}
function LU(e, t) {
  t.tagID === h.HTML ? Ut(e, t) : Vl(e, t);
}
function Vl(e, t) {
  e.insertionMode = M.IN_BODY, Eu(e, t);
}
function DU(e, t) {
  switch (t.tagID) {
    case h.HTML: {
      Ut(e, t);
      break;
    }
    case h.NOFRAMES: {
      Dn(e, t);
      break;
    }
  }
}
function MU(e, t) {
  t.chars = lt, e._insertCharacters(t);
}
function UU(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function GN(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== pe.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function BU(e, t) {
  if (QM(t))
    GN(e), e._startTagOutsideForeignContent(t);
  else {
    const a = e._getAdjustedCurrentElement(), i = e.treeAdapter.getNamespaceURI(a);
    i === pe.MATHML ? RN(t) : i === pe.SVG && (JM(t), vN(t)), Mf(t), t.selfClosing ? e._appendElement(t, i) : e._insertElement(t, i), t.ackSelfClosing = !0;
  }
}
function FU(e, t) {
  if (t.tagID === h.P || t.tagID === h.BR) {
    GN(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const i = e.openElements.items[a];
    if (e.treeAdapter.getNamespaceURI(i) === pe.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const o = e.treeAdapter.getTagName(i);
    if (o.toLowerCase() === t.tagName) {
      t.tagName = o, e.openElements.shortenToLength(a);
      break;
    }
  }
}
V.AREA, V.BASE, V.BASEFONT, V.BGSOUND, V.BR, V.COL, V.EMBED, V.FRAME, V.HR, V.IMG, V.INPUT, V.KEYGEN, V.LINK, V.META, V.PARAM, V.SOURCE, V.TRACK, V.WBR;
const PU = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, HU = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), uA = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function jN(e, t) {
  const a = KU(e), i = q1("type", {
    handlers: { root: zU, element: GU, text: jU, comment: qN, doctype: $U, raw: YU },
    unknown: VU
  }), o = {
    parser: a ? new sA(uA) : sA.getFragmentParser(void 0, uA),
    handle(d) {
      i(d, o);
    },
    stitches: !1,
    options: t || {}
  };
  i(e, o), Ri(o, zn());
  const l = a ? o.parser.document : o.parser.getFragment(), c = Z3(l, {
    // To do: support `space`?
    file: o.options.file
  });
  return o.stitches && bu(c, "comment", function(d, m, f) {
    const b = (
      /** @type {Stitch} */
      /** @type {unknown} */
      d
    );
    if (b.value.stitch && f && m !== void 0) {
      const E = f.children;
      return E[m] = b.value.stitch, m;
    }
  }), c.type === "root" && c.children.length === 1 && c.children[0].type === e.type ? c.children[0] : c;
}
function $N(e, t) {
  let a = -1;
  if (e)
    for (; ++a < e.length; )
      t.handle(e[a]);
}
function zU(e, t) {
  $N(e.children, t);
}
function GU(e, t) {
  WU(e, t), $N(e.children, t), XU(e, t);
}
function jU(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const a = {
    type: De.CHARACTER,
    chars: e.value,
    location: lo(e)
  };
  Ri(t, zn(e)), t.parser.currentToken = a, t.parser._processToken(t.parser.currentToken);
}
function $U(e, t) {
  const a = {
    type: De.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: lo(e)
  };
  Ri(t, zn(e)), t.parser.currentToken = a, t.parser._processToken(t.parser.currentToken);
}
function qU(e, t) {
  t.stitches = !0;
  const a = ZU(e);
  if ("children" in e && "children" in a) {
    const i = (
      /** @type {Root} */
      jN({ type: "root", children: e.children }, t.options)
    );
    a.children = i.children;
  }
  qN({ type: "comment", value: { stitch: a } }, t);
}
function qN(e, t) {
  const a = e.value, i = {
    type: De.COMMENT,
    data: a,
    location: lo(e)
  };
  Ri(t, zn(e)), t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken);
}
function YU(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, YN(t, zn(e)), t.parser.tokenizer.write(
    t.options.tagfilter ? e.value.replace(PU, "&lt;$1$2") : e.value,
    !1
  ), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const a = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(a);
  }
}
function VU(e, t) {
  const a = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(a.type))
    qU(a, t);
  else {
    let i = "";
    throw HU.has(a.type) && (i = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + a.type + "` node" + i);
  }
}
function Ri(e, t) {
  YN(e, t);
  const a = e.parser.tokenizer.currentCharacterToken;
  a && a.location && (a.location.endLine = e.parser.tokenizer.preprocessor.line, a.location.endCol = e.parser.tokenizer.preprocessor.col + 1, a.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = a, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = mt.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function YN(e, t) {
  if (t && t.offset !== void 0) {
    const a = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = a;
  }
}
function WU(e, t) {
  const a = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === mt.PLAINTEXT) return;
  Ri(t, zn(e));
  const i = t.parser.openElements.current;
  let o = "namespaceURI" in i ? i.namespaceURI : fr.html;
  o === fr.html && a === "svg" && (o = fr.svg);
  const l = nM(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: o === fr.svg ? "svg" : "html" }
  ), c = {
    type: De.START_TAG,
    tagName: a,
    tagID: Ni(a),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in l ? l.attrs : [],
    location: lo(e)
  };
  t.parser.currentToken = c, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = a;
}
function XU(e, t) {
  const a = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && cM.includes(a) || t.parser.tokenizer.state === mt.PLAINTEXT) return;
  Ri(t, du(e));
  const i = {
    type: De.END_TAG,
    tagName: a,
    tagID: Ni(a),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: lo(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  a === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === mt.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === mt.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === mt.SCRIPT_DATA) && (t.parser.tokenizer.state = mt.DATA);
}
function KU(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function lo(e) {
  const t = zn(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, a = du(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: a.line,
    endCol: a.column,
    endOffset: a.offset
  };
}
function ZU(e) {
  return "children" in e ? hr({ ...e, children: [] }) : hr(e);
}
function QU(e) {
  return function(t, a) {
    return (
      /** @type {Root} */
      jN(t, { ...e, file: a })
    );
  };
}
const pr = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"], af = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...pr,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...pr],
    // Note: this is used by GFM footnotes.
    h2: [["className", "sr-only"]],
    img: [...pr, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    input: [
      ["disabled", !0],
      ["type", "checkbox"]
    ],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ol: [...pr, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...pr],
    table: [...pr],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ul: [...pr, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      // Note: `disabled` is technically allowed on all elements by GH.
      // But it is useless on everything except `input`.
      // Because `input`s are normally not allowed, but we allow them for
      // checkboxes due to tasklists, we allow `disabled` only there.
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: { disabled: !0, type: "checkbox" }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
}, Ga = {}.hasOwnProperty;
function JU(e, t) {
  let a = { type: "root", children: [] };
  const i = {
    schema: t ? { ...af, ...t } : af,
    stack: []
  }, o = VN(i, e);
  return o && (Array.isArray(o) ? o.length === 1 ? a = o[0] : a.children = o : a = o), a;
}
function VN(e, t) {
  if (t && typeof t == "object") {
    const a = (
      /** @type {Record<string, Readonly<unknown>>} */
      t
    );
    switch (typeof a.type == "string" ? a.type : "") {
      case "comment":
        return e4(e, a);
      case "doctype":
        return t4(e, a);
      case "element":
        return n4(e, a);
      case "root":
        return a4(e, a);
      case "text":
        return r4(e, a);
    }
  }
}
function e4(e, t) {
  if (e.schema.allowComments) {
    const a = typeof t.value == "string" ? t.value : "", i = a.indexOf("-->"), l = { type: "comment", value: i < 0 ? a : a.slice(0, i) };
    return uo(l, t), l;
  }
}
function t4(e, t) {
  if (e.schema.allowDoctypes) {
    const a = { type: "doctype" };
    return uo(a, t), a;
  }
}
function n4(e, t) {
  const a = typeof t.tagName == "string" ? t.tagName : "";
  e.stack.push(a);
  const i = (
    /** @type {Array<ElementContent>} */
    WN(e, t.children)
  ), o = i4(e, t.properties);
  e.stack.pop();
  let l = !1;
  if (a && a !== "*" && (!e.schema.tagNames || e.schema.tagNames.includes(a)) && (l = !0, e.schema.ancestors && Ga.call(e.schema.ancestors, a))) {
    const d = e.schema.ancestors[a];
    let m = -1;
    for (l = !1; ++m < d.length; )
      e.stack.includes(d[m]) && (l = !0);
  }
  if (!l)
    return e.schema.strip && !e.schema.strip.includes(a) ? i : void 0;
  const c = {
    type: "element",
    tagName: a,
    properties: o,
    children: i
  };
  return uo(c, t), c;
}
function a4(e, t) {
  const i = { type: "root", children: (
    /** @type {Array<RootContent>} */
    WN(e, t.children)
  ) };
  return uo(i, t), i;
}
function r4(e, t) {
  const i = { type: "text", value: typeof t.value == "string" ? t.value : "" };
  return uo(i, t), i;
}
function WN(e, t) {
  const a = [];
  if (Array.isArray(t)) {
    const i = (
      /** @type {Array<Readonly<unknown>>} */
      t
    );
    let o = -1;
    for (; ++o < i.length; ) {
      const l = VN(e, i[o]);
      l && (Array.isArray(l) ? a.push(...l) : a.push(l));
    }
  }
  return a;
}
function i4(e, t) {
  const a = e.stack[e.stack.length - 1], i = e.schema.attributes, o = e.schema.required, l = i && Ga.call(i, a) ? i[a] : void 0, c = i && Ga.call(i, "*") ? i["*"] : void 0, d = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    t && typeof t == "object" ? t : {}
  ), m = {};
  let f;
  for (f in d)
    if (Ga.call(d, f)) {
      const b = d[f];
      let E = cA(
        e,
        dA(l, f),
        f,
        b
      );
      E == null && (E = cA(e, dA(c, f), f, b)), E != null && (m[f] = E);
    }
  if (o && Ga.call(o, a)) {
    const b = o[a];
    for (f in b)
      Ga.call(b, f) && !Ga.call(m, f) && (m[f] = b[f]);
  }
  return m;
}
function cA(e, t, a, i) {
  return t ? Array.isArray(i) ? s4(e, t, a, i) : XN(e, t, a, i) : void 0;
}
function s4(e, t, a, i) {
  let o = -1;
  const l = [];
  for (; ++o < i.length; ) {
    const c = XN(e, t, a, i[o]);
    (typeof c == "number" || typeof c == "string") && l.push(c);
  }
  return l;
}
function XN(e, t, a, i) {
  if (!(typeof i != "boolean" && typeof i != "number" && typeof i != "string") && o4(e, a, i)) {
    if (typeof t == "object" && t.length > 1) {
      let o = !1, l = 0;
      for (; ++l < t.length; ) {
        const c = t[l];
        if (c && typeof c == "object" && "flags" in c) {
          if (c.test(String(i))) {
            o = !0;
            break;
          }
        } else if (c === i) {
          o = !0;
          break;
        }
      }
      if (!o) return;
    }
    return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(a) ? e.schema.clobberPrefix + i : i;
  }
}
function o4(e, t, a) {
  const i = e.schema.protocols && Ga.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0;
  if (!i || i.length === 0)
    return !0;
  const o = String(a), l = o.indexOf(":"), c = o.indexOf("?"), d = o.indexOf("#"), m = o.indexOf("/");
  if (l < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
  m > -1 && l > m || c > -1 && l > c || d > -1 && l > d)
    return !0;
  let f = -1;
  for (; ++f < i.length; ) {
    const b = i[f];
    if (l === b.length && o.slice(0, b.length) === b)
      return !0;
  }
  return !1;
}
function uo(e, t) {
  const a = m1(
    // @ts-expect-error: looks like a node.
    t
  );
  t.data && (e.data = hr(t.data)), a && (e.position = a);
}
function dA(e, t) {
  let a, i = -1;
  if (e)
    for (; ++i < e.length; ) {
      const o = e[i], l = typeof o == "string" ? o : o[0];
      if (l === t)
        return o;
      l === "data*" && (a = o);
    }
  if (t.length > 4 && t.slice(0, 4).toLowerCase() === "data")
    return a;
}
function l4(e) {
  return function(t) {
    return (
      /** @type {Root} */
      JU(t, e)
    );
  };
}
function u4(e, t) {
  if (e == null) return {};
  var a = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    a[i] = e[i];
  }
  return a;
}
function c4(e, t) {
  if (e == null) return {};
  var a, i, o = u4(e, t);
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (i = 0; i < l.length; i++) a = l[i], t.indexOf(a) === -1 && {}.propertyIsEnumerable.call(e, a) && (o[a] = e[a]);
  }
  return o;
}
function rf(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var a = 0, i = Array(t); a < t; a++) i[a] = e[a];
  return i;
}
function d4(e) {
  if (Array.isArray(e)) return rf(e);
}
function p4(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function f4(e, t) {
  if (e) {
    if (typeof e == "string") return rf(e, t);
    var a = {}.toString.call(e).slice(8, -1);
    return a === "Object" && e.constructor && (a = e.constructor.name), a === "Map" || a === "Set" ? Array.from(e) : a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? rf(e, t) : void 0;
  }
}
function m4() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sf(e) {
  return d4(e) || p4(e) || f4(e) || m4();
}
function Qs(e) {
  "@babel/helpers - typeof";
  return Qs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qs(e);
}
function g4(e, t) {
  if (Qs(e) != "object" || !e) return e;
  var a = e[Symbol.toPrimitive];
  if (a !== void 0) {
    var i = a.call(e, t);
    if (Qs(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function h4(e) {
  var t = g4(e, "string");
  return Qs(t) == "symbol" ? t : t + "";
}
function KN(e, t, a) {
  return (t = h4(t)) in e ? Object.defineProperty(e, t, {
    value: a,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = a, e;
}
function of() {
  return of = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var a = arguments[t];
      for (var i in a) ({}).hasOwnProperty.call(a, i) && (e[i] = a[i]);
    }
    return e;
  }, of.apply(null, arguments);
}
function pA(e, t) {
  var a = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), a.push.apply(a, i);
  }
  return a;
}
function gi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var a = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pA(Object(a), !0).forEach(function(i) {
      KN(e, i, a[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a)) : pA(Object(a)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(a, i));
    });
  }
  return e;
}
function b4(e) {
  var t = e.length;
  if (t === 0 || t === 1) return e;
  if (t === 2)
    return [e[0], e[1], "".concat(e[0], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0])];
  if (t === 3)
    return [e[0], e[1], e[2], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0])];
  if (t >= 4)
    return [e[0], e[1], e[2], e[3], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3]), "".concat(e[3], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1], ".").concat(e[0])];
}
var Np = {};
function E4(e) {
  if (e.length === 0 || e.length === 1) return e;
  var t = e.join(".");
  return Np[t] || (Np[t] = b4(e)), Np[t];
}
function y4(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = arguments.length > 2 ? arguments[2] : void 0, i = e.filter(function(l) {
    return l !== "token";
  }), o = E4(i);
  return o.reduce(function(l, c) {
    return gi(gi({}, l), a[c]);
  }, t);
}
function fA(e) {
  return e.join(" ");
}
function T4(e, t) {
  var a = 0;
  return function(i) {
    return a += 1, i.map(function(o, l) {
      return ZN({
        node: o,
        stylesheet: e,
        useInlineStyles: t,
        key: "code-segment-".concat(a, "-").concat(l)
      });
    });
  };
}
function ZN(e) {
  var t = e.node, a = e.stylesheet, i = e.style, o = i === void 0 ? {} : i, l = e.useInlineStyles, c = e.key, d = t.properties, m = t.type, f = t.tagName, b = t.value;
  if (m === "text")
    return b;
  if (f) {
    var E = T4(a, l), T;
    if (!l)
      T = gi(gi({}, d), {}, {
        className: fA(d.className)
      });
    else {
      var S = Object.keys(a).reduce(function(C, L) {
        return L.split(".").forEach(function(x) {
          C.includes(x) || C.push(x);
        }), C;
      }, []), _ = d.className && d.className.includes("token") ? ["token"] : [], k = d.className && _.concat(d.className.filter(function(C) {
        return !S.includes(C);
      }));
      T = gi(gi({}, d), {}, {
        className: fA(k) || void 0,
        style: y4(d.className, Object.assign({}, d.style, o), a)
      });
    }
    var R = E(t.children);
    return /* @__PURE__ */ Re.createElement(f, of({
      key: c
    }, T), R);
  }
}
const S4 = (function(e, t) {
  var a = e.listLanguages();
  return a.indexOf(t) !== -1;
});
var _4 = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function mA(e, t) {
  var a = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), a.push.apply(a, i);
  }
  return a;
}
function $a(e) {
  for (var t = 1; t < arguments.length; t++) {
    var a = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mA(Object(a), !0).forEach(function(i) {
      KN(e, i, a[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a)) : mA(Object(a)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(a, i));
    });
  }
  return e;
}
var A4 = /\n/g;
function N4(e) {
  return e.match(A4);
}
function R4(e) {
  var t = e.lines, a = e.startingLineNumber, i = e.style;
  return t.map(function(o, l) {
    var c = l + a;
    return /* @__PURE__ */ Re.createElement("span", {
      key: "line-".concat(l),
      className: "react-syntax-highlighter-line-number",
      style: typeof i == "function" ? i(c) : i
    }, "".concat(c, `
`));
  });
}
function v4(e) {
  var t = e.codeString, a = e.codeStyle, i = e.containerStyle, o = i === void 0 ? {
    float: "left",
    paddingRight: "10px"
  } : i, l = e.numberStyle, c = l === void 0 ? {} : l, d = e.startingLineNumber;
  return /* @__PURE__ */ Re.createElement("code", {
    style: Object.assign({}, a, o)
  }, R4({
    lines: t.replace(/\n$/, "").split(`
`),
    style: c,
    startingLineNumber: d
  }));
}
function C4(e) {
  return "".concat(e.toString().length, ".25em");
}
function QN(e, t) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(e),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: t
    },
    children: [{
      type: "text",
      value: e
    }]
  };
}
function JN(e, t, a) {
  var i = {
    display: "inline-block",
    minWidth: C4(a),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  }, o = typeof e == "function" ? e(t) : e, l = $a($a({}, i), o);
  return l;
}
function Wl(e) {
  var t = e.children, a = e.lineNumber, i = e.lineNumberStyle, o = e.largestLineNumber, l = e.showInlineLineNumbers, c = e.lineProps, d = c === void 0 ? {} : c, m = e.className, f = m === void 0 ? [] : m, b = e.showLineNumbers, E = e.wrapLongLines, T = e.wrapLines, S = T === void 0 ? !1 : T, _ = S ? $a({}, typeof d == "function" ? d(a) : d) : {};
  if (_.className = _.className ? [].concat(sf(_.className.trim().split(/\s+/)), sf(f)) : f, a && l) {
    var k = JN(i, a, o);
    t.unshift(QN(a, k));
  }
  return E & b && (_.style = $a({
    display: "flex"
  }, _.style)), {
    type: "element",
    tagName: "span",
    properties: _,
    children: t
  };
}
function eR(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  e.length === void 0 && (e = [e]);
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    if (o.type === "text")
      a.push(Wl({
        children: [o],
        className: sf(new Set(t))
      }));
    else if (o.children) {
      var l, c = t.concat(((l = o.properties) === null || l === void 0 ? void 0 : l.className) || []);
      eR(o.children, c).forEach(function(d) {
        return a.push(d);
      });
    }
  }
  return a;
}
function w4(e, t, a, i, o, l, c, d, m) {
  var f, b = eR(e.value), E = [], T = -1, S = 0;
  function _(q, D) {
    var G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return Wl({
      children: q,
      lineNumber: D,
      lineNumberStyle: d,
      largestLineNumber: c,
      showInlineLineNumbers: o,
      lineProps: a,
      className: G,
      showLineNumbers: i,
      wrapLongLines: m,
      wrapLines: t
    });
  }
  function k(q, D) {
    if (i && D && o) {
      var G = JN(d, D, c);
      q.unshift(QN(D, G));
    }
    return q;
  }
  function R(q, D) {
    var G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return t || G.length > 0 ? _(q, D, G) : k(q, D);
  }
  for (var C = function() {
    var D = b[S], G = D.children[0].value, K = N4(G);
    if (K) {
      var Q = G.split(`
`);
      Q.forEach(function(U, ee) {
        var ae = i && E.length + l, ue = {
          type: "text",
          value: "".concat(U, `
`)
        };
        if (ee === 0) {
          var de = b.slice(T + 1, S).concat(Wl({
            children: [ue],
            className: D.properties.className
          })), ce = R(de, ae);
          E.push(ce);
        } else if (ee === Q.length - 1) {
          var j = b[S + 1] && b[S + 1].children && b[S + 1].children[0], se = {
            type: "text",
            value: "".concat(U)
          };
          if (j) {
            var Ee = Wl({
              children: [se],
              className: D.properties.className
            });
            b.splice(S + 1, 0, Ee);
          } else {
            var Ne = [se], O = R(Ne, ae, D.properties.className);
            E.push(O);
          }
        } else {
          var F = [ue], te = R(F, ae, D.properties.className);
          E.push(te);
        }
      }), T = S;
    }
    S++;
  }; S < b.length; )
    C();
  if (T !== b.length - 1) {
    var L = b.slice(T + 1, b.length);
    if (L && L.length) {
      var x = i && E.length + l, Y = R(L, x);
      E.push(Y);
    }
  }
  return t ? E : (f = []).concat.apply(f, E);
}
function k4(e) {
  var t = e.rows, a = e.stylesheet, i = e.useInlineStyles;
  return t.map(function(o, l) {
    return ZN({
      node: o,
      stylesheet: a,
      useInlineStyles: i,
      key: "code-segment-".concat(l)
    });
  });
}
function tR(e) {
  return e && typeof e.highlightAuto < "u";
}
function I4(e) {
  var t = e.astGenerator, a = e.language, i = e.code, o = e.defaultCodeValue;
  if (tR(t)) {
    var l = S4(t, a);
    return a === "text" ? {
      value: o,
      language: "text"
    } : l ? t.highlight(a, i) : t.highlightAuto(i);
  }
  try {
    return a && a !== "text" ? {
      value: t.highlight(i, a)
    } : {
      value: o
    };
  } catch {
    return {
      value: o
    };
  }
}
function O4(e, t) {
  return function(i) {
    var o, l, c = i.language, d = i.children, m = i.style, f = m === void 0 ? t : m, b = i.customStyle, E = b === void 0 ? {} : b, T = i.codeTagProps, S = T === void 0 ? {
      className: c ? "language-".concat(c) : void 0,
      style: $a($a({}, f['code[class*="language-"]']), f['code[class*="language-'.concat(c, '"]')])
    } : T, _ = i.useInlineStyles, k = _ === void 0 ? !0 : _, R = i.showLineNumbers, C = R === void 0 ? !1 : R, L = i.showInlineLineNumbers, x = L === void 0 ? !0 : L, Y = i.startingLineNumber, q = Y === void 0 ? 1 : Y, D = i.lineNumberContainerStyle, G = i.lineNumberStyle, K = G === void 0 ? {} : G, Q = i.wrapLines, U = i.wrapLongLines, ee = U === void 0 ? !1 : U, ae = i.lineProps, ue = ae === void 0 ? {} : ae, de = i.renderer, ce = i.PreTag, j = ce === void 0 ? "pre" : ce, se = i.CodeTag, Ee = se === void 0 ? "code" : se, Ne = i.code, O = Ne === void 0 ? (Array.isArray(d) ? d[0] : d) || "" : Ne, F = i.astGenerator, te = c4(i, _4);
    F = F || e;
    var v = C ? /* @__PURE__ */ Re.createElement(v4, {
      containerStyle: D,
      codeStyle: S.style || {},
      numberStyle: K,
      startingLineNumber: q,
      codeString: O
    }) : null, he = f.hljs || f['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    }, ye = tR(F) ? "hljs" : "prismjs", _e = k ? Object.assign({}, te, {
      style: Object.assign({}, he, E)
    }) : Object.assign({}, te, {
      className: te.className ? "".concat(ye, " ").concat(te.className) : ye,
      style: Object.assign({}, E)
    });
    if (ee ? S.style = $a({
      whiteSpace: "pre-wrap"
    }, S.style) : S.style = $a({
      whiteSpace: "pre"
    }, S.style), !F)
      return /* @__PURE__ */ Re.createElement(j, _e, v, /* @__PURE__ */ Re.createElement(Ee, S, O));
    (Q === void 0 && de || ee) && (Q = !0), de = de || k4;
    var Le = [{
      type: "text",
      value: O
    }], Ze = I4({
      astGenerator: F,
      language: c,
      code: O,
      defaultCodeValue: Le
    });
    Ze.language === null && (Ze.value = Le);
    var Ve = (o = (l = O.match(/\n/g)) === null || l === void 0 ? void 0 : l.length) !== null && o !== void 0 ? o : 0, jt = q + Ve, vn = w4(Ze, Q, ue, C, x, q, jt, K, ee);
    return /* @__PURE__ */ Re.createElement(j, _e, /* @__PURE__ */ Re.createElement(Ee, S, !x && v, de({
      rows: vn,
      stylesheet: f,
      useInlineStyles: k
    })));
  };
}
const x4 = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "armasm", "arturo", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "awk", "bash", "basic", "batch", "bbcode", "bbj", "bicep", "birb", "bison", "bnf", "bqn", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "cilkc", "cilkcpp", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "cooklang", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cue", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gettext", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "gradle", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "linker-script", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "mata", "matlab", "maxscript", "mel", "mermaid", "metafont", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "odin", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plant-uml", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rescript", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stata", "stylus", "supercollider", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wgsl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"], L4 = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], gA = {
  0: "",
  128: "",
  130: "",
  131: "",
  132: "",
  133: "",
  134: "",
  135: "",
  136: "",
  137: "",
  138: "",
  139: "",
  140: "",
  142: "",
  145: "",
  146: "",
  147: "",
  148: "",
  149: "",
  150: "",
  151: "",
  152: "",
  153: "",
  154: "",
  155: "",
  156: "",
  158: "",
  159: ""
};
function nR(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function D4(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
function M4(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function hA(e) {
  return M4(e) || nR(e);
}
const U4 = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function B4(e, t) {
  const a = {}, i = typeof a.additional == "string" ? a.additional.charCodeAt(0) : a.additional, o = [];
  let l = 0, c = -1, d = "", m, f;
  a.position && ("start" in a.position || "indent" in a.position ? (f = a.position.indent, m = a.position.start) : m = a.position);
  let b = (m ? m.line : 0) || 1, E = (m ? m.column : 0) || 1, T = _(), S;
  for (l--; ++l <= e.length; )
    if (S === 10 && (E = (f ? f[c] : 0) || 1), S = e.charCodeAt(l), S === 38) {
      const C = e.charCodeAt(l + 1);
      if (C === 9 || C === 10 || C === 12 || C === 32 || C === 38 || C === 60 || Number.isNaN(C) || i && C === i) {
        d += String.fromCharCode(S), E++;
        continue;
      }
      const L = l + 1;
      let x = L, Y = L, q;
      if (C === 35) {
        Y = ++x;
        const ue = e.charCodeAt(Y);
        ue === 88 || ue === 120 ? (q = "hexadecimal", Y = ++x) : q = "decimal";
      } else
        q = "named";
      let D = "", G = "", K = "";
      const Q = q === "named" ? hA : q === "decimal" ? nR : D4;
      for (Y--; ++Y <= e.length; ) {
        const ue = e.charCodeAt(Y);
        if (!Q(ue))
          break;
        K += String.fromCharCode(ue), q === "named" && L4.includes(K) && (D = K, G = Xs(K));
      }
      let U = e.charCodeAt(Y) === 59;
      if (U) {
        Y++;
        const ue = q === "named" ? Xs(K) : !1;
        ue && (D = K, G = ue);
      }
      let ee = 1 + Y - L, ae = "";
      if (!(!U && a.nonTerminated === !1)) if (!K)
        q !== "named" && k(4, ee);
      else if (q === "named") {
        if (U && !G)
          k(5, 1);
        else if (D !== K && (Y = x + D.length, ee = 1 + Y - x, U = !1), !U) {
          const ue = D ? 1 : 3;
          if (a.attribute) {
            const de = e.charCodeAt(Y);
            de === 61 ? (k(ue, ee), G = "") : hA(de) ? G = "" : k(ue, ee);
          } else
            k(ue, ee);
        }
        ae = G;
      } else {
        U || k(2, ee);
        let ue = Number.parseInt(
          K,
          q === "hexadecimal" ? 16 : 10
        );
        if (F4(ue))
          k(7, ee), ae = "";
        else if (ue in gA)
          k(6, ee), ae = gA[ue];
        else {
          let de = "";
          P4(ue) && k(6, ee), ue > 65535 && (ue -= 65536, de += String.fromCharCode(
            ue >>> 10 | 55296
          ), ue = 56320 | ue & 1023), ae = de + String.fromCharCode(ue);
        }
      }
      if (ae) {
        R(), T = _(), l = Y - 1, E += Y - L + 1, o.push(ae);
        const ue = _();
        ue.offset++, a.reference && a.reference.call(
          a.referenceContext || void 0,
          ae,
          { start: T, end: ue },
          e.slice(L - 1, Y)
        ), T = ue;
      } else
        K = e.slice(L - 1, Y), d += K, E += K.length, l = Y - 1;
    } else
      S === 10 && (b++, c++, E = 0), Number.isNaN(S) ? R() : (d += String.fromCharCode(S), E++);
  return o.join("");
  function _() {
    return {
      line: b,
      column: E,
      offset: l + ((m ? m.offset : 0) || 0)
    };
  }
  function k(C, L) {
    let x;
    a.warning && (x = _(), x.column += L, x.offset += L, a.warning.call(
      a.warningContext || void 0,
      U4[C],
      x,
      C
    ));
  }
  function R() {
    d && (o.push(d), a.text && a.text.call(a.textContext || void 0, d, {
      start: T,
      end: _()
    }), d = "");
  }
}
function F4(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function P4(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534;
}
var H4 = 0, Gl = {}, Rt = {
  /**
   * A namespace for utility methods.
   *
   * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
   * change or disappear at any time.
   *
   * @namespace
   * @memberof Prism
   */
  util: {
    /**
     * Returns the name of the type of the given value.
     *
     * @param {any} o
     * @returns {string}
     * @example
     * type(null)      === 'Null'
     * type(undefined) === 'Undefined'
     * type(123)       === 'Number'
     * type('foo')     === 'String'
     * type(true)      === 'Boolean'
     * type([1, 2])    === 'Array'
     * type({})        === 'Object'
     * type(String)    === 'Function'
     * type(/abc+/)    === 'RegExp'
     */
    type: function(e) {
      return Object.prototype.toString.call(e).slice(8, -1);
    },
    /**
     * Returns a unique number for the given object. Later calls will still return the same number.
     *
     * @param {Object} obj
     * @returns {number}
     */
    objId: function(e) {
      return e.__id || Object.defineProperty(e, "__id", { value: ++H4 }), e.__id;
    },
    /**
     * Creates a deep clone of the given object.
     *
     * The main intended use of this function is to clone language definitions.
     *
     * @param {T} o
     * @param {Record<number, any>} [visited]
     * @returns {T}
     * @template T
     */
    clone: function e(t, a) {
      a = a || {};
      var i, o;
      switch (Rt.util.type(t)) {
        case "Object":
          if (o = Rt.util.objId(t), a[o])
            return a[o];
          i = /** @type {Record<string, any>} */
          {}, a[o] = i;
          for (var l in t)
            t.hasOwnProperty(l) && (i[l] = e(t[l], a));
          return (
            /** @type {any} */
            i
          );
        case "Array":
          return o = Rt.util.objId(t), a[o] ? a[o] : (i = [], a[o] = i, /** @type {any} */
          t.forEach(
            function(c, d) {
              i[d] = e(c, a);
            }
          ), /** @type {any} */
          i);
        default:
          return t;
      }
    }
  },
  /**
   * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
   *
   * @namespace
   * @memberof Prism
   * @public
   */
  languages: {
    /**
     * The grammar for plain, unformatted text.
     */
    plain: Gl,
    plaintext: Gl,
    text: Gl,
    txt: Gl,
    /**
     * Creates a deep copy of the language with the given id and appends the given tokens.
     *
     * If a token in `redef` also appears in the copied language, then the existing token in the copied language
     * will be overwritten at its original position.
     *
     * ## Best practices
     *
     * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
     * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
     * understand the language definition because, normally, the order of tokens matters in Prism grammars.
     *
     * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
     * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
     *
     * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
     * @param {Grammar} redef The new tokens to append.
     * @returns {Grammar} The new language created.
     * @public
     * @example
     * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
     *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
     *     // at its original position
     *     'comment': { ... },
     *     // CSS doesn't have a 'color' token, so this token will be appended
     *     'color': /\b(?:red|green|blue)\b/
     * });
     */
    extend: function(e, t) {
      var a = Rt.util.clone(Rt.languages[e]);
      for (var i in t)
        a[i] = t[i];
      return a;
    },
    /**
     * Inserts tokens _before_ another token in a language definition or any other grammar.
     *
     * ## Usage
     *
     * This helper method makes it easy to modify existing languages. For example, the CSS language definition
     * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
     * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
     * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
     * this:
     *
     * ```js
     * Prism.languages.markup.style = {
     *     // token
     * };
     * ```
     *
     * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
     * before existing tokens. For the CSS example above, you would use it like this:
     *
     * ```js
     * Prism.languages.insertBefore('markup', 'cdata', {
     *     'style': {
     *         // token
     *     }
     * });
     * ```
     *
     * ## Special cases
     *
     * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
     * will be ignored.
     *
     * This behavior can be used to insert tokens after `before`:
     *
     * ```js
     * Prism.languages.insertBefore('markup', 'comment', {
     *     'comment': Prism.languages.markup.comment,
     *     // tokens after 'comment'
     * });
     * ```
     *
     * ## Limitations
     *
     * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
     * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
     * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
     * deleting properties which is necessary to insert at arbitrary positions.
     *
     * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
     * Instead, it will create a new object and replace all references to the target object with the new one. This
     * can be done without temporarily deleting properties, so the iteration order is well-defined.
     *
     * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
     * you hold the target object in a variable, then the value of the variable will not change.
     *
     * ```js
     * var oldMarkup = Prism.languages.markup;
     * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
     *
     * assert(oldMarkup !== Prism.languages.markup);
     * assert(newMarkup === Prism.languages.markup);
     * ```
     *
     * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
     * object to be modified.
     * @param {string} before The key to insert before.
     * @param {Grammar} insert An object containing the key-value pairs to be inserted.
     * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
     * object to be modified.
     *
     * Defaults to `Prism.languages`.
     * @returns {Grammar} The new grammar object.
     * @public
     */
    insertBefore: function(e, t, a, i) {
      i = i || /** @type {any} */
      Rt.languages;
      var o = i[e], l = {};
      for (var c in o)
        if (o.hasOwnProperty(c)) {
          if (c == t)
            for (var d in a)
              a.hasOwnProperty(d) && (l[d] = a[d]);
          a.hasOwnProperty(c) || (l[c] = o[c]);
        }
      var m = i[e];
      return i[e] = l, Rt.languages.DFS(Rt.languages, function(f, b) {
        b === m && f != e && (this[f] = l);
      }), l;
    },
    // Traverse a language definition with Depth First Search
    DFS: function e(t, a, i, o) {
      o = o || {};
      var l = Rt.util.objId;
      for (var c in t)
        if (t.hasOwnProperty(c)) {
          a.call(t, c, t[c], i || c);
          var d = t[c], m = Rt.util.type(d);
          m === "Object" && !o[l(d)] ? (o[l(d)] = !0, e(d, a, null, o)) : m === "Array" && !o[l(d)] && (o[l(d)] = !0, e(d, a, c, o));
        }
    }
  },
  plugins: {},
  /**
   * Low-level function, only use if you know what youre doing. It accepts a string of text as input
   * and the language definitions to use, and returns a string with the HTML produced.
   *
   * The following hooks will be run:
   * 1. `before-tokenize`
   * 2. `after-tokenize`
   * 3. `wrap`: On each {@link Token}.
   *
   * @param {string} text A string with the code to be highlighted.
   * @param {Grammar} grammar An object containing the tokens to use.
   *
   * Usually a language definition like `Prism.languages.markup`.
   * @param {string} language The name of the language definition passed to `grammar`.
   * @returns {string} The highlighted HTML.
   * @memberof Prism
   * @public
   * @example
   * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
   */
  highlight: function(e, t, a) {
    var i = {
      code: e,
      grammar: t,
      language: a
    };
    if (Rt.hooks.run("before-tokenize", i), !i.grammar)
      throw new Error('The language "' + i.language + '" has no grammar.');
    return i.tokens = Rt.tokenize(i.code, i.grammar), Rt.hooks.run("after-tokenize", i), qs.stringify(Rt.util.encode(i.tokens), i.language);
  },
  /**
   * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
   * and the language definitions to use, and returns an array with the tokenized code.
   *
   * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
   *
   * This method could be useful in other contexts as well, as a very crude parser.
   *
   * @param {string} text A string with the code to be highlighted.
   * @param {Grammar} grammar An object containing the tokens to use.
   *
   * Usually a language definition like `Prism.languages.markup`.
   * @returns {TokenStream} An array of strings and tokens, a token stream.
   * @memberof Prism
   * @public
   * @example
   * let code = `var foo = 0;`;
   * let tokens = Prism.tokenize(code, Prism.languages.javascript);
   * tokens.forEach(token => {
   *     if (token instanceof Prism.Token && token.type === 'number') {
   *         console.log(`Found numeric literal: ${token.content}`);
   *     }
   * });
   */
  tokenize: function(e, t) {
    var a = t.rest;
    if (a) {
      for (var i in a)
        t[i] = a[i];
      delete t.rest;
    }
    var o = new z4();
    return Xl(o, o.head, e), aR(e, o, t, o.head, 0), j4(o);
  },
  /**
   * @namespace
   * @memberof Prism
   * @public
   */
  hooks: {
    all: {},
    /**
     * Adds the given callback to the list of callbacks for the given hook.
     *
     * The callback will be invoked when the hook it is registered for is run.
     * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
     *
     * One callback function can be registered to multiple hooks and the same hook multiple times.
     *
     * @param {string} name The name of the hook.
     * @param {HookCallback} callback The callback function which is given environment variables.
     * @public
     */
    add: function(e, t) {
      var a = Rt.hooks.all;
      a[e] = a[e] || [], a[e].push(t);
    },
    /**
     * Runs a hook invoking all registered callbacks with the given environment variables.
     *
     * Callbacks will be invoked synchronously and in the order in which they were registered.
     *
     * @param {string} name The name of the hook.
     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
     * @public
     */
    run: function(e, t) {
      var a = Rt.hooks.all[e];
      if (!(!a || !a.length))
        for (var i = 0, o; o = a[i++]; )
          o(t);
    }
  },
  Token: qs
};
function qs(e, t, a, i) {
  this.type = e, this.content = t, this.alias = a, this.length = (i || "").length | 0;
}
function bA(e, t, a, i) {
  e.lastIndex = t;
  var o = e.exec(a);
  if (o && i && o[1]) {
    var l = o[1].length;
    o.index += l, o[0] = o[0].slice(l);
  }
  return o;
}
function aR(e, t, a, i, o, l) {
  for (var c in a)
    if (!(!a.hasOwnProperty(c) || !a[c])) {
      var d = a[c];
      d = Array.isArray(d) ? d : [d];
      for (var m = 0; m < d.length; ++m) {
        if (l && l.cause == c + "," + m)
          return;
        var f = d[m], b = f.inside, E = !!f.lookbehind, T = !!f.greedy, S = f.alias;
        if (T && !f.pattern.global) {
          var _ = f.pattern.toString().match(/[imsuy]*$/)[0];
          f.pattern = RegExp(f.pattern.source, _ + "g");
        }
        for (var k = f.pattern || f, R = i.next, C = o; R !== t.tail && !(l && C >= l.reach); C += R.value.length, R = R.next) {
          var L = R.value;
          if (t.length > e.length)
            return;
          if (!(L instanceof qs)) {
            var x = 1, Y;
            if (T) {
              if (Y = bA(k, C, e, E), !Y || Y.index >= e.length)
                break;
              var K = Y.index, q = Y.index + Y[0].length, D = C;
              for (D += R.value.length; K >= D; )
                R = R.next, D += R.value.length;
              if (D -= R.value.length, C = D, R.value instanceof qs)
                continue;
              for (var G = R; G !== t.tail && (D < q || typeof G.value == "string"); G = G.next)
                x++, D += G.value.length;
              x--, L = e.slice(C, D), Y.index -= C;
            } else if (Y = bA(k, 0, L, E), !Y)
              continue;
            var K = Y.index, Q = Y[0], U = L.slice(0, K), ee = L.slice(K + Q.length), ae = C + L.length;
            l && ae > l.reach && (l.reach = ae);
            var ue = R.prev;
            U && (ue = Xl(t, ue, U), C += U.length), G4(t, ue, x);
            var de = new qs(
              c,
              b ? Rt.tokenize(Q, b) : Q,
              S,
              Q
            );
            if (R = Xl(t, ue, de), ee && Xl(t, R, ee), x > 1) {
              var ce = {
                cause: c + "," + m,
                reach: ae
              };
              aR(
                e,
                t,
                a,
                R.prev,
                C,
                ce
              ), l && ce.reach > l.reach && (l.reach = ce.reach);
            }
          }
        }
      }
    }
}
function z4() {
  var e = { value: null, prev: null, next: null }, t = { value: null, prev: e, next: null };
  e.next = t, this.head = e, this.tail = t, this.length = 0;
}
function Xl(e, t, a) {
  var i = t.next, o = { value: a, prev: t, next: i };
  return t.next = o, i.prev = o, e.length++, o;
}
function G4(e, t, a) {
  for (var i = t.next, o = 0; o < a && i !== e.tail; o++)
    i = i.next;
  t.next = i, i.prev = t, e.length -= o;
}
function j4(e) {
  for (var t = [], a = e.head.next; a !== e.tail; )
    t.push(a.value), a = a.next;
  return t;
}
const rR = Rt;
function iR() {
}
iR.prototype = rR;
const N = new iR();
N.highlight = $4;
N.register = q4;
N.alias = Y4;
N.registered = V4;
N.listLanguages = W4;
N.util.encode = X4;
N.Token.stringify = lf;
function $4(e, t) {
  if (typeof e != "string")
    throw new TypeError("Expected `string` for `value`, got `" + e + "`");
  let a, i;
  if (t && typeof t == "object")
    a = t;
  else {
    if (i = t, typeof i != "string")
      throw new TypeError("Expected `string` for `name`, got `" + i + "`");
    if (Object.hasOwn(N.languages, i))
      a = N.languages[i];
    else
      throw new Error("Unknown language: `" + i + "` is not registered");
  }
  return {
    type: "root",
    // @ts-expect-error: we hacked Prism to accept and return the things we want.
    children: rR.highlight.call(N, e, a, i)
  };
}
function q4(e) {
  if (typeof e != "function" || !e.displayName)
    throw new Error("Expected `function` for `syntax`, got `" + e + "`");
  Object.hasOwn(N.languages, e.displayName) || e(N);
}
function Y4(e, t) {
  const a = N.languages;
  let i = {};
  typeof e == "string" ? t && (i[e] = t) : i = e;
  let o;
  for (o in i)
    if (Object.hasOwn(i, o)) {
      const l = i[o], c = typeof l == "string" ? [l] : l;
      let d = -1;
      for (; ++d < c.length; )
        a[c[d]] = a[o];
    }
}
function V4(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Expected `string` for `aliasOrLanguage`, got `" + e + "`"
    );
  return Object.hasOwn(N.languages, e);
}
function W4() {
  const e = N.languages, t = [];
  let a;
  for (a in e)
    Object.hasOwn(e, a) && typeof e[a] == "object" && t.push(a);
  return t;
}
function lf(e, t) {
  if (typeof e == "string")
    return { type: "text", value: e };
  if (Array.isArray(e)) {
    const i = [];
    let o = -1;
    for (; ++o < e.length; )
      e[o] !== null && e[o] !== void 0 && e[o] !== "" && i.push(
        /** @type {Element | Text} */
        lf(e[o], t)
      );
    return i;
  }
  const a = {
    attributes: {},
    classes: ["token", e.type],
    content: lf(e.content, t),
    language: t,
    tag: "span",
    type: e.type
  };
  return e.alias && a.classes.push(
    ...typeof e.alias == "string" ? [e.alias] : e.alias
  ), N.hooks.run("wrap", a), pN(
    a.tag + "." + a.classes.join("."),
    K4(a.attributes),
    a.content
  );
}
function X4(e) {
  return e;
}
function K4(e) {
  let t;
  for (t in e)
    Object.hasOwn(e, t) && (e[t] = B4(e[t]));
  return e;
}
const Z4 = {
  'code[class*="language-"]': {
    color: "black",
    background: "none",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    color: "black",
    background: "#f5f2f0",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    background: "#f5f2f0",
    padding: ".1em",
    borderRadius: ".3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "slategray"
  },
  prolog: {
    color: "slategray"
  },
  doctype: {
    color: "slategray"
  },
  cdata: {
    color: "slategray"
  },
  punctuation: {
    color: "#999"
  },
  namespace: {
    Opacity: ".7"
  },
  property: {
    color: "#905"
  },
  tag: {
    color: "#905"
  },
  boolean: {
    color: "#905"
  },
  number: {
    color: "#905"
  },
  constant: {
    color: "#905"
  },
  symbol: {
    color: "#905"
  },
  deleted: {
    color: "#905"
  },
  selector: {
    color: "#690"
  },
  "attr-name": {
    color: "#690"
  },
  string: {
    color: "#690"
  },
  char: {
    color: "#690"
  },
  builtin: {
    color: "#690"
  },
  inserted: {
    color: "#690"
  },
  operator: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  entity: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)",
    cursor: "help"
  },
  url: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  atrule: {
    color: "#07a"
  },
  "attr-value": {
    color: "#07a"
  },
  keyword: {
    color: "#07a"
  },
  function: {
    color: "#DD4A68"
  },
  "class-name": {
    color: "#DD4A68"
  },
  regex: {
    color: "#e90"
  },
  important: {
    color: "#e90",
    fontWeight: "bold"
  },
  variable: {
    color: "#e90"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
xt.displayName = "markup";
xt.aliases = ["atom", "html", "mathml", "rss", "ssml", "svg", "xml"];
function xt(e) {
  e.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, e.languages.markup.tag.inside["attr-value"].inside.entity = e.languages.markup.entity, e.languages.markup.doctype.inside["internal-subset"].inside = e.languages.markup, e.hooks.add("wrap", function(t) {
    t.type === "entity" && (t.attributes.title = t.content.value.replace(/&amp;/, "&"));
  }), Object.defineProperty(e.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(a, i) {
      var o = {};
      o["language-" + i] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: e.languages[i]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var l = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      l["language-" + i] = {
        pattern: /[\s\S]+/,
        inside: e.languages[i]
      };
      var c = {};
      c[a] = {
        pattern: RegExp(
          /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
            /__/g,
            function() {
              return a;
            }
          ),
          "i"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: l
      }, e.languages.insertBefore("markup", "cdata", c);
    }
  }), Object.defineProperty(e.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(t, a) {
      e.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [a, "language-" + a],
                inside: e.languages[a]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), e.languages.html = e.languages.markup, e.languages.mathml = e.languages.markup, e.languages.svg = e.languages.markup, e.languages.xml = e.languages.extend("markup", {}), e.languages.ssml = e.languages.xml, e.languages.atom = e.languages.xml, e.languages.rss = e.languages.xml;
}
Sr.displayName = "css";
Sr.aliases = [];
function Sr(e) {
  (function(t) {
    var a = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    t.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp(
          "@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + a.source + ")*?" + /(?:;|(?=\s*\{))/.source
        ),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp(
          "\\burl\\((?:" + a.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
          "i"
        ),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + a.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(
          `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + a.source + ")*(?=\\s*\\{)"
        ),
        lookbehind: !0
      },
      string: {
        pattern: a,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, t.languages.css.atrule.inside.rest = t.languages.css;
    var i = t.languages.markup;
    i && (i.tag.addInlined("style", "css"), i.tag.addAttribute("style", "css"));
  })(e);
}
ze.displayName = "clike";
ze.aliases = [];
function ze(e) {
  e.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  };
}
Pf.displayName = "regex";
Pf.aliases = [];
function Pf(e) {
  (function(t) {
    var a = {
      pattern: /\\[\\(){}[\]^$+*?|.]/,
      alias: "escape"
    }, i = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, o = {
      pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
      alias: "class-name"
    }, l = {
      pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
      alias: "class-name"
    }, c = "(?:[^\\\\-]|" + i.source + ")", d = RegExp(c + "-" + c), m = {
      pattern: /(<|')[^<>']+(?=[>']$)/,
      lookbehind: !0,
      alias: "variable"
    };
    t.languages.regex = {
      "char-class": {
        pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
        lookbehind: !0,
        inside: {
          "char-class-negation": {
            pattern: /(^\[)\^/,
            lookbehind: !0,
            alias: "operator"
          },
          "char-class-punctuation": {
            pattern: /^\[|\]$/,
            alias: "punctuation"
          },
          range: {
            pattern: d,
            inside: {
              escape: i,
              "range-punctuation": {
                pattern: /-/,
                alias: "operator"
              }
            }
          },
          "special-escape": a,
          "char-set": l,
          escape: i
        }
      },
      "special-escape": a,
      "char-set": o,
      backreference: [
        {
          // a backreference which is not an octal escape
          pattern: /\\(?![123][0-7]{2})[1-9]/,
          alias: "keyword"
        },
        {
          pattern: /\\k<[^<>']+>/,
          alias: "keyword",
          inside: {
            "group-name": m
          }
        }
      ],
      anchor: {
        pattern: /[$^]|\\[ABbGZz]/,
        alias: "function"
      },
      escape: i,
      group: [
        {
          // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
          // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
          // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
          pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
          alias: "punctuation",
          inside: {
            "group-name": m
          }
        },
        {
          pattern: /\)/,
          alias: "punctuation"
        }
      ],
      quantifier: {
        pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
        alias: "number"
      },
      alternation: {
        pattern: /\|/,
        alias: "keyword"
      }
    };
  })(e);
}
Bt.displayName = "javascript";
Bt.aliases = ["js"];
function Bt(e) {
  e.register(ze), e.languages.javascript = e.languages.extend("clike", {
    "class-name": [
      e.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), e.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, e.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: e.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: e.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: e.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: e.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: e.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), e.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: e.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), e.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), e.languages.markup && (e.languages.markup.tag.addInlined("script", "javascript"), e.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), e.languages.js = e.languages.javascript;
}
Hf.displayName = "abap";
Hf.aliases = [];
function Hf(e) {
  e.languages.abap = {
    comment: /^\*.*/m,
    string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    "string-template": {
      pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
      lookbehind: !0,
      alias: "string"
    },
    /* End Of Line comments should not interfere with strings when the
    quote character occurs within them. We assume a string being highlighted
    inside an EOL comment is more acceptable than the opposite.
    */
    "eol-comment": {
      pattern: /(^|\s)".*/m,
      lookbehind: !0,
      alias: "comment"
    },
    keyword: {
      pattern: /(\s|\.|^)(?:\*-INPUT|\?TO|ABAP-SOURCE|ABBREVIATED|ABS|ABSTRACT|ACCEPT|ACCEPTING|ACCESSPOLICY|ACCORDING|ACOS|ACTIVATION|ACTUAL|ADD|ADD-CORRESPONDING|ADJACENT|AFTER|ALIAS|ALIASES|ALIGN|ALL|ALLOCATE|ALPHA|ANALYSIS|ANALYZER|AND|ANY|APPEND|APPENDAGE|APPENDING|APPLICATION|ARCHIVE|AREA|ARITHMETIC|AS|ASCENDING|ASIN|ASPECT|ASSERT|ASSIGN|ASSIGNED|ASSIGNING|ASSOCIATION|ASYNCHRONOUS|AT|ATAN|ATTRIBUTES|AUTHORITY|AUTHORITY-CHECK|AVG|BACK|BACKGROUND|BACKUP|BACKWARD|BADI|BASE|BEFORE|BEGIN|BETWEEN|BIG|BINARY|BINDING|BIT|BIT-AND|BIT-NOT|BIT-OR|BIT-XOR|BLACK|BLANK|BLANKS|BLOB|BLOCK|BLOCKS|BLUE|BOUND|BOUNDARIES|BOUNDS|BOXED|BREAK-POINT|BT|BUFFER|BY|BYPASSING|BYTE|BYTE-CA|BYTE-CN|BYTE-CO|BYTE-CS|BYTE-NA|BYTE-NS|BYTE-ORDER|C|CA|CALL|CALLING|CASE|CAST|CASTING|CATCH|CEIL|CENTER|CENTERED|CHAIN|CHAIN-INPUT|CHAIN-REQUEST|CHANGE|CHANGING|CHANNELS|CHAR-TO-HEX|CHARACTER|CHARLEN|CHECK|CHECKBOX|CIRCULAR|CI_|CLASS|CLASS-CODING|CLASS-DATA|CLASS-EVENTS|CLASS-METHODS|CLASS-POOL|CLEANUP|CLEAR|CLIENT|CLOB|CLOCK|CLOSE|CN|CNT|CO|COALESCE|CODE|CODING|COLLECT|COLOR|COLUMN|COLUMNS|COL_BACKGROUND|COL_GROUP|COL_HEADING|COL_KEY|COL_NEGATIVE|COL_NORMAL|COL_POSITIVE|COL_TOTAL|COMMENT|COMMENTS|COMMIT|COMMON|COMMUNICATION|COMPARING|COMPONENT|COMPONENTS|COMPRESSION|COMPUTE|CONCAT|CONCATENATE|COND|CONDENSE|CONDITION|CONNECT|CONNECTION|CONSTANTS|CONTEXT|CONTEXTS|CONTINUE|CONTROL|CONTROLS|CONV|CONVERSION|CONVERT|COPIES|COPY|CORRESPONDING|COS|COSH|COUNT|COUNTRY|COVER|CP|CPI|CREATE|CREATING|CRITICAL|CS|CURRENCY|CURRENCY_CONVERSION|CURRENT|CURSOR|CURSOR-SELECTION|CUSTOMER|CUSTOMER-FUNCTION|DANGEROUS|DATA|DATABASE|DATAINFO|DATASET|DATE|DAYLIGHT|DBMAXLEN|DD\/MM\/YY|DD\/MM\/YYYY|DDMMYY|DEALLOCATE|DECIMALS|DECIMAL_SHIFT|DECLARATIONS|DEEP|DEFAULT|DEFERRED|DEFINE|DEFINING|DEFINITION|DELETE|DELETING|DEMAND|DEPARTMENT|DESCENDING|DESCRIBE|DESTINATION|DETAIL|DIALOG|DIRECTORY|DISCONNECT|DISPLAY|DISPLAY-MODE|DISTANCE|DISTINCT|DIV|DIVIDE|DIVIDE-CORRESPONDING|DIVISION|DO|DUMMY|DUPLICATE|DUPLICATES|DURATION|DURING|DYNAMIC|DYNPRO|E|EACH|EDIT|EDITOR-CALL|ELSE|ELSEIF|EMPTY|ENABLED|ENABLING|ENCODING|END|END-ENHANCEMENT-SECTION|END-LINES|END-OF-DEFINITION|END-OF-FILE|END-OF-PAGE|END-OF-SELECTION|ENDAT|ENDCASE|ENDCATCH|ENDCHAIN|ENDCLASS|ENDDO|ENDENHANCEMENT|ENDEXEC|ENDFOR|ENDFORM|ENDFUNCTION|ENDIAN|ENDIF|ENDING|ENDINTERFACE|ENDLOOP|ENDMETHOD|ENDMODULE|ENDON|ENDPROVIDE|ENDSELECT|ENDTRY|ENDWHILE|ENGINEERING|ENHANCEMENT|ENHANCEMENT-POINT|ENHANCEMENT-SECTION|ENHANCEMENTS|ENTRIES|ENTRY|ENVIRONMENT|EQ|EQUAL|EQUIV|ERRORMESSAGE|ERRORS|ESCAPE|ESCAPING|EVENT|EVENTS|EXACT|EXCEPT|EXCEPTION|EXCEPTION-TABLE|EXCEPTIONS|EXCLUDE|EXCLUDING|EXEC|EXECUTE|EXISTS|EXIT|EXIT-COMMAND|EXP|EXPAND|EXPANDING|EXPIRATION|EXPLICIT|EXPONENT|EXPORT|EXPORTING|EXTEND|EXTENDED|EXTENSION|EXTRACT|FAIL|FETCH|FIELD|FIELD-GROUPS|FIELD-SYMBOL|FIELD-SYMBOLS|FIELDS|FILE|FILTER|FILTER-TABLE|FILTERS|FINAL|FIND|FIRST|FIRST-LINE|FIXED-POINT|FKEQ|FKGE|FLOOR|FLUSH|FONT|FOR|FORM|FORMAT|FORWARD|FOUND|FRAC|FRAME|FRAMES|FREE|FRIENDS|FROM|FUNCTION|FUNCTION-POOL|FUNCTIONALITY|FURTHER|GAPS|GE|GENERATE|GET|GIVING|GKEQ|GKGE|GLOBAL|GRANT|GREATER|GREEN|GROUP|GROUPS|GT|HANDLE|HANDLER|HARMLESS|HASHED|HAVING|HDB|HEAD-LINES|HEADER|HEADERS|HEADING|HELP-ID|HELP-REQUEST|HIDE|HIGH|HINT|HOLD|HOTSPOT|I|ICON|ID|IDENTIFICATION|IDENTIFIER|IDS|IF|IGNORE|IGNORING|IMMEDIATELY|IMPLEMENTATION|IMPLEMENTATIONS|IMPLEMENTED|IMPLICIT|IMPORT|IMPORTING|IN|INACTIVE|INCL|INCLUDE|INCLUDES|INCLUDING|INCREMENT|INDEX|INDEX-LINE|INFOTYPES|INHERITING|INIT|INITIAL|INITIALIZATION|INNER|INOUT|INPUT|INSERT|INSTANCES|INTENSIFIED|INTERFACE|INTERFACE-POOL|INTERFACES|INTERNAL|INTERVALS|INTO|INVERSE|INVERTED-DATE|IS|ISO|ITERATOR|ITNO|JOB|JOIN|KEEP|KEEPING|KERNEL|KEY|KEYS|KEYWORDS|KIND|LANGUAGE|LAST|LATE|LAYOUT|LE|LEADING|LEAVE|LEFT|LEFT-JUSTIFIED|LEFTPLUS|LEFTSPACE|LEGACY|LENGTH|LESS|LET|LEVEL|LEVELS|LIKE|LINE|LINE-COUNT|LINE-SELECTION|LINE-SIZE|LINEFEED|LINES|LIST|LIST-PROCESSING|LISTBOX|LITTLE|LLANG|LOAD|LOAD-OF-PROGRAM|LOB|LOCAL|LOCALE|LOCATOR|LOG|LOG-POINT|LOG10|LOGFILE|LOGICAL|LONG|LOOP|LOW|LOWER|LPAD|LPI|LT|M|MAIL|MAIN|MAJOR-ID|MAPPING|MARGIN|MARK|MASK|MATCH|MATCHCODE|MAX|MAXIMUM|MEDIUM|MEMBERS|MEMORY|MESH|MESSAGE|MESSAGE-ID|MESSAGES|MESSAGING|METHOD|METHODS|MIN|MINIMUM|MINOR-ID|MM\/DD\/YY|MM\/DD\/YYYY|MMDDYY|MOD|MODE|MODIF|MODIFIER|MODIFY|MODULE|MOVE|MOVE-CORRESPONDING|MULTIPLY|MULTIPLY-CORRESPONDING|NA|NAME|NAMETAB|NATIVE|NB|NE|NESTED|NESTING|NEW|NEW-LINE|NEW-PAGE|NEW-SECTION|NEXT|NO|NO-DISPLAY|NO-EXTENSION|NO-GAP|NO-GAPS|NO-GROUPING|NO-HEADING|NO-SCROLLING|NO-SIGN|NO-TITLE|NO-TOPOFPAGE|NO-ZERO|NODE|NODES|NON-UNICODE|NON-UNIQUE|NOT|NP|NS|NULL|NUMBER|NUMOFCHAR|O|OBJECT|OBJECTS|OBLIGATORY|OCCURRENCE|OCCURRENCES|OCCURS|OF|OFF|OFFSET|OLE|ON|ONLY|OPEN|OPTION|OPTIONAL|OPTIONS|OR|ORDER|OTHER|OTHERS|OUT|OUTER|OUTPUT|OUTPUT-LENGTH|OVERFLOW|OVERLAY|PACK|PACKAGE|PAD|PADDING|PAGE|PAGES|PARAMETER|PARAMETER-TABLE|PARAMETERS|PART|PARTIALLY|PATTERN|PERCENTAGE|PERFORM|PERFORMING|PERSON|PF|PF-STATUS|PINK|PLACES|POOL|POSITION|POS_HIGH|POS_LOW|PRAGMAS|PRECOMPILED|PREFERRED|PRESERVING|PRIMARY|PRINT|PRINT-CONTROL|PRIORITY|PRIVATE|PROCEDURE|PROCESS|PROGRAM|PROPERTY|PROTECTED|PROVIDE|PUBLIC|PUSHBUTTON|PUT|QUEUE-ONLY|QUICKINFO|RADIOBUTTON|RAISE|RAISING|RANGE|RANGES|RAW|READ|READ-ONLY|READER|RECEIVE|RECEIVED|RECEIVER|RECEIVING|RED|REDEFINITION|REDUCE|REDUCED|REF|REFERENCE|REFRESH|REGEX|REJECT|REMOTE|RENAMING|REPLACE|REPLACEMENT|REPLACING|REPORT|REQUEST|REQUESTED|RESERVE|RESET|RESOLUTION|RESPECTING|RESPONSIBLE|RESULT|RESULTS|RESUMABLE|RESUME|RETRY|RETURN|RETURNCODE|RETURNING|RIGHT|RIGHT-JUSTIFIED|RIGHTPLUS|RIGHTSPACE|RISK|RMC_COMMUNICATION_FAILURE|RMC_INVALID_STATUS|RMC_SYSTEM_FAILURE|ROLE|ROLLBACK|ROUND|ROWS|RTTI|RUN|SAP|SAP-SPOOL|SAVING|SCALE_PRESERVING|SCALE_PRESERVING_SCIENTIFIC|SCAN|SCIENTIFIC|SCIENTIFIC_WITH_LEADING_ZERO|SCREEN|SCROLL|SCROLL-BOUNDARY|SCROLLING|SEARCH|SECONDARY|SECONDS|SECTION|SELECT|SELECT-OPTIONS|SELECTION|SELECTION-SCREEN|SELECTION-SET|SELECTION-SETS|SELECTION-TABLE|SELECTIONS|SELECTOR|SEND|SEPARATE|SEPARATED|SET|SHARED|SHIFT|SHORT|SHORTDUMP-ID|SIGN|SIGN_AS_POSTFIX|SIMPLE|SIN|SINGLE|SINH|SIZE|SKIP|SKIPPING|SMART|SOME|SORT|SORTABLE|SORTED|SOURCE|SPACE|SPECIFIED|SPLIT|SPOOL|SPOTS|SQL|SQLSCRIPT|SQRT|STABLE|STAMP|STANDARD|START-OF-SELECTION|STARTING|STATE|STATEMENT|STATEMENTS|STATIC|STATICS|STATUSINFO|STEP-LOOP|STOP|STRLEN|STRUCTURE|STRUCTURES|STYLE|SUBKEY|SUBMATCHES|SUBMIT|SUBROUTINE|SUBSCREEN|SUBSTRING|SUBTRACT|SUBTRACT-CORRESPONDING|SUFFIX|SUM|SUMMARY|SUMMING|SUPPLIED|SUPPLY|SUPPRESS|SWITCH|SWITCHSTATES|SYMBOL|SYNCPOINTS|SYNTAX|SYNTAX-CHECK|SYNTAX-TRACE|SYSTEM-CALL|SYSTEM-EXCEPTIONS|SYSTEM-EXIT|TAB|TABBED|TABLE|TABLES|TABLEVIEW|TABSTRIP|TAN|TANH|TARGET|TASK|TASKS|TEST|TESTING|TEXT|TEXTPOOL|THEN|THROW|TIME|TIMES|TIMESTAMP|TIMEZONE|TITLE|TITLE-LINES|TITLEBAR|TO|TOKENIZATION|TOKENS|TOP-LINES|TOP-OF-PAGE|TRACE-FILE|TRACE-TABLE|TRAILING|TRANSACTION|TRANSFER|TRANSFORMATION|TRANSLATE|TRANSPORTING|TRMAC|TRUNC|TRUNCATE|TRUNCATION|TRY|TYPE|TYPE-POOL|TYPE-POOLS|TYPES|ULINE|UNASSIGN|UNDER|UNICODE|UNION|UNIQUE|UNIT|UNIT_CONVERSION|UNIX|UNPACK|UNTIL|UNWIND|UP|UPDATE|UPPER|USER|USER-COMMAND|USING|UTF-8|VALID|VALUE|VALUE-REQUEST|VALUES|VARY|VARYING|VERIFICATION-MESSAGE|VERSION|VIA|VIEW|VISIBLE|WAIT|WARNING|WHEN|WHENEVER|WHERE|WHILE|WIDTH|WINDOW|WINDOWS|WITH|WITH-HEADING|WITH-TITLE|WITHOUT|WORD|WORK|WRITE|WRITER|X|XML|XOR|XSD|XSTRLEN|YELLOW|YES|YYMMDD|Z|ZERO|ZONE)(?![\w-])/i,
      lookbehind: !0
    },
    /* Numbers can be only integers. Decimal or Hex appear only as strings */
    number: /\b\d+\b/,
    /* Operators must always be surrounded by whitespace, they cannot be put
    adjacent to operands.
    */
    operator: {
      pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
      lookbehind: !0
    },
    "string-operator": {
      pattern: /(\s)&&?(?=\s)/,
      lookbehind: !0,
      /* The official editor highlights */
      alias: "keyword"
    },
    "token-operator": [
      {
        /* Special operators used to access structure components, class methods/attributes, etc. */
        pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
        lookbehind: !0,
        alias: "punctuation"
      },
      {
        /* Special tokens used do delimit string templates */
        pattern: /[|{}]/,
        alias: "punctuation"
      }
    ],
    punctuation: /[,.:()]/
  };
}
zf.displayName = "abnf";
zf.aliases = [];
function zf(e) {
  (function(t) {
    var a = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
    t.languages.abnf = {
      comment: /;.*/,
      string: {
        pattern: /(?:%[is])?"[^"\n\r]*"/,
        greedy: !0,
        inside: {
          punctuation: /^%[is]/
        }
      },
      range: {
        pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
        alias: "number"
      },
      terminal: {
        pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
        alias: "number"
      },
      repetition: {
        pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
        lookbehind: !0,
        alias: "operator"
      },
      definition: {
        pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
        lookbehind: !0,
        alias: "keyword",
        inside: {
          punctuation: /<|>/
        }
      },
      "core-rule": {
        pattern: RegExp(
          "(?:(^|[^<\\w-])" + a + "|<" + a + ">)(?![\\w-])",
          "i"
        ),
        lookbehind: !0,
        alias: ["rule", "constant"],
        inside: {
          punctuation: /<|>/
        }
      },
      rule: {
        pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
        lookbehind: !0,
        inside: {
          punctuation: /<|>/
        }
      },
      operator: /=\/?|\//,
      punctuation: /[()\[\]]/
    };
  })(e);
}
Gf.displayName = "actionscript";
Gf.aliases = [];
function Gf(e) {
  e.register(Bt), e.languages.actionscript = e.languages.extend("javascript", {
    keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
    operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
  }), e.languages.actionscript["class-name"].alias = "function", delete e.languages.actionscript.parameter, delete e.languages.actionscript["literal-property"], e.languages.markup && e.languages.insertBefore("actionscript", "string", {
    xml: {
      pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
      lookbehind: !0,
      inside: e.languages.markup
    }
  });
}
jf.displayName = "ada";
jf.aliases = [];
function jf(e) {
  e.languages.ada = {
    comment: /--.*/,
    string: /"(?:""|[^"\r\f\n])*"/,
    number: [
      {
        pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
      },
      {
        pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
      }
    ],
    attribute: {
      pattern: /\b'\w+/,
      alias: "attr-name"
    },
    keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|or|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
    boolean: /\b(?:false|true)\b/i,
    operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
    punctuation: /\.\.?|[,;():]/,
    char: /'.'/,
    variable: /\b[a-z](?:\w)*\b/i
  };
}
$f.displayName = "agda";
$f.aliases = [];
function $f(e) {
  (function(t) {
    t.languages.agda = {
      comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
        greedy: !0
      },
      punctuation: /[(){}.;@]/,
      "class-name": {
        pattern: /((?:data|record) +)\S+/,
        lookbehind: !0
      },
      function: {
        pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
        lookbehind: !0
      },
      operator: {
        pattern: /(^\s*|\s)(?:[=|:\\?_]|->)(?=\s)/,
        lookbehind: !0
      },
      keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
    };
  })(e);
}
qf.displayName = "al";
qf.aliases = [];
function qf(e) {
  e.languages.al = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
    string: {
      pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
      greedy: !0
    },
    function: {
      pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
      lookbehind: !0
    },
    keyword: [
      // keywords
      /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
      // objects and metadata that are used like keywords
      /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
    ],
    number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
    boolean: /\b(?:false|true)\b/i,
    variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
    "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
    operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
    punctuation: /[()\[\]{}:.;,]/
  };
}
Yf.displayName = "antlr4";
Yf.aliases = ["g4"];
function Yf(e) {
  e.languages.antlr4 = {
    comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    string: {
      pattern: /'(?:\\.|[^\\'\r\n])*'/,
      greedy: !0
    },
    "character-class": {
      pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
      greedy: !0,
      alias: "regex",
      inside: {
        range: {
          pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
          lookbehind: !0,
          alias: "punctuation"
        },
        escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
        punctuation: /[\[\]]/
      }
    },
    action: {
      pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
      greedy: !0,
      inside: {
        content: {
          // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
          pattern: /(\{)[\s\S]+(?=\})/,
          lookbehind: !0
        },
        punctuation: /[{}]/
      }
    },
    command: {
      pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
      lookbehind: !0,
      inside: {
        function: /\b\w+(?=\s*(?:[,(]|$))/,
        punctuation: /[,()]/
      }
    },
    annotation: {
      pattern: /@\w+(?:::\w+)*/,
      alias: "keyword"
    },
    label: {
      pattern: /#[ \t]*\w+/,
      alias: "punctuation"
    },
    keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
    definition: [
      {
        pattern: /\b[a-z]\w*(?=\s*:)/,
        alias: ["rule", "class-name"]
      },
      {
        pattern: /\b[A-Z]\w*(?=\s*:)/,
        alias: ["token", "constant"]
      }
    ],
    constant: /\b[A-Z][A-Z_]*\b/,
    operator: /\.\.|->|[|~]|[*+?]\??/,
    punctuation: /[;:()=]/
  }, e.languages.g4 = e.languages.antlr4;
}
Vf.displayName = "apacheconf";
Vf.aliases = [];
function Vf(e) {
  e.languages.apacheconf = {
    comment: /#.*/,
    "directive-inline": {
      pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
      lookbehind: !0,
      alias: "property"
    },
    "directive-block": {
      pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
      inside: {
        "directive-block": {
          pattern: /^<\/?\w+/,
          inside: {
            punctuation: /^<\/?/
          },
          alias: "tag"
        },
        "directive-block-parameter": {
          pattern: /.*[^>]/,
          inside: {
            punctuation: /:/,
            string: {
              pattern: /("|').*\1/,
              inside: {
                variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
              }
            }
          },
          alias: "attr-value"
        },
        punctuation: />/
      },
      alias: "tag"
    },
    "directive-flags": {
      pattern: /\[(?:[\w=],?)+\]/,
      alias: "keyword"
    },
    string: {
      pattern: /("|').*\1/,
      inside: {
        variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
      }
    },
    variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
    regex: /\^?.*\$|\^.*\$?/
  };
}
co.displayName = "sql";
co.aliases = [];
function co(e) {
  e.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: !0,
      lookbehind: !0,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  };
}
Wf.displayName = "apex";
Wf.aliases = [];
function Wf(e) {
  e.register(ze), e.register(co), (function(t) {
    var a = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i, i = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
      /<keyword>/g,
      function() {
        return a.source;
      }
    );
    function o(c) {
      return RegExp(
        c.replace(/<CLASS-NAME>/g, function() {
          return i;
        }),
        "i"
      );
    }
    var l = {
      keyword: a,
      punctuation: /[()\[\]{};,:.<>]/
    };
    t.languages.apex = {
      comment: t.languages.clike.comment,
      string: t.languages.clike.string,
      sql: {
        pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
        lookbehind: !0,
        greedy: !0,
        alias: "language-sql",
        inside: t.languages.sql
      },
      annotation: {
        pattern: /@\w+\b/,
        alias: "punctuation"
      },
      "class-name": [
        {
          pattern: o(
            /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
          ),
          lookbehind: !0,
          inside: l
        },
        {
          // cast
          pattern: o(
            /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
          ),
          lookbehind: !0,
          inside: l
        },
        {
          // variable/parameter declaration and return types
          pattern: o(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
          inside: l
        }
      ],
      trigger: {
        pattern: /(\btrigger\s+)\w+\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      keyword: a,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/i,
      number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
      operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
      punctuation: /[()\[\]{};,.]/
    };
  })(e);
}
Xf.displayName = "apl";
Xf.aliases = [];
function Xf(e) {
  e.languages.apl = {
    comment: /(?:|#[! ]).*$/m,
    string: {
      pattern: /'(?:[^'\r\n]|'')*'/,
      greedy: !0
    },
    number: /?(?:\d*\.?\b\d+(?:e[+]?\d+)?||)(?:j?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+]?\d+)?||))?/i,
    statement: /:[A-Z][a-z][A-Za-z]*\b/,
    "system-function": {
      pattern: /[A-Z]+/i,
      alias: "function"
    },
    constant: /[#]/,
    function: /[-+|?*!<=>~,]/,
    "monadic-operator": {
      pattern: /[\\\/&]/,
      alias: "operator"
    },
    "dyadic-operator": {
      pattern: /[.@]/,
      alias: "operator"
    },
    assignment: {
      pattern: //,
      alias: "keyword"
    },
    punctuation: /[\[;\]()]/,
    dfn: {
      pattern: /[{}:]/,
      alias: "builtin"
    }
  };
}
Kf.displayName = "applescript";
Kf.aliases = [];
function Kf(e) {
  e.languages.applescript = {
    comment: [
      // Allow one level of nesting
      /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
      /--.+/,
      /#.+/
    ],
    string: /"(?:\\.|[^"\\\r\n])*"/,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
    operator: [
      /[&=*+\-\/^]|[<>]=?/,
      /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
    ],
    keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
    "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
    punctuation: /[{}():,]/
  };
}
Zf.displayName = "aql";
Zf.aliases = [];
function Zf(e) {
  e.languages.aql = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
    property: {
      pattern: /([{,]\s*)(?:(?!\d)\w+|(["'`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
      greedy: !0
    },
    identifier: {
      pattern: /([`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
      greedy: !0
    },
    variable: /@@?\w+/,
    keyword: [
      {
        pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
        lookbehind: !0
      },
      /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
      // pseudo keywords get a lookbehind to avoid false positives
      {
        pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
        lookbehind: !0
      },
      {
        pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
        lookbehind: !0
      },
      {
        pattern: /\bOPTIONS(?=\s*\{)/i
      }
    ],
    function: /\b(?!\d)\w+(?=\s*\()/,
    boolean: /\b(?:false|true)\b/i,
    range: {
      pattern: /\.\./,
      alias: "operator"
    },
    number: [
      /\b0b[01]+/i,
      /\b0x[0-9a-f]+/i,
      /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
    ],
    operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
    punctuation: /::|[?.:,;()[\]{}]/
  };
}
jn.displayName = "c";
jn.aliases = [];
function jn(e) {
  e.register(ze), e.languages.c = e.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), e.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: !0
    }
  }), e.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          },
          e.languages.c.string
        ],
        char: e.languages.c.char,
        comment: e.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: e.languages.c
        }
      }
    }
  }), e.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete e.languages.c.boolean;
}
vi.displayName = "cpp";
vi.aliases = [];
function vi(e) {
  e.register(jn), (function(t) {
    var a = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, i = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
      /<keyword>/g,
      function() {
        return a.source;
      }
    );
    t.languages.cpp = t.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(
            /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
              /<keyword>/g,
              function() {
                return a.source;
              }
            )
          ),
          lookbehind: !0
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: a,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), t.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
            /<mod-name>/g,
            function() {
              return i;
            }
          ) + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: !0
      }
    }), t.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: t.languages.cpp
          }
        }
      }
    }), t.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), t.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: t.languages.extend("cpp", {})
      }
    }), t.languages.insertBefore(
      "inside",
      "double-colon",
      {
        // All untokenized words that are not namespaces should be class names
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
      },
      t.languages.cpp["base-clause"]
    );
  })(e);
}
Qf.displayName = "arduino";
Qf.aliases = ["ino"];
function Qf(e) {
  e.register(vi), e.languages.arduino = e.languages.extend("cpp", {
    keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
    constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
    builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
  }), e.languages.ino = e.languages.arduino;
}
Jf.displayName = "arff";
Jf.aliases = [];
function Jf(e) {
  e.languages.arff = {
    comment: /%.*/,
    string: {
      pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: /@(?:attribute|data|end|relation)\b/i,
    number: /\b\d+(?:\.\d+)?\b/,
    punctuation: /[{},]/
  };
}
em.displayName = "armasm";
em.aliases = ["arm-asm"];
function em(e) {
  e.languages.armasm = {
    comment: {
      pattern: /;.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\r\n]|"")*"/,
      greedy: !0,
      inside: {
        variable: {
          pattern: /((?:^|[^$])(?:\${2})*)\$\w+/,
          lookbehind: !0
        }
      }
    },
    char: {
      pattern: /'(?:[^'\r\n]{0,4}|'')'/,
      greedy: !0
    },
    "version-symbol": {
      pattern: /\|[\w@]+\|/,
      greedy: !0,
      alias: "property"
    },
    boolean: /\b(?:FALSE|TRUE)\b/,
    directive: {
      pattern: /\b(?:ALIAS|ALIGN|AREA|ARM|ASSERT|ATTR|CN|CODE|CODE16|CODE32|COMMON|CP|DATA|DCB|DCD|DCDO|DCDU|DCFD|DCFDU|DCI|DCQ|DCQU|DCW|DCWU|DN|ELIF|ELSE|END|ENDFUNC|ENDIF|ENDP|ENTRY|EQU|EXPORT|EXPORTAS|EXTERN|FIELD|FILL|FN|FUNCTION|GBLA|GBLL|GBLS|GET|GLOBAL|IF|IMPORT|INCBIN|INCLUDE|INFO|KEEP|LCLA|LCLL|LCLS|LTORG|MACRO|MAP|MEND|MEXIT|NOFP|OPT|PRESERVE8|PROC|QN|READONLY|RELOC|REQUIRE|REQUIRE8|RLIST|ROUT|SETA|SETL|SETS|SN|SPACE|SUBT|THUMB|THUMBX|TTL|WEND|WHILE)\b/,
      alias: "property"
    },
    instruction: {
      pattern: /((?:^|(?:^|[^\\])(?:\r\n?|\n))[ \t]*(?:(?:[A-Z][A-Z0-9_]*[a-z]\w*|[a-z]\w*|\d+)[ \t]+)?)\b[A-Z.]+\b/,
      lookbehind: !0,
      alias: "keyword"
    },
    variable: /\$\w+/,
    number: /(?:\b[2-9]_\d+|(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e-?\d+)?|\b0(?:[fd]_|x)[0-9a-f]+|&[0-9a-f]+)\b/i,
    register: {
      pattern: /\b(?:r\d|lr)\b/,
      alias: "symbol"
    },
    operator: /<>|<<|>>|&&|\|\||[=!<>/]=?|[+\-*%#?&|^]|:[A-Z]+:/,
    punctuation: /[()[\],]/
  }, e.languages["arm-asm"] = e.languages.armasm;
}
_u.displayName = "bash";
_u.aliases = ["sh", "shell"];
function _u(e) {
  (function(t) {
    var a = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", i = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      // this looks reasonably well in all themes
      inside: null
      // see below
    }, o = {
      bash: i,
      environment: {
        pattern: RegExp("\\$" + a),
        alias: "constant"
      },
      variable: [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: !0,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            variable: [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: !0
              },
              /^\$\(\(/
            ],
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            punctuation: /\(\(?|\)\)?|,|;/
          }
        },
        // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: !0,
          inside: {
            variable: /^\$\(|^`|\)$|`$/
          }
        },
        // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: !0,
          inside: {
            operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            punctuation: /[\[\]]/,
            environment: {
              pattern: RegExp("(\\{)" + a),
              lookbehind: !0,
              alias: "constant"
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    t.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: !0
      },
      "function-name": [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not foo {
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: !0,
          alias: "function"
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: "function"
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: !0
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (= and +=).
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + a),
            lookbehind: !0,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: !0
      },
      // Highlight parameter names as variables
      parameter: {
        pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
        alias: "variable",
        lookbehind: !0
      },
      string: [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: !0,
          greedy: !0,
          inside: o
        },
        // Here-document with quotes around the tag
        //  No expansion (so no inside).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            bash: i
          }
        },
        // Normal string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: !0,
          greedy: !0,
          inside: o
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: !0,
          inside: {
            entity: o.entity
          }
        }
      ],
      environment: {
        pattern: RegExp("\\$?" + a),
        alias: "constant"
      },
      variable: o.variable,
      function: {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      builtin: {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: !0,
        // Alias added to make those easier to distinguish from strings.
        alias: "class-name"
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      operator: {
        // Lots of redirections here, but not just that.
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: !0
      }
    }, i.inside = t.languages.bash;
    for (var l = [
      "comment",
      "function-name",
      "for-or-select",
      "assign-left",
      "parameter",
      "string",
      "environment",
      "function",
      "keyword",
      "builtin",
      "boolean",
      "file-descriptor",
      "operator",
      "punctuation",
      "number"
    ], c = o.variable[1].inside, d = 0; d < l.length; d++)
      c[l[d]] = t.languages.bash[l[d]];
    t.languages.sh = t.languages.bash, t.languages.shell = t.languages.bash;
  })(e);
}
Au.displayName = "yaml";
Au.aliases = ["yml"];
function Au(e) {
  (function(t) {
    var a = /[*&][^\s[\]{},]+/, i = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, o = "(?:" + i.source + "(?:[ 	]+" + a.source + ")?|" + a.source + "(?:[ 	]+" + i.source + ")?)", l = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
      /<PLAIN>/g,
      function() {
        return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
      }
    ), c = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function d(m, f) {
      f = (f || "").replace(/m/g, "") + "m";
      var b = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
        return o;
      }).replace(/<<value>>/g, function() {
        return m;
      });
      return RegExp(b, f);
    }
    t.languages.yaml = {
      scalar: {
        pattern: RegExp(
          /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
            /<<prop>>/g,
            function() {
              return o;
            }
          )
        ),
        lookbehind: !0,
        alias: "string"
      },
      comment: /#.*/,
      key: {
        pattern: RegExp(
          /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
            return o;
          }).replace(/<<key>>/g, function() {
            return "(?:" + l + "|" + c + ")";
          })
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "atrule"
      },
      directive: {
        pattern: /(^[ \t]*)%.+/m,
        lookbehind: !0,
        alias: "important"
      },
      datetime: {
        pattern: d(
          /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
        ),
        lookbehind: !0,
        alias: "number"
      },
      boolean: {
        pattern: d(/false|true/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      null: {
        pattern: d(/null|~/.source, "i"),
        lookbehind: !0,
        alias: "important"
      },
      string: {
        pattern: d(c),
        lookbehind: !0,
        greedy: !0
      },
      number: {
        pattern: d(
          /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
          "i"
        ),
        lookbehind: !0
      },
      tag: i,
      important: a,
      punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
    }, t.languages.yml = t.languages.yaml;
  })(e);
}
tm.displayName = "markdown";
tm.aliases = ["md"];
function tm(e) {
  e.register(xt), (function(t) {
    var a = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function i(d) {
      return d = d.replace(/<inner>/g, function() {
        return a;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + d + ")");
    }
    var o = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, l = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
      /__/g,
      function() {
        return o;
      }
    ), c = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    t.languages.markdown = t.languages.extend("markup", {}), t.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: t.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp(
          "^" + l + c + "(?:" + l + ")*",
          "m"
        ),
        inside: {
          "table-data-rows": {
            pattern: RegExp(
              "^(" + l + c + ")(?:" + l + ")*$"
            ),
            lookbehind: !0,
            inside: {
              "table-data": {
                pattern: RegExp(o),
                inside: t.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + l + ")" + c + "$"),
            lookbehind: !0,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + l + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(o),
                alias: "important",
                inside: t.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: !0
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: i(
          /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: i(
          /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: i(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: !0,
        greedy: !0,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: i(
          /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: !0,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: !0
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: !0
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: !0
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(d) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(
        function(m) {
          d !== m && (t.languages.markdown[d].inside.content.inside[m] = t.languages.markdown[m]);
        }
      );
    }), t.hooks.add("after-tokenize", function(d) {
      if (d.language !== "markdown" && d.language !== "md")
        return;
      function m(f) {
        if (!(!f || typeof f == "string"))
          for (var b = 0, E = f.length; b < E; b++) {
            var T = f[b];
            if (T.type !== "code") {
              m(T.content);
              continue;
            }
            var S = T.content[1], _ = T.content[3];
            if (S && _ && S.type === "code-language" && _.type === "code-block" && typeof S.content == "string") {
              var k = S.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              k = (/[a-z][\w-]*/i.exec(k) || [""])[0].toLowerCase();
              var R = "language-" + k;
              _.alias ? typeof _.alias == "string" ? _.alias = [_.alias, R] : _.alias.push(R) : _.alias = [R];
            }
          }
      }
      m(d.tokens);
    }), t.hooks.add("wrap", function(d) {
      if (d.type === "code-block") {
        for (var m = "", f = 0, b = d.classes.length; f < b; f++) {
          var E = d.classes[f], T = /language-(.+)/.exec(E);
          if (T) {
            m = T[1];
            break;
          }
        }
        var S = t.languages[m];
        if (S)
          d.content = t.highlight(d.content.value, S, m);
        else if (m && m !== "none" && t.plugins.autoloader) {
          var _ = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          d.attributes.id = _, t.plugins.autoloader.loadLanguages(m, function() {
            var k = document.getElementById(_);
            k && (k.innerHTML = t.highlight(
              k.textContent,
              t.languages[m],
              m
            ));
          });
        }
      }
    }), RegExp(t.languages.markup.tag.pattern.source, "gi"), t.languages.md = t.languages.markdown;
  })(e);
}
nm.displayName = "arturo";
nm.aliases = ["art"];
function nm(e) {
  (function(t) {
    var a = function(i, o) {
      return {
        pattern: RegExp(
          /\{!/.source + "(?:" + (o || i) + ")" + /$[\s\S]*\}/.source,
          "m"
        ),
        greedy: !0,
        inside: {
          embedded: {
            pattern: /(^\{!\w+\b)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            alias: "language-" + i,
            inside: t.languages[i]
          },
          string: /[\s\S]+/
        }
      };
    };
    t.languages.arturo = {
      comment: {
        pattern: /;.*/,
        greedy: !0
      },
      character: {
        pattern: /`.`/,
        alias: "char",
        greedy: !0
      },
      number: {
        pattern: /\b\d+(?:\.\d+(?:\.\d+(?:-[\w+-]+)?)?)?\b/
      },
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"/,
        greedy: !0
      },
      regex: {
        pattern: /\{\/.*?\/\}/,
        greedy: !0
      },
      "html-string": a("html"),
      "css-string": a("css"),
      "js-string": a("js"),
      "md-string": a("md"),
      "sql-string": a("sql"),
      "sh-string": a("shell", "sh"),
      multistring: {
        pattern: /.*|\{:[\s\S]*?:\}|\{[\s\S]*?\}|^-{6}$[\s\S]*/m,
        alias: "string",
        greedy: !0
      },
      label: {
        pattern: /\w+\b\??:/,
        alias: "property"
      },
      literal: {
        pattern: /'(?:\w+\b\??:?)/,
        alias: "constant"
      },
      type: {
        pattern: /:(?:\w+\b\??:?)/,
        alias: "class-name"
      },
      color: /#\w+/,
      predicate: {
        pattern: /\b(?:all|and|any|ascii|attr|attribute|attributeLabel|binary|block|char|contains|database|date|dictionary|empty|equal|even|every|exists|false|floating|function|greater|greaterOrEqual|if|in|inline|integer|is|key|label|leap|less|lessOrEqual|literal|logical|lower|nand|negative|nor|not|notEqual|null|numeric|odd|or|path|pathLabel|positive|prefix|prime|regex|same|set|some|sorted|standalone|string|subset|suffix|superset|symbol|symbolLiteral|true|try|type|unless|upper|when|whitespace|word|xnor|xor|zero)\?/,
        alias: "keyword"
      },
      "builtin-function": {
        pattern: /\b(?:abs|acos|acosh|acsec|acsech|actan|actanh|add|after|alert|alias|and|angle|append|arg|args|arity|array|as|asec|asech|asin|asinh|atan|atan2|atanh|attr|attrs|average|before|benchmark|blend|break|call|capitalize|case|ceil|chop|clear|clip|close|color|combine|conj|continue|copy|cos|cosh|crc|csec|csech|ctan|ctanh|cursor|darken|dec|decode|define|delete|desaturate|deviation|dialog|dictionary|difference|digest|digits|div|do|download|drop|dup|e|else|empty|encode|ensure|env|escape|execute|exit|exp|extend|extract|factors|fdiv|filter|first|flatten|floor|fold|from|function|gamma|gcd|get|goto|hash|hypot|if|inc|indent|index|infinity|info|input|insert|inspect|intersection|invert|jaro|join|keys|kurtosis|last|let|levenshtein|lighten|list|ln|log|loop|lower|mail|map|match|max|median|min|mod|module|mul|nand|neg|new|nor|normalize|not|now|null|open|or|outdent|pad|palette|panic|path|pause|permissions|permutate|pi|pop|popup|pow|powerset|powmod|prefix|print|prints|process|product|query|random|range|read|relative|remove|rename|render|repeat|replace|request|return|reverse|round|sample|saturate|script|sec|sech|select|serve|set|shl|shr|shuffle|sin|sinh|size|skewness|slice|sort|spin|split|sqrt|squeeze|stack|strip|sub|suffix|sum|switch|symbols|symlink|sys|take|tan|tanh|terminal|terminate|to|truncate|try|type|unclip|union|unique|unless|until|unzip|upper|values|var|variance|volume|webview|while|with|wordwrap|write|xnor|xor|zip)\b/,
        alias: "keyword"
      },
      sugar: {
        pattern: /->|=>|\||::/,
        alias: "operator"
      },
      punctuation: /[()[\],]/,
      symbol: {
        pattern: /<:|-:||@|#|\+|\||\*|\$|---|-|%|\/|\.\.|\^|~|=|<|>|\\/
      },
      boolean: {
        pattern: /\b(?:false|maybe|true)\b/
      }
    }, t.languages.art = t.languages.arturo;
  })(e);
}
am.displayName = "asciidoc";
am.aliases = ["adoc"];
function am(e) {
  (function(t) {
    var a = {
      pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
      lookbehind: !0,
      inside: {
        quoted: {
          pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
          inside: {
            punctuation: /^[$`]|[$`]$/
          }
        },
        interpreted: {
          pattern: /'(?:[^'\\]|\\.)*'/,
          inside: {
            punctuation: /^'|'$/
            // See rest below
          }
        },
        string: /"(?:[^"\\]|\\.)*"/,
        variable: /\w+(?==)/,
        punctuation: /^\[|\]$|,/,
        operator: /=/,
        // The negative look-ahead prevents blank matches
        "attr-value": /(?!^\s+$).+/
      }
    }, i = t.languages.asciidoc = {
      "comment-block": {
        pattern: /^(\/{4,})$[\s\S]*?^\1/m,
        alias: "comment"
      },
      table: {
        pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
        inside: {
          specifiers: {
            pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
            alias: "attr-value"
          },
          punctuation: {
            pattern: /(^|[^\\])[|!]=*/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      "passthrough-block": {
        pattern: /^(\+{4,})$[\s\S]*?^\1$/m,
        inside: {
          punctuation: /^\++|\++$/
          // See rest below
        }
      },
      // Literal blocks and listing blocks
      "literal-block": {
        pattern: /^(-{4,}|\.{4,})$[\s\S]*?^\1$/m,
        inside: {
          punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
          // See rest below
        }
      },
      // Sidebar blocks, quote blocks, example blocks and open blocks
      "other-block": {
        pattern: /^(--|\*{4,}|_{4,}|={4,})$[\s\S]*?^\1$/m,
        inside: {
          punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
          // See rest below
        }
      },
      // list-punctuation and list-label must appear before indented-block
      "list-punctuation": {
        pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
        lookbehind: !0,
        alias: "punctuation"
      },
      "list-label": {
        pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
        lookbehind: !0,
        alias: "symbol"
      },
      "indented-block": {
        pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
        lookbehind: !0
      },
      comment: /^\/\/.*/m,
      title: {
        pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
        alias: "important",
        inside: {
          punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
          // See rest below
        }
      },
      "attribute-entry": {
        pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
        alias: "tag"
      },
      attributes: a,
      hr: {
        pattern: /^'{3,}$/m,
        alias: "punctuation"
      },
      "page-break": {
        pattern: /^<{3,}$/m,
        alias: "punctuation"
      },
      admonition: {
        pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
        alias: "keyword"
      },
      callout: [
        {
          pattern: /(^[ \t]*)<?\d*>/m,
          lookbehind: !0,
          alias: "symbol"
        },
        {
          pattern: /<\d+>/,
          alias: "symbol"
        }
      ],
      macro: {
        pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
        inside: {
          function: /^[a-z\d-]+(?=:)/,
          punctuation: /^::?/,
          attributes: {
            pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
            inside: a.inside
          }
        }
      },
      inline: {
        /*
        The initial look-behind prevents the highlighting of escaped quoted text.
        Quoted text can be multi-line but cannot span an empty line.
        All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
        First, we handle the constrained quotes.
        Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
        They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
        Then we handle the unconstrained quotes.
        Those do not have the restrictions of the constrained quotes.
        They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
        */
        pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
        lookbehind: !0,
        inside: {
          attributes: a,
          url: {
            pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
            inside: {
              punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
            }
          },
          "attribute-ref": {
            pattern: /^\{.+\}$/,
            inside: {
              variable: {
                pattern: /(^\{)[a-z\d,+_-]+/,
                lookbehind: !0
              },
              operator: /^[=?!#%@$]|!(?=[:}])/,
              punctuation: /^\{|\}$|::?/
            }
          },
          italic: {
            pattern: /^(['_])[\s\S]+\1$/,
            inside: {
              punctuation: /^(?:''?|__?)|(?:''?|__?)$/
            }
          },
          bold: {
            pattern: /^\*[\s\S]+\*$/,
            inside: {
              punctuation: /^\*\*?|\*\*?$/
            }
          },
          punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
        }
      },
      replacement: {
        pattern: /\((?:C|R|TM)\)/,
        alias: "builtin"
      },
      entity: /&#?[\da-z]{1,8};/i,
      "line-continuation": {
        pattern: /(^| )\+$/m,
        lookbehind: !0,
        alias: "punctuation"
      }
    };
    function o(l) {
      l = l.split(" ");
      for (var c = {}, d = 0, m = l.length; d < m; d++)
        c[l[d]] = i[l[d]];
      return c;
    }
    a.inside.interpreted.inside.rest = o(
      "macro inline replacement entity"
    ), i["passthrough-block"].inside.rest = o("macro"), i["literal-block"].inside.rest = o("callout"), i.table.inside.rest = o(
      "comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"
    ), i["other-block"].inside.rest = o(
      "table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"
    ), i.title.inside.rest = o(
      "macro inline replacement entity"
    ), t.hooks.add("wrap", function(l) {
      l.type === "entity" && (l.attributes.title = l.content.value.replace(/&amp;/, "&"));
    }), t.languages.adoc = t.languages.asciidoc;
  })(e);
}
Ci.displayName = "csharp";
Ci.aliases = ["cs", "dotnet"];
function Ci(e) {
  e.register(ze), (function(t) {
    function a(O, F) {
      return O.replace(/<<(\d+)>>/g, function(te, v) {
        return "(?:" + F[+v] + ")";
      });
    }
    function i(O, F, te) {
      return RegExp(a(O, F), "");
    }
    function o(O, F) {
      for (var te = 0; te < F; te++)
        O = O.replace(/<<self>>/g, function() {
          return "(?:" + O + ")";
        });
      return O.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var l = {
      // keywords which represent a return or variable type
      type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
      // keywords which are used to declare a type
      typeDeclaration: "class enum interface record struct",
      // contextual keywords
      // ("var" and "dynamic" are missing because they are used like types)
      contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
      // all other keywords
      other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    function c(O) {
      return "\\b(?:" + O.trim().replace(/ /g, "|") + ")\\b";
    }
    var d = c(
      l.typeDeclaration
    ), m = RegExp(
      c(
        l.type + " " + l.typeDeclaration + " " + l.contextual + " " + l.other
      )
    ), f = c(
      l.typeDeclaration + " " + l.contextual + " " + l.other
    ), b = c(
      l.type + " " + l.typeDeclaration + " " + l.other
    ), E = o(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), T = o(/\((?:[^()]|<<self>>)*\)/.source, 2), S = /@?\b[A-Za-z_]\w*\b/.source, _ = a(/<<0>>(?:\s*<<1>>)?/.source, [S, E]), k = a(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
      f,
      _
    ]), R = /\[\s*(?:,\s*)*\]/.source, C = a(
      /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
      [k, R]
    ), L = a(
      /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
      [E, T, R]
    ), x = a(/\(<<0>>+(?:,<<0>>+)+\)/.source, [L]), Y = a(
      /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
      [x, k, R]
    ), q = {
      keyword: m,
      punctuation: /[<>()?,.:[\]]/
    }, D = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, G = /"(?:\\.|[^\\"\r\n])*"/.source, K = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    t.languages.csharp = t.languages.extend("clike", {
      string: [
        {
          pattern: i(/(^|[^$\\])<<0>>/.source, [K]),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: i(/(^|[^@$\\])<<0>>/.source, [G]),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "class-name": [
        {
          // Using static
          // using static System.Math;
          pattern: i(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
            k
          ]),
          lookbehind: !0,
          inside: q
        },
        {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: i(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
            S,
            Y
          ]),
          lookbehind: !0,
          inside: q
        },
        {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: i(/(\busing\s+)<<0>>(?=\s*=)/.source, [S]),
          lookbehind: !0
        },
        {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: i(/(\b<<0>>\s+)<<1>>/.source, [
            d,
            _
          ]),
          lookbehind: !0,
          inside: q
        },
        {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: i(/(\bcatch\s*\(\s*)<<0>>/.source, [k]),
          lookbehind: !0,
          inside: q
        },
        {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: i(/(\bwhere\s+)<<0>>/.source, [S]),
          lookbehind: !0
        },
        {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: i(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
            C
          ]),
          lookbehind: !0,
          inside: q
        },
        {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: i(
            /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
            [Y, b, S]
          ),
          inside: q
        }
      ],
      keyword: m,
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
      number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      punctuation: /\?\.?|::|[{}[\];(),.:]/
    }), t.languages.insertBefore("csharp", "number", {
      range: {
        pattern: /\.\./,
        alias: "operator"
      }
    }), t.languages.insertBefore("csharp", "punctuation", {
      "named-parameter": {
        pattern: i(/([(,]\s*)<<0>>(?=\s*:)/.source, [S]),
        lookbehind: !0,
        alias: "punctuation"
      }
    }), t.languages.insertBefore("csharp", "class-name", {
      namespace: {
        // namespace Foo.Bar {}
        // using Foo.Bar;
        pattern: i(
          /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
          [S]
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      "type-expression": {
        // default(Foo), typeof(Foo<Bar>), sizeof(int)
        pattern: i(
          /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
          [T]
        ),
        lookbehind: !0,
        alias: "class-name",
        inside: q
      },
      "return-type": {
        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
        // int Foo => 0; int Foo { get; set } = 0;
        pattern: i(
          /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
          [Y, k]
        ),
        inside: q,
        alias: "class-name"
      },
      "constructor-invocation": {
        // new List<Foo<Bar[]>> { }
        pattern: i(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [Y]),
        lookbehind: !0,
        inside: q,
        alias: "class-name"
      },
      /*'explicit-implementation': {
      // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
      pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
      inside: classNameInside,
      alias: 'class-name'
      },*/
      "generic-method": {
        // foo<Bar>()
        pattern: i(/<<0>>\s*<<1>>(?=\s*\()/.source, [S, E]),
        inside: {
          function: i(/^<<0>>/.source, [S]),
          generic: {
            pattern: RegExp(E),
            alias: "class-name",
            inside: q
          }
        }
      },
      "type-list": {
        // The list of types inherited or of generic constraints
        // class Foo<F> : Bar, IList<FooBar>
        // where F : Bar, IList<int>
        pattern: i(
          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
          [
            d,
            _,
            S,
            Y,
            m.source,
            T,
            /\bnew\s*\(\s*\)/.source
          ]
        ),
        lookbehind: !0,
        inside: {
          "record-arguments": {
            pattern: i(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
              _,
              T
            ]),
            lookbehind: !0,
            greedy: !0,
            inside: t.languages.csharp
          },
          keyword: m,
          "class-name": {
            pattern: RegExp(Y),
            greedy: !0,
            inside: q
          },
          punctuation: /[,()]/
        }
      },
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          // highlight preprocessor directives as keywords
          directive: {
            pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    });
    var Q = G + "|" + D, U = a(
      /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
      [Q]
    ), ee = o(
      a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
        U
      ]),
      2
    ), ae = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, ue = a(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
      k,
      ee
    ]);
    t.languages.insertBefore("csharp", "class-name", {
      attribute: {
        // Attributes
        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
        pattern: i(
          /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
          [ae, ue]
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          target: {
            pattern: i(/^<<0>>(?=\s*:)/.source, [ae]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: i(/\(<<0>>*\)/.source, [ee]),
            inside: t.languages.csharp
          },
          "class-name": {
            pattern: RegExp(k),
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[:,]/
        }
      }
    });
    var de = /:[^}\r\n]+/.source, ce = o(
      a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
        U
      ]),
      2
    ), j = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
      ce,
      de
    ]), se = o(
      a(
        /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
        [Q]
      ),
      2
    ), Ee = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
      se,
      de
    ]);
    function Ne(O, F) {
      return {
        interpolation: {
          pattern: i(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [O]),
          lookbehind: !0,
          inside: {
            "format-string": {
              pattern: i(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                F,
                de
              ]),
              lookbehind: !0,
              inside: {
                punctuation: /^:/
              }
            },
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: t.languages.csharp
            }
          }
        },
        string: /[\s\S]+/
      };
    }
    t.languages.insertBefore("csharp", "string", {
      "interpolation-string": [
        {
          pattern: i(
            /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
            [j]
          ),
          lookbehind: !0,
          greedy: !0,
          inside: Ne(j, ce)
        },
        {
          pattern: i(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
            Ee
          ]),
          lookbehind: !0,
          greedy: !0,
          inside: Ne(Ee, se)
        }
      ],
      char: {
        pattern: RegExp(D),
        greedy: !0
      }
    }), t.languages.dotnet = t.languages.cs = t.languages.csharp;
  })(e);
}
rm.displayName = "aspnet";
rm.aliases = [];
function rm(e) {
  e.register(Ci), e.register(xt), e.languages.aspnet = e.languages.extend("markup", {
    "page-directive": {
      pattern: /<%\s*@.*%>/,
      alias: "tag",
      inside: {
        "page-directive": {
          pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
          alias: "tag"
        },
        rest: e.languages.markup.tag.inside
      }
    },
    directive: {
      pattern: /<%.*%>/,
      alias: "tag",
      inside: {
        directive: {
          pattern: /<%\s*?[$=%#:]{0,2}|%>/,
          alias: "tag"
        },
        rest: e.languages.csharp
      }
    }
  }), e.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, e.languages.insertBefore(
    "inside",
    "punctuation",
    {
      directive: e.languages.aspnet.directive
    },
    e.languages.aspnet.tag.inside["attr-value"]
  ), e.languages.insertBefore("aspnet", "comment", {
    "asp-comment": {
      pattern: /<%--[\s\S]*?--%>/,
      alias: ["asp", "comment"]
    }
  }), e.languages.insertBefore(
    "aspnet",
    e.languages.javascript ? "script" : "tag",
    {
      "asp-script": {
        pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
        lookbehind: !0,
        alias: ["asp", "script"],
        inside: e.languages.csharp || {}
      }
    }
  );
}
im.displayName = "asm6502";
im.aliases = [];
function im(e) {
  e.languages.asm6502 = {
    comment: /;.*/,
    directive: {
      pattern: /\.\w+(?= )/,
      alias: "property"
    },
    string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    "op-code": {
      pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
      alias: "keyword"
    },
    "hex-number": {
      pattern: /#?\$[\da-f]{1,4}\b/i,
      alias: "number"
    },
    "binary-number": {
      pattern: /#?%[01]+\b/,
      alias: "number"
    },
    "decimal-number": {
      pattern: /#?\b\d+\b/,
      alias: "number"
    },
    register: {
      pattern: /\b[xya]\b/i,
      alias: "variable"
    },
    punctuation: /[(),:]/
  };
}
sm.displayName = "asmatmel";
sm.aliases = [];
function sm(e) {
  e.languages.asmatmel = {
    comment: {
      pattern: /;.*/,
      greedy: !0
    },
    string: {
      pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
    directive: {
      pattern: /\.\w+(?= )/,
      alias: "property"
    },
    "r-register": {
      pattern: /\br(?:\d|[12]\d|3[01])\b/,
      alias: "variable"
    },
    "op-code": {
      pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
      alias: "keyword"
    },
    "hex-number": {
      pattern: /#?\$[\da-f]{2,4}\b/i,
      alias: "number"
    },
    "binary-number": {
      pattern: /#?%[01]+\b/,
      alias: "number"
    },
    "decimal-number": {
      pattern: /#?\b\d+\b/,
      alias: "number"
    },
    register: {
      pattern: /\b[acznvshtixy]\b/i,
      alias: "variable"
    },
    operator: />>=?|<<=?|&[&=]?|\|[\|=]?|[-+*/%^!=<>?]=?/,
    punctuation: /[(),:]/
  };
}
om.displayName = "autohotkey";
om.aliases = [];
function om(e) {
  e.languages.autohotkey = {
    comment: [
      {
        pattern: /(^|\s);.*/,
        lookbehind: !0
      },
      {
        pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
        lookbehind: !0,
        greedy: !0
      }
    ],
    tag: {
      // labels
      pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
      lookbehind: !0
    },
    string: /"(?:[^"\n\r]|"")*"/,
    variable: /%\w+%/,
    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
    operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
    boolean: /\b(?:false|true)\b/,
    command: {
      pattern: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
      alias: "selector"
    },
    constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
    builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
    symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
    directive: {
      pattern: /#[a-z]+\b/i,
      alias: "important"
    },
    keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
    function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
    punctuation: /[{}[\]():,]/
  };
}
lm.displayName = "autoit";
lm.aliases = [];
function lm(e) {
  e.languages.autoit = {
    comment: [
      /;.*/,
      {
        // The multi-line comments delimiters can actually be commented out with ";"
        pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
        lookbehind: !0
      }
    ],
    url: {
      pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
      lookbehind: !0
    },
    string: {
      pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
      greedy: !0,
      inside: {
        variable: /([%$@])\w+\1/
      }
    },
    directive: {
      pattern: /(^[\t ]*)#[\w-]+/m,
      lookbehind: !0,
      alias: "keyword"
    },
    function: /\b\w+(?=\()/,
    // Variables and macros
    variable: /[$@]\w+/,
    keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
    boolean: /\b(?:False|True)\b/i,
    operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
    punctuation: /[\[\]().,:]/
  };
}
um.displayName = "avisynth";
um.aliases = ["avs"];
function um(e) {
  (function(t) {
    function a(f, b) {
      return f.replace(/<<(\d+)>>/g, function(E, T) {
        return b[+T];
      });
    }
    function i(f, b, E) {
      return RegExp(a(f, b), E);
    }
    var o = /bool|clip|float|int|string|val/.source, l = [
      // bools
      /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
      // control
      /apply|assert|default|eval|import|nop|select|undefined/.source,
      // global
      /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
      // conv
      /hex(?:value)?|value/.source,
      // numeric
      /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
      // trig
      /a?sinh?|a?cosh?|a?tan[2h]?/.source,
      // bit
      /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
      // runtime
      /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
      // script
      /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
      // string
      /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
      // version
      /isversionorgreater|version(?:number|string)/.source,
      // helper
      /buildpixeltype|colorspacenametopixeltype/.source,
      // avsplus
      /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
    ].join("|"), c = [
      // content
      /has(?:audio|video)/.source,
      // resolution
      /height|width/.source,
      // framerate
      /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
      // interlacing
      /getparity|is(?:field|frame)based/.source,
      // color format
      /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
      // audio
      /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
    ].join("|"), d = [
      // source
      /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
      // color
      /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
      // overlay
      /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
      // geometry
      /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
      // pixel
      /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
      // timeline
      /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
      // interlace
      /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
      // audio
      /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
      // conditional
      /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
      // export
      /imagewriter/.source,
      // debug
      /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
    ].join("|"), m = [l, c, d].join("|");
    t.languages.avisynth = {
      comment: [
        {
          // Matches [* *] nestable block comments, but only supports 1 level of nested comments
          // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
          pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // Matches /* */ block comments
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // Matches # comments
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // Handle before strings because optional arguments are surrounded by double quotes
      argument: {
        pattern: i(/\b(?:<<0>>)\s+("?)\w+\1/.source, [o], "i"),
        inside: {
          keyword: /^\w+/
        }
      },
      // Optional argument assignment
      "argument-label": {
        pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
        lookbehind: !0,
        inside: {
          "argument-name": {
            pattern: /^\w+/,
            alias: "punctuation"
          },
          punctuation: /=$/
        }
      },
      string: [
        {
          // triple double-quoted
          pattern: /"""[\s\S]*?"""/,
          greedy: !0
        },
        {
          // single double-quoted
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: !0,
          inside: {
            constant: {
              // These *are* case-sensitive!
              pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
            }
          }
        }
      ],
      // The special "last" variable that takes the value of the last implicitly returned clip
      variable: /\b(?:last)\b/i,
      boolean: /\b(?:false|no|true|yes)\b/i,
      keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
      constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
      // AviSynth's internal functions, filters, and properties
      "builtin-function": {
        pattern: i(/\b(?:<<0>>)\b/.source, [m], "i"),
        alias: "function"
      },
      "type-cast": {
        pattern: i(/\b(?:<<0>>)(?=\s*\()/.source, [o], "i"),
        alias: "keyword"
      },
      // External/user-defined filters
      function: {
        pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
        lookbehind: !0
      },
      // Matches a \ as the first or last character on a line
      "line-continuation": {
        pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
        lookbehind: !0,
        alias: "punctuation"
      },
      number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
      operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
      punctuation: /[{}\[\]();,.]/
    }, t.languages.avs = t.languages.avisynth;
  })(e);
}
cm.displayName = "avro-idl";
cm.aliases = ["avdl"];
function cm(e) {
  e.languages["avro-idl"] = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
      lookbehind: !0,
      greedy: !0
    },
    annotation: {
      pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
      greedy: !0,
      alias: "function"
    },
    "function-identifier": {
      pattern: /`[^\r\n`]+`(?=\s*\()/,
      greedy: !0,
      alias: "function"
    },
    identifier: {
      pattern: /`[^\r\n`]+`/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: [
      {
        pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
        lookbehind: !0
      },
      /-?\b(?:Infinity|NaN)\b/
    ],
    operator: /=/,
    punctuation: /[()\[\]{}<>.:,;-]/
  }, e.languages.avdl = e.languages["avro-idl"];
}
dm.displayName = "awk";
dm.aliases = ["gawk"];
function dm(e) {
  e.languages.awk = {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])"(?:[^\\"\r\n]|\\.)*"/,
      lookbehind: !0,
      greedy: !0
    },
    regex: {
      pattern: /((?:^|[^\w\s)])\s*)\/(?:[^\/\\\r\n]|\\.)*\//,
      lookbehind: !0,
      greedy: !0
    },
    variable: /\$\w+/,
    keyword: /\b(?:BEGIN|BEGINFILE|END|ENDFILE|break|case|continue|default|delete|do|else|exit|for|function|getline|if|in|next|nextfile|printf?|return|switch|while)\b|@(?:include|load)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[a-fA-F0-9]+)\b/,
    operator: /--|\+\+|!?~|>&|>>|<<|(?:\*\*|[<>!=+\-*/%^])=?|&&|\|[|&]|[?:]/,
    punctuation: /[()[\]{},;]/
  }, e.languages.gawk = e.languages.awk;
}
Nu.displayName = "basic";
Nu.aliases = [];
function Nu(e) {
  e.languages.basic = {
    comment: {
      pattern: /(?:!|REM\b).+/i,
      inside: {
        keyword: /^REM/i
      }
    },
    string: {
      pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
      greedy: !0
    },
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
    function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
    operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
    punctuation: /[,;:()]/
  };
}
pm.displayName = "batch";
pm.aliases = [];
function pm(e) {
  (function(t) {
    var a = /%%?[~:\w]+%?|!\S+!/, i = {
      pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
      alias: "attr-name",
      inside: {
        punctuation: /:/
      }
    }, o = /"(?:[\\"]"|[^"])*"(?!")/, l = /(?:\b|-)\d+\b/;
    t.languages.batch = {
      comment: [
        /^::.*/m,
        {
          pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: !0
        }
      ],
      label: {
        pattern: /^:.*/m,
        alias: "property"
      },
      command: [
        {
          // FOR command
          pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
          lookbehind: !0,
          inside: {
            keyword: /\b(?:do|in)\b|^for\b/i,
            string: o,
            parameter: i,
            variable: a,
            number: l,
            punctuation: /[()',]/
          }
        },
        {
          // IF command
          pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
          lookbehind: !0,
          inside: {
            keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
            string: o,
            parameter: i,
            variable: a,
            number: l,
            operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
          }
        },
        {
          // ELSE command
          pattern: /((?:^|[&()])[ \t]*)else\b/im,
          lookbehind: !0,
          inside: {
            keyword: /^else\b/i
          }
        },
        {
          // SET command
          pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: !0,
          inside: {
            keyword: /^set\b/i,
            string: o,
            parameter: i,
            variable: [a, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
            number: l,
            operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
            punctuation: /[()',]/
          }
        },
        {
          // Other commands
          pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
          lookbehind: !0,
          inside: {
            keyword: /^\w+\b/,
            string: o,
            parameter: i,
            label: {
              pattern: /(^\s*):\S+/m,
              lookbehind: !0,
              alias: "property"
            },
            variable: a,
            number: l,
            operator: /\^/
          }
        }
      ],
      operator: /[&@]/,
      punctuation: /[()']/
    };
  })(e);
}
fm.displayName = "bbcode";
fm.aliases = ["shortcode"];
function fm(e) {
  e.languages.bbcode = {
    tag: {
      pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
      inside: {
        tag: {
          pattern: /^\[\/?[^\s=\]]+/,
          inside: {
            punctuation: /^\[\/?/
          }
        },
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
          inside: {
            punctuation: [
              /^=/,
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\]/,
        "attr-name": /[^\s=\]]+/
      }
    }
  }, e.languages.shortcode = e.languages.bbcode;
}
mm.displayName = "bbj";
mm.aliases = [];
function mm(e) {
  (function(t) {
    t.languages.bbj = {
      comment: {
        pattern: /(^|[^\\:])rem\s+.*/i,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(['"])(?:(?!\1|\\).|\\.)*\1/,
        greedy: !0
      },
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:abstract|all|argc|begin|bye|callback|case|chn|class|classend|ctl|day|declare|delete|dim|dom|dread|dsz|else|end|endif|err|exitto|extends|fi|field|for|from|gosub|goto|if|implements|interface|interfaceend|iol|iolist|let|list|load|method|methodend|methodret|on|opts|pfx|print|private|process_events|protected|psz|public|read|read_resource|release|remove_callback|repeat|restore|return|rev|seterr|setesc|sqlchn|sqlunt|ssn|start|static|swend|switch|sys|then|tim|unt|until|use|void|wend|where|while)\b/i,
      function: /\b\w+(?=\()/,
      boolean: /\b(?:BBjAPI\.TRUE|BBjAPI\.FALSE)\b/i,
      operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:and|not|or|xor)\b/i,
      punctuation: /[.,;:()]/
    };
  })(e);
}
gm.displayName = "bicep";
gm.aliases = [];
function gm(e) {
  e.languages.bicep = {
    comment: [
      {
        // multiline comments eg /* ASDF */
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        // singleline comments eg // ASDF
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    property: [
      {
        pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
        lookbehind: !0
      },
      {
        pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: [
      {
        pattern: /'''[^'][\s\S]*?'''/,
        greedy: !0
      },
      {
        pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    "interpolated-string": {
      pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$\{[^{}\r\n]*\}/,
          inside: {
            expression: {
              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
              lookbehind: !0
            },
            punctuation: /^\$\{|\}$/
          }
        },
        string: /[\s\S]+/
      }
    },
    datatype: {
      pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
      lookbehind: !0,
      alias: "class-name"
    },
    boolean: /\b(?:false|true)\b/,
    // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
    keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
    decorator: /@\w+\b/,
    function: /\b[a-z_]\w*(?=[ \t]*\()/i,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
    punctuation: /[{}[\];(),.:]/
  }, e.languages.bicep["interpolated-string"].inside.interpolation.inside.expression.inside = e.languages.bicep;
}
hm.displayName = "birb";
hm.aliases = [];
function hm(e) {
  e.register(ze), e.languages.birb = e.languages.extend("clike", {
    string: {
      pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
      greedy: !0
    },
    "class-name": [
      /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
      // matches variable and function return types (parameters as well).
      /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
    ],
    keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
    operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
    variable: /\b[a-z_]\w*\b/
  }), e.languages.insertBefore("birb", "function", {
    metadata: {
      pattern: /<\w+>/,
      greedy: !0,
      alias: "symbol"
    }
  });
}
bm.displayName = "bison";
bm.aliases = [];
function bm(e) {
  e.register(jn), e.languages.bison = e.languages.extend("c", {}), e.languages.insertBefore("bison", "comment", {
    bison: {
      // This should match all the beginning of the file
      // including the prologue(s), the bison declarations and
      // the grammar rules.
      pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
      inside: {
        c: {
          // Allow for one level of nested braces
          pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
          inside: {
            delimiter: {
              pattern: /^%?\{|%?\}$/,
              alias: "punctuation"
            },
            "bison-variable": {
              pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
              alias: "variable",
              inside: {
                punctuation: /<|>/
              }
            },
            rest: e.languages.c
          }
        },
        comment: e.languages.c.comment,
        string: e.languages.c.string,
        property: /\S+(?=:)/,
        keyword: /%\w+/,
        number: {
          pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
          lookbehind: !0
        },
        punctuation: /%[%?]|[|:;\[\]<>]/
      }
    }
  });
}
Em.displayName = "bnf";
Em.aliases = ["rbnf"];
function Em(e) {
  e.languages.bnf = {
    string: {
      pattern: /"[^\r\n"]*"|'[^\r\n']*'/
    },
    definition: {
      pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
      alias: ["rule", "keyword"],
      inside: {
        punctuation: /^<|>$/
      }
    },
    rule: {
      pattern: /<[^<>\r\n\t]+>/,
      inside: {
        punctuation: /^<|>$/
      }
    },
    operator: /::=|[|()[\]{}*+?]|\.{3}/
  }, e.languages.rbnf = e.languages.bnf;
}
ym.displayName = "bqn";
ym.aliases = [];
function ym(e) {
  e.languages.bqn = {
    shebang: {
      pattern: /^#![ \t]*\/.*/,
      alias: "important",
      greedy: !0
    },
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    "string-literal": {
      pattern: /"(?:[^"]|"")*"/,
      greedy: !0,
      alias: "string"
    },
    "character-literal": {
      pattern: /'(?:[\s\S]|[\uD800-\uDBFF][\uDC00-\uDFFF])'/,
      greedy: !0,
      alias: "char"
    },
    function: /[\w.]+[\w.]*/,
    "dot-notation-on-brackets": {
      pattern: /\{(?=.*\}\.)|\}\./,
      alias: "namespace"
    },
    "special-name": {
      pattern: /(?:|||||||||||__|_)/,
      alias: "keyword"
    },
    "dot-notation-on-name": {
      pattern: /[A-Za-z_][\w]*\./,
      alias: "namespace"
    },
    "word-number-scientific": {
      pattern: /\d+(?:\.\d+)?[eE]?\d+/,
      alias: "number"
    },
    "word-name": {
      pattern: /[A-Za-z_][\w]*/,
      alias: "symbol"
    },
    "word-number": {
      pattern: /[]?(?:\d*\.?\b\d+(?:e[+]?\d+|E[+]?\d+)?|||)(?:j?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+]?\d+|E[+]?\d+)?|||))?/,
      alias: "number"
    },
    "null-literal": {
      pattern: /@/,
      alias: "char"
    },
    "primitive-functions": {
      pattern: /[-+|<>=/!]/,
      alias: "operator"
    },
    "primitive-1-operators": {
      pattern: /[`]/,
      alias: "operator"
    },
    "primitive-2-operators": {
      pattern: /[]/,
      alias: "operator"
    },
    punctuation: /[(){}[\],.;:?]/
  };
}
Tm.displayName = "brainfuck";
Tm.aliases = [];
function Tm(e) {
  e.languages.brainfuck = {
    pointer: {
      pattern: /<|>/,
      alias: "keyword"
    },
    increment: {
      pattern: /\+/,
      alias: "inserted"
    },
    decrement: {
      pattern: /-/,
      alias: "deleted"
    },
    branching: {
      pattern: /\[|\]/,
      alias: "important"
    },
    operator: /[.,]/,
    comment: /\S+/
  };
}
Sm.displayName = "brightscript";
Sm.aliases = [];
function Sm(e) {
  e.languages.brightscript = {
    comment: /(?:\brem|').*/i,
    "directive-statement": {
      pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
      lookbehind: !0,
      alias: "property",
      inside: {
        "error-message": {
          pattern: /(^#error).+/,
          lookbehind: !0
        },
        directive: {
          pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
          alias: "keyword"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: null
          // see below
        }
      }
    },
    property: {
      pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\r\n]|"")*"(?!")/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\bAs[\t ]+)\w+/i,
      lookbehind: !0
    },
    keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
    boolean: /\b(?:false|true)\b/i,
    function: /\b(?!\d)\w+(?=[\t ]*\()/,
    number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
    operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
    punctuation: /[.,;()[\]{}]/,
    constant: /\b(?:LINE_NUM)\b/i
  }, e.languages.brightscript["directive-statement"].inside.expression.inside = e.languages.brightscript;
}
_m.displayName = "bro";
_m.aliases = [];
function _m(e) {
  e.languages.bro = {
    comment: {
      pattern: /(^|[^\\$])#.*/,
      lookbehind: !0,
      inside: {
        italic: /\b(?:FIXME|TODO|XXX)\b/
      }
    },
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    boolean: /\b[TF]\b/,
    function: {
      pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
      lookbehind: !0
    },
    builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
    constant: {
      pattern: /(\bconst[ \t]+)\w+/i,
      lookbehind: !0
    },
    keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    punctuation: /[{}[\];(),.:]/
  };
}
Am.displayName = "bsl";
Am.aliases = ["oscript"];
function Am(e) {
  e.languages.bsl = {
    comment: /\/\/.*/,
    string: [
      // 
      // Strings
      {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      //   
      // Date & time
      {
        pattern: /'(?:[^'\r\n\\]|\\.)*'/
      }
    ],
    keyword: [
      {
        // RU
        pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:|||||||||||||||||||||||||||||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
        lookbehind: !0
      },
      {
        // EN
        pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
      }
    ],
    number: {
      pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
      lookbehind: !0
    },
    operator: [
      /[<>+\-*/]=?|[%=]/,
      // RU
      {
        pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
        lookbehind: !0
      },
      // EN
      {
        pattern: /\b(?:and|not|or)\b/i
      }
    ],
    punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
    directive: [
      //    &, &, ...
      // Preprocessor tags of the type &Client, &Server, ...
      {
        pattern: /^([ \t]*)&.*/m,
        lookbehind: !0,
        greedy: !0,
        alias: "important"
      },
      //   :
      // #  
      // ...
      // #
      // Preprocessor instructions of the form:
      // #If Server Then
      // ...
      // #EndIf
      {
        pattern: /^([ \t]*)#.*/gm,
        lookbehind: !0,
        greedy: !0,
        alias: "important"
      }
    ]
  }, e.languages.oscript = e.languages.bsl;
}
Nm.displayName = "cfscript";
Nm.aliases = ["cfc"];
function Nm(e) {
  e.register(ze), e.languages.cfscript = e.languages.extend("clike", {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        inside: {
          annotation: {
            pattern: /(?:^|[^.])@[\w\.]+/,
            alias: "punctuation"
          }
        }
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
    operator: [
      /\+\+|--|&&|\|\||::|=>|[!=]==|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|:/,
      /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
    ],
    scope: {
      pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
      alias: "global"
    },
    type: {
      pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
      alias: "builtin"
    }
  }), e.languages.insertBefore("cfscript", "keyword", {
    // This must be declared before keyword because we use "function" inside the lookahead
    "function-variable": {
      pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    }
  }), delete e.languages.cfscript["class-name"], e.languages.cfc = e.languages.cfscript;
}
Rm.displayName = "chaiscript";
Rm.aliases = [];
function Rm(e) {
  e.register(ze), e.register(vi), e.languages.chaiscript = e.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
      lookbehind: !0,
      greedy: !0
    },
    "class-name": [
      {
        // e.g. class Rectangle { ... }
        pattern: /(\bclass\s+)\w+/,
        lookbehind: !0
      },
      {
        // e.g. attr Rectangle::height, def Rectangle::area() { ... }
        pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
        lookbehind: !0
      }
    ],
    keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
    number: [e.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
    operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
  }), e.languages.insertBefore("chaiscript", "operator", {
    "parameter-type": {
      // e.g. def foo(int x, Vector y) {...}
      pattern: /([,(]\s*)\w+(?=\s+\w)/,
      lookbehind: !0,
      alias: "class-name"
    }
  }), e.languages.insertBefore("chaiscript", "string", {
    "string-interpolation": {
      pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
          lookbehind: !0,
          inside: {
            "interpolation-expression": {
              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
              lookbehind: !0,
              inside: e.languages.chaiscript
            },
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  });
}
vm.displayName = "cil";
vm.aliases = [];
function vm(e) {
  e.languages.cil = {
    comment: /\/\/.*/,
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    directive: {
      pattern: /(^|\W)\.[a-z]+(?=\s)/,
      lookbehind: !0,
      alias: "class-name"
    },
    // Actually an assembly reference
    variable: /\[[\w\.]+\]/,
    keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
    function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
    punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
  };
}
Cm.displayName = "cilkc";
Cm.aliases = ["cilk-c"];
function Cm(e) {
  e.register(jn), e.languages.cilkc = e.languages.insertBefore("c", "function", {
    "parallel-keyword": {
      pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
      alias: "keyword"
    }
  }), e.languages["cilk-c"] = e.languages.cilkc;
}
wm.displayName = "cilkcpp";
wm.aliases = ["cilk", "cilk-cpp"];
function wm(e) {
  e.register(vi), e.languages.cilkcpp = e.languages.insertBefore("cpp", "function", {
    "parallel-keyword": {
      pattern: /\bcilk_(?:for|reducer|s(?:cope|pawn|ync))\b/,
      alias: "keyword"
    }
  }), e.languages["cilk-cpp"] = e.languages.cilkcpp, e.languages.cilk = e.languages.cilkcpp;
}
km.displayName = "clojure";
km.aliases = [];
function km(e) {
  e.languages.clojure = {
    comment: {
      pattern: /;.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\\]|\\.)*"/,
      greedy: !0
    },
    char: /\\\w+/,
    symbol: {
      pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
      lookbehind: !0
    },
    keyword: {
      pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
      lookbehind: !0
    },
    boolean: /\b(?:false|nil|true)\b/,
    number: {
      pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
      lookbehind: !0
    },
    function: {
      pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
      lookbehind: !0
    },
    operator: /[#@^`~]/,
    punctuation: /[{}\[\](),]/
  };
}
Im.displayName = "cmake";
Im.aliases = [];
function Im(e) {
  e.languages.cmake = {
    comment: /#.*/,
    string: {
      pattern: /"(?:[^\\"]|\\.)*"/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
          inside: {
            punctuation: /\$\{|\}/,
            variable: /\w+/
          }
        }
      }
    },
    variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
    property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
    keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
    boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
    namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
    operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
    inserted: {
      pattern: /\b\w+::\w+\b/,
      alias: "class-name"
    },
    number: /\b\d+(?:\.\d+)*\b/,
    function: /\b[a-z_]\w*(?=\s*\()\b/i,
    punctuation: /[()>}]|\$[<{]/
  };
}
Om.displayName = "cobol";
Om.aliases = [];
function Om(e) {
  e.languages.cobol = {
    comment: {
      pattern: /\*>.*|(^[ \t]*)\*.*/m,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
      greedy: !0
    },
    level: {
      pattern: /(^[ \t]*)\d+\b/m,
      lookbehind: !0,
      greedy: !0,
      alias: "number"
    },
    "class-name": {
      // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
      pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
      lookbehind: !0,
      inside: {
        number: {
          pattern: /(\()\d+/,
          lookbehind: !0
        },
        punctuation: /[()]/
      }
    },
    keyword: {
      pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
      lookbehind: !0
    },
    boolean: {
      pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
      lookbehind: !0
    },
    number: {
      pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
      lookbehind: !0
    },
    operator: [
      /<>|[<>]=?|[=+*/&]/,
      {
        pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
        lookbehind: !0
      }
    ],
    punctuation: /[.:,()]/
  };
}
xm.displayName = "coffeescript";
xm.aliases = ["coffee"];
function xm(e) {
  e.register(Bt), (function(t) {
    var a = /#(?!\{).+/, i = {
      pattern: /#\{[^}]+\}/,
      alias: "variable"
    };
    t.languages.coffeescript = t.languages.extend("javascript", {
      comment: a,
      string: [
        // Strings are multiline
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          greedy: !0
        },
        {
          // Strings are multiline
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          greedy: !0,
          inside: {
            interpolation: i
          }
        }
      ],
      keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
      "class-member": {
        pattern: /@(?!\d)\w+/,
        alias: "variable"
      }
    }), t.languages.insertBefore("coffeescript", "comment", {
      "multiline-comment": {
        pattern: /###[\s\S]+?###/,
        alias: "comment"
      },
      // Block regexp can contain comments and interpolation
      "block-regex": {
        pattern: /\/{3}[\s\S]*?\/{3}/,
        alias: "regex",
        inside: {
          comment: a,
          interpolation: i
        }
      }
    }), t.languages.insertBefore("coffeescript", "string", {
      "inline-javascript": {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          },
          script: {
            pattern: /[\s\S]+/,
            alias: "language-javascript",
            inside: t.languages.javascript
          }
        }
      },
      // Block strings
      "multiline-string": [
        {
          pattern: /'''[\s\S]*?'''/,
          greedy: !0,
          alias: "string"
        },
        {
          pattern: /"""[\s\S]*?"""/,
          greedy: !0,
          alias: "string",
          inside: {
            interpolation: i
          }
        }
      ]
    }), t.languages.insertBefore("coffeescript", "keyword", {
      // Object property
      property: /(?!\d)\w+(?=\s*:(?!:))/
    }), delete t.languages.coffeescript["template-string"], t.languages.coffee = t.languages.coffeescript;
  })(e);
}
Lm.displayName = "concurnas";
Lm.aliases = ["conc"];
function Lm(e) {
  e.languages.concurnas = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
      lookbehind: !0,
      greedy: !0
    },
    langext: {
      pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
      greedy: !0,
      inside: {
        "class-name": /^\w+/,
        string: {
          pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
          lookbehind: !0
        },
        punctuation: /\|\|/
      }
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
      lookbehind: !0
    },
    keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
    punctuation: /[{}[\];(),.:]/,
    operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
    annotation: {
      pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
      alias: "builtin"
    }
  }, e.languages.insertBefore("concurnas", "langext", {
    "regex-literal": {
      pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: e.languages.concurnas
        },
        regex: /[\s\S]+/
      }
    },
    "string-literal": {
      pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: e.languages.concurnas
        },
        string: /[\s\S]+/
      }
    }
  }), e.languages.conc = e.languages.concurnas;
}
Dm.displayName = "csp";
Dm.aliases = [];
function Dm(e) {
  (function(t) {
    function a(i) {
      return RegExp(
        /([ \t])/.source + "(?:" + i + ")" + /(?=[\s;]|$)/.source,
        "i"
      );
    }
    t.languages.csp = {
      directive: {
        pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
        lookbehind: !0,
        alias: "property"
      },
      scheme: {
        pattern: a(/[a-z][a-z0-9.+-]*:/.source),
        lookbehind: !0
      },
      none: {
        pattern: a(/'none'/.source),
        lookbehind: !0,
        alias: "keyword"
      },
      nonce: {
        pattern: a(/'nonce-[-+/\w=]+'/.source),
        lookbehind: !0,
        alias: "number"
      },
      hash: {
        pattern: a(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
        lookbehind: !0,
        alias: "number"
      },
      host: {
        pattern: a(
          /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
        ),
        lookbehind: !0,
        alias: "url",
        inside: {
          important: /\*/
        }
      },
      keyword: [
        {
          pattern: a(/'unsafe-[a-z-]+'/.source),
          lookbehind: !0,
          alias: "unsafe"
        },
        {
          pattern: a(/'[a-z-]+'/.source),
          lookbehind: !0,
          alias: "safe"
        }
      ],
      punctuation: /;/
    };
  })(e);
}
Mm.displayName = "cooklang";
Mm.aliases = [];
function Mm(e) {
  (function(t) {
    var a = /(?:(?!\s)[\d$+<=a-zA-Z\x80-\uFFFF])+/.source, i = /[^{}@#]+/.source, o = /\{[^}#@]*\}/.source, l = i + o, c = /(?:h|hours|hrs|m|min|minutes)/.source, d = {
      pattern: /\{[^{}]*\}/,
      inside: {
        amount: {
          pattern: /([\{|])[^{}|*%]+/,
          lookbehind: !0,
          alias: "number"
        },
        unit: {
          pattern: /(%)[^}]+/,
          lookbehind: !0,
          alias: "symbol"
        },
        "servings-scaler": {
          pattern: /\*/,
          alias: "operator"
        },
        "servings-alternative-separator": {
          pattern: /\|/,
          alias: "operator"
        },
        "unit-separator": {
          pattern: /(?:%|(\*)%)/,
          lookbehind: !0,
          alias: "operator"
        },
        punctuation: /[{}]/
      }
    };
    t.languages.cooklang = {
      comment: {
        // [- comment -]
        // -- comment
        pattern: /\[-[\s\S]*?-\]|--.*/,
        greedy: !0
      },
      meta: {
        // >> key: value
        pattern: />>.*:.*/,
        inside: {
          property: {
            // key:
            pattern: /(>>\s*)[^\s:](?:[^:]*[^\s:])?/,
            lookbehind: !0
          }
        }
      },
      "cookware-group": {
        // #...{...}, #...
        pattern: new RegExp(
          "#(?:" + l + "|" + a + ")"
        ),
        inside: {
          cookware: {
            pattern: new RegExp("(^#)(?:" + i + ")"),
            lookbehind: !0,
            alias: "variable"
          },
          "cookware-keyword": {
            pattern: /^#/,
            alias: "keyword"
          },
          "quantity-group": {
            pattern: new RegExp(/\{[^{}@#]*\}/),
            inside: {
              quantity: {
                pattern: new RegExp(/(^\{)/.source + i),
                lookbehind: !0,
                alias: "number"
              },
              punctuation: /[{}]/
            }
          }
        }
      },
      "ingredient-group": {
        // @...{...}, @...
        pattern: new RegExp(
          "@(?:" + l + "|" + a + ")"
        ),
        inside: {
          ingredient: {
            pattern: new RegExp("(^@)(?:" + i + ")"),
            lookbehind: !0,
            alias: "variable"
          },
          "ingredient-keyword": {
            pattern: /^@/,
            alias: "keyword"
          },
          "amount-group": d
        }
      },
      "timer-group": {
        // ~timer{...}
        // eslint-disable-next-line regexp/sort-alternatives
        pattern: /~(?!\s)[^@#~{}]*\{[^{}]*\}/,
        inside: {
          timer: {
            pattern: /(^~)[^{]+/,
            lookbehind: !0,
            alias: "variable"
          },
          "duration-group": {
            // {...}
            pattern: /\{[^{}]*\}/,
            inside: {
              punctuation: /[{}]/,
              unit: {
                pattern: new RegExp(
                  /(%\s*)/.source + c + /\b/.source
                ),
                lookbehind: !0,
                alias: "symbol"
              },
              operator: /%/,
              duration: {
                pattern: /\d+/,
                alias: "number"
              }
            }
          },
          "timer-keyword": {
            pattern: /^~/,
            alias: "keyword"
          }
        }
      }
    };
  })(e);
}
Um.displayName = "coq";
Um.aliases = [];
function Um(e) {
  (function(t) {
    for (var a = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source, i = 0; i < 2; i++)
      a = a.replace(/<self>/g, function() {
        return a;
      });
    a = a.replace(/<self>/g, "[]"), t.languages.coq = {
      comment: RegExp(a),
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      attribute: [
        {
          pattern: RegExp(
            /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
              /<comment>/g,
              function() {
                return a;
              }
            )
          ),
          greedy: !0,
          alias: "attr-name",
          inside: {
            comment: RegExp(a),
            string: {
              pattern: /"(?:[^"]|"")*"(?!")/,
              greedy: !0
            },
            operator: /=/,
            punctuation: /^#\[|\]$|[,()]/
          }
        },
        {
          pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
          alias: "attr-name"
        }
      ],
      keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
      number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
      punct: {
        pattern: /@\{|\{\||\[=|:>/,
        alias: "punctuation"
      },
      operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
      punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
    };
  })(e);
}
wi.displayName = "ruby";
wi.aliases = ["rb"];
function wi(e) {
  e.register(ze), (function(t) {
    t.languages.ruby = t.languages.extend("clike", {
      comment: {
        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
      operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
      punctuation: /[(){}[\].,;]/
    }), t.languages.insertBefore("ruby", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    });
    var a = {
      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
      lookbehind: !0,
      inside: {
        content: {
          pattern: /^(#\{)[\s\S]+(?=\}$)/,
          lookbehind: !0,
          inside: t.languages.ruby
        },
        delimiter: {
          pattern: /^#\{|\}$/,
          alias: "punctuation"
        }
      }
    };
    delete t.languages.ruby.function;
    var i = "(?:" + [
      /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
      /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
      /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
      /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
      /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")", o = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    t.languages.insertBefore("ruby", "keyword", {
      "regex-literal": [
        {
          pattern: RegExp(
            /%r/.source + i + /[egimnosux]{0,6}/.source
          ),
          greedy: !0,
          inside: {
            interpolation: a,
            regex: /[\s\S]+/
          }
        },
        {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: a,
            regex: /[\s\S]+/
          }
        }
      ],
      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
      symbol: [
        {
          pattern: RegExp(/(^|[^:]):/.source + o),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: RegExp(
            /([\r\n{(,][ \t]*)/.source + o + /(?=:(?!:))/.source
          ),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "method-definition": {
        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
        lookbehind: !0,
        inside: {
          function: /\b\w+$/,
          keyword: /^self\b/,
          "class-name": /^\w+/,
          punctuation: /\./
        }
      }
    }), t.languages.insertBefore("ruby", "string", {
      "string-literal": [
        {
          pattern: RegExp(/%[qQiIwWs]?/.source + i),
          greedy: !0,
          inside: {
            interpolation: a,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: !0,
          inside: {
            interpolation: a,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?/
              }
            },
            interpolation: a,
            string: /[\s\S]+/
          }
        },
        {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?'|'$/
              }
            },
            string: /[\s\S]+/
          }
        }
      ],
      "command-literal": [
        {
          pattern: RegExp(/%x/.source + i),
          greedy: !0,
          inside: {
            interpolation: a,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        },
        {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: !0,
          inside: {
            interpolation: a,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }
      ]
    }), delete t.languages.ruby.string, t.languages.insertBefore("ruby", "number", {
      builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
      constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    }), t.languages.rb = t.languages.ruby;
  })(e);
}
Bm.displayName = "crystal";
Bm.aliases = [];
function Bm(e) {
  e.register(wi), (function(t) {
    t.languages.crystal = t.languages.extend("ruby", {
      keyword: [
        /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
        {
          pattern: /(\.\s*)(?:is_a|responds_to)\?/,
          lookbehind: !0
        }
      ],
      number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
      operator: [/->/, t.languages.ruby.operator],
      punctuation: /[(){}[\].,;\\]/
    }), t.languages.insertBefore("crystal", "string-literal", {
      attribute: {
        pattern: /@\[.*?\]/,
        inside: {
          delimiter: {
            pattern: /^@\[|\]$/,
            alias: "punctuation"
          },
          attribute: {
            pattern: /^(\s*)\w+/,
            lookbehind: !0,
            alias: "class-name"
          },
          args: {
            pattern: /\S(?:[\s\S]*\S)?/,
            inside: t.languages.crystal
          }
        }
      },
      expansion: {
        pattern: /\{(?:\{.*?\}|%.*?%)\}/,
        inside: {
          content: {
            pattern: /^(\{.)[\s\S]+(?=.\}$)/,
            lookbehind: !0,
            inside: t.languages.crystal
          },
          delimiter: {
            pattern: /^\{[\{%]|[\}%]\}$/,
            alias: "operator"
          }
        }
      },
      char: {
        pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
        greedy: !0
      }
    });
  })(e);
}
Fm.displayName = "css-extras";
Fm.aliases = [];
function Fm(e) {
  e.register(Sr), (function(t) {
    var a = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, i;
    t.languages.css.selector = {
      pattern: t.languages.css.selector.pattern,
      lookbehind: !0,
      inside: i = {
        "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
        "pseudo-class": /:[-\w]+/,
        class: /\.[-\w]+/,
        id: /#[-\w]+/,
        attribute: {
          pattern: RegExp(`\\[(?:[^[\\]"']|` + a.source + ")*\\]"),
          greedy: !0,
          inside: {
            punctuation: /^\[|\]$/,
            "case-sensitivity": {
              pattern: /(\s)[si]$/i,
              lookbehind: !0,
              alias: "keyword"
            },
            namespace: {
              pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
              lookbehind: !0,
              inside: {
                punctuation: /\|$/
              }
            },
            "attr-name": {
              pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
              lookbehind: !0
            },
            "attr-value": [
              a,
              {
                pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                lookbehind: !0
              }
            ],
            operator: /[|~*^$]?=/
          }
        },
        "n-th": [
          {
            pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
            lookbehind: !0,
            inside: {
              number: /[\dn]+/,
              operator: /[+-]/
            }
          },
          {
            pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
            lookbehind: !0
          }
        ],
        combinator: />|\+|~|\|\|/,
        // the `tag` token has been existed and removed.
        // because we can't find a perfect tokenize to match it.
        // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
        punctuation: /[(),]/
      }
    }, t.languages.css.atrule.inside["selector-function-argument"].inside = i, t.languages.insertBefore("css", "property", {
      variable: {
        pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
        lookbehind: !0
      }
    });
    var o = {
      pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
      lookbehind: !0
    }, l = {
      pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
      lookbehind: !0
    };
    t.languages.insertBefore("css", "function", {
      operator: {
        pattern: /(\s)[+\-*\/](?=\s)/,
        lookbehind: !0
      },
      // CAREFUL!
      // Previewers and Inline color use hexcode and color.
      hexcode: {
        pattern: /\B#[\da-f]{3,8}\b/i,
        alias: "color"
      },
      color: [
        {
          pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
          lookbehind: !0
        },
        {
          pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
          inside: {
            unit: o,
            number: l,
            function: /[\w-]+(?=\()/,
            punctuation: /[(),]/
          }
        }
      ],
      // it's important that there is no boundary assertion after the hex digits
      entity: /\\[\da-f]{1,8}/i,
      unit: o,
      number: l
    });
  })(e);
}
Pm.displayName = "csv";
Pm.aliases = [];
function Pm(e) {
  e.languages.csv = {
    value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
    punctuation: /,/
  };
}
Hm.displayName = "cue";
Hm.aliases = [];
function Hm(e) {
  (function(t) {
    var a = /\\(?:(?!\2)|\2(?:[^()\r\n]|\([^()]*\)))/.source, i = /"""(?:[^\\"]|"(?!""\2)|<esc>)*"""/.source + // eslint-disable-next-line regexp/strict
    "|" + /'''(?:[^\\']|'(?!''\2)|<esc>)*'''/.source + // eslint-disable-next-line regexp/strict
    "|" + /"(?:[^\\\r\n"]|"(?!\2)|<esc>)*"/.source + // eslint-disable-next-line regexp/strict
    "|" + /'(?:[^\\\r\n']|'(?!\2)|<esc>)*'/.source, o = "(?:" + i.replace(/<esc>/g, a) + ")";
    t.languages.cue = {
      comment: {
        pattern: /\/\/.*/,
        greedy: !0
      },
      "string-literal": {
        // eslint-disable-next-line regexp/strict
        pattern: RegExp(
          /(^|[^#"'\\])(#*)/.source + o + /(?!["'])\2/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,
          // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and
          // capture the hashes at the end of the string.
          escape: {
            pattern: /(?=[\s\S]*["'](#*)$)\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\d{2,3}|[^(])/,
            greedy: !0,
            alias: "string"
          },
          interpolation: {
            pattern: /(?=[\s\S]*["'](#*)$)\\\1\([^()]*\)/,
            greedy: !0,
            inside: {
              punctuation: /^\\#*\(|\)$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: null
              }
            }
          },
          string: /[\s\S]+/
        }
      },
      keyword: {
        pattern: /(^|[^\w$])(?:for|if|import|in|let|null|package)(?![\w$])/,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[^\w$])(?:false|true)(?![\w$])/,
        lookbehind: !0
      },
      builtin: {
        pattern: /(^|[^\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\w$])/,
        lookbehind: !0
      },
      attribute: {
        pattern: /@[\w$]+(?=\s*\()/,
        alias: "function"
      },
      function: {
        pattern: /(^|[^\w$])[a-z_$][\w$]*(?=\s*\()/i,
        lookbehind: !0
      },
      number: {
        pattern: /(^|[^\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[eE][+-]?\d+(?:_\d+)*)?(?:[KMGTP]i?)?)(?![\w$])/,
        lookbehind: !0
      },
      operator: /\.{3}|_\|_|&&?|\|\|?|[=!]~|[<>=!]=?|[+\-*/?]/,
      punctuation: /[()[\]{},.:]/
    }, t.languages.cue["string-literal"].inside.interpolation.inside.expression.inside = t.languages.cue;
  })(e);
}
zm.displayName = "cypher";
zm.aliases = [];
function zm(e) {
  e.languages.cypher = {
    // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
    comment: /\/\/.*/,
    string: {
      pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
      greedy: !0
    },
    "class-name": {
      pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
      lookbehind: !0,
      greedy: !0
    },
    relationship: {
      pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    },
    identifier: {
      pattern: /`(?:[^`\\\r\n])*`/,
      greedy: !0
    },
    variable: /\$\w+/,
    // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
    keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
    function: /\b\w+\b(?=\s*\()/,
    boolean: /\b(?:false|null|true)\b/i,
    number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
    // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
    operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
    punctuation: /[()[\]{},;.]/
  };
}
Gm.displayName = "d";
Gm.aliases = [];
function Gm(e) {
  e.register(ze), e.languages.d = e.languages.extend("clike", {
    comment: [
      {
        // Shebang
        pattern: /^\s*#!.+/,
        greedy: !0
      },
      {
        pattern: RegExp(
          /(^|[^\\])/.source + "(?:" + [
            // /+ comment +/
            // Allow one level of nesting
            /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
            // // comment
            /\/\/.*/.source,
            // /* comment */
            /\/\*[\s\S]*?\*\//.source
          ].join("|") + ")"
        ),
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: [
      {
        pattern: RegExp(
          [
            // r"", x""
            /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
            // q"[]", q"()", q"<>", q"{}"
            /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
            // q"IDENT
            // ...
            // IDENT"
            /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
            // q"//", q"||", etc.
            // eslint-disable-next-line regexp/strict
            /\bq"(.)[\s\S]*?\2"/.source,
            // eslint-disable-next-line regexp/strict
            /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
          ].join("|"),
          "m"
        ),
        greedy: !0
      },
      {
        pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
        greedy: !0,
        alias: "token-string"
      }
    ],
    // In order: $, keywords and special tokens, globally defined symbols
    keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
    number: [
      // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
      // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
      /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
      {
        pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
        lookbehind: !0
      }
    ],
    operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
  }), e.languages.insertBefore("d", "string", {
    // Characters
    // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
    char: /'(?:\\(?:\W|\w+)|[^\\])'/
  }), e.languages.insertBefore("d", "keyword", {
    property: /\B@\w*/
  }), e.languages.insertBefore("d", "function", {
    register: {
      // Iasm registers
      pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
      alias: "variable"
    }
  });
}
jm.displayName = "dart";
jm.aliases = [];
function jm(e) {
  e.register(ze), (function(t) {
    var a = [
      /\b(?:async|sync|yield)\*/,
      /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
    ], i = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, o = {
      pattern: RegExp(i + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        }
      }
    };
    t.languages.dart = t.languages.extend("clike", {
      "class-name": [
        o,
        {
          // variables and parameters
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(
            i + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
          ),
          lookbehind: !0,
          inside: o.inside
        }
      ],
      keyword: a,
      operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
    }), t.languages.insertBefore("dart", "string", {
      "string-literal": {
        pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
            lookbehind: !0,
            inside: {
              punctuation: /^\$\{?|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: t.languages.dart
              }
            }
          },
          string: /[\s\S]+/
        }
      },
      string: void 0
    }), t.languages.insertBefore("dart", "class-name", {
      metadata: {
        pattern: /@\w+/,
        alias: "function"
      }
    }), t.languages.insertBefore("dart", "class-name", {
      generics: {
        pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
        inside: {
          "class-name": o,
          keyword: a,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      }
    });
  })(e);
}
$m.displayName = "dataweave";
$m.aliases = [];
function $m(e) {
  (function(t) {
    t.languages.dataweave = {
      url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
      property: {
        pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
        greedy: !0
      },
      string: {
        pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
      date: {
        pattern: /\|[\w:+-]+\|/,
        greedy: !0
      },
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      regex: {
        pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
        greedy: !0
      },
      keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
      function: /\b[A-Z_]\w*(?=\s*\()/i,
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      punctuation: /[{}[\];(),.:@]/,
      operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
      boolean: /\b(?:false|true)\b/
    };
  })(e);
}
qm.displayName = "dax";
qm.aliases = [];
function qm(e) {
  e.languages.dax = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
      lookbehind: !0
    },
    "data-field": {
      pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
      alias: "symbol"
    },
    measure: {
      pattern: /\[[ \w\xA0-\uFFFF]+\]/,
      alias: "constant"
    },
    string: {
      pattern: /"(?:[^"]|"")*"(?!")/,
      greedy: !0
    },
    function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
    keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
    boolean: {
      pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
      alias: "constant"
    },
    number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
    operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
    punctuation: /[;\[\](){}`,.]/
  };
}
Ym.displayName = "dhall";
Ym.aliases = [];
function Ym(e) {
  e.languages.dhall = {
    // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
    // The multi-line pattern is essentially this:
    //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
    comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
    string: {
      pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$\{[^{}]*\}/,
          inside: {
            expression: {
              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
              lookbehind: !0,
              alias: "language-dhall",
              inside: null
              // see blow
            },
            punctuation: /\$\{|\}/
          }
        }
      }
    },
    label: {
      pattern: /`[^`]*`/,
      greedy: !0
    },
    url: {
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
      pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
      greedy: !0
    },
    env: {
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
      pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
      greedy: !0,
      inside: {
        function: /^env/,
        operator: /^:/,
        variable: /[\s\S]+/
      }
    },
    hash: {
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
      pattern: /\bsha256:[\da-fA-F]{64}\b/,
      inside: {
        function: /sha256/,
        operator: /:/,
        number: /[\da-fA-F]{64}/
      }
    },
    // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
    keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
    builtin: /\b(?:None|Some)\b/,
    boolean: /\b(?:False|True)\b/,
    number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
    operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
    punctuation: /\.\.|[{}\[\](),./]/,
    // we'll just assume that every capital word left is a type name
    "class-name": /\b[A-Z]\w*\b/
  }, e.languages.dhall.string.inside.interpolation.inside.expression.inside = e.languages.dhall;
}
Vm.displayName = "diff";
Vm.aliases = [];
function Vm(e) {
  (function(t) {
    t.languages.diff = {
      coord: [
        // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
        /^(?:\*{3}|-{3}|\+{3}).*$/m,
        // Match "@@ ... @@" coord lines in unified diff.
        /^@@.*@@$/m,
        // Match coord lines in normal diff (starts with a number).
        /^\d.*$/m
      ]
      // deleted, inserted, unchanged, diff
    };
    var a = {
      "deleted-sign": "-",
      "deleted-arrow": "<",
      "inserted-sign": "+",
      "inserted-arrow": ">",
      unchanged: " ",
      diff: "!"
    };
    Object.keys(a).forEach(function(i) {
      var o = a[i], l = [];
      /^\w+$/.test(i) || l.push(/\w+/.exec(i)[0]), i === "diff" && l.push("bold"), t.languages.diff[i] = {
        pattern: RegExp(
          "^(?:[" + o + `].*(?:\r
?|
|(?![\\s\\S])))+`,
          "m"
        ),
        alias: l,
        inside: {
          line: {
            pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
            lookbehind: !0
          },
          prefix: {
            pattern: /[\s\S]/,
            alias: /\w+/.exec(i)[0]
          }
        }
      };
    }), Object.defineProperty(t.languages.diff, "PREFIXES", {
      value: a
    });
  })(e);
}
Ft.displayName = "markup-templating";
Ft.aliases = [];
function Ft(e) {
  e.register(xt), (function(t) {
    function a(i, o) {
      return "___" + i.toUpperCase() + o + "___";
    }
    Object.defineProperties(t.languages["markup-templating"] = {}, {
      buildPlaceholders: {
        /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */
        value: function(i, o, l, c) {
          if (i.language === o) {
            var d = i.tokenStack = [];
            i.code = i.code.replace(l, function(m) {
              if (typeof c == "function" && !c(m))
                return m;
              for (var f = d.length, b; i.code.indexOf(b = a(o, f)) !== -1; )
                ++f;
              return d[f] = m, b;
            }), i.grammar = t.languages.markup;
          }
        }
      },
      tokenizePlaceholders: {
        /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */
        value: function(i, o) {
          if (i.language !== o || !i.tokenStack)
            return;
          i.grammar = t.languages[o];
          var l = 0, c = Object.keys(i.tokenStack);
          function d(m) {
            for (var f = 0; f < m.length && !(l >= c.length); f++) {
              var b = m[f];
              if (typeof b == "string" || b.content && typeof b.content == "string") {
                var E = c[l], T = i.tokenStack[E], S = typeof b == "string" ? b : b.content, _ = a(o, E), k = S.indexOf(_);
                if (k > -1) {
                  ++l;
                  var R = S.substring(0, k), C = new t.Token(
                    o,
                    t.tokenize(T, i.grammar),
                    "language-" + o,
                    T
                  ), L = S.substring(k + _.length), x = [];
                  R && x.push.apply(x, d([R])), x.push(C), L && x.push.apply(x, d([L])), typeof b == "string" ? m.splice.apply(m, [f, 1].concat(x)) : b.content = x;
                }
              } else b.content && d(b.content);
            }
            return m;
          }
          d(i.tokens);
        }
      }
    });
  })(e);
}
Wm.displayName = "django";
Wm.aliases = ["jinja2"];
function Wm(e) {
  e.register(Ft), (function(t) {
    t.languages.django = {
      comment: /^\{#[\s\S]*?#\}$/,
      tag: {
        pattern: /(^\{%[+-]?\s*)\w+/,
        lookbehind: !0,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      filter: {
        pattern: /(\|)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      test: {
        pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      function: /\b[a-z_]\w+(?=\s*\()/i,
      keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
      operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      number: /\b\d+(?:\.\d+)?\b/,
      boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
      variable: /\b\w+\b/,
      punctuation: /[{}[\](),.:;]/
    };
    var a = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g, i = t.languages["markup-templating"];
    t.hooks.add("before-tokenize", function(o) {
      i.buildPlaceholders(o, "django", a);
    }), t.hooks.add("after-tokenize", function(o) {
      i.tokenizePlaceholders(o, "django");
    }), t.languages.jinja2 = t.languages.django, t.hooks.add("before-tokenize", function(o) {
      i.buildPlaceholders(o, "jinja2", a);
    }), t.hooks.add("after-tokenize", function(o) {
      i.tokenizePlaceholders(o, "jinja2");
    });
  })(e);
}
Xm.displayName = "dns-zone-file";
Xm.aliases = ["dns-zone"];
function Xm(e) {
  e.languages["dns-zone-file"] = {
    comment: /;.*/,
    string: {
      pattern: /"(?:\\.|[^"\\\r\n])*"/,
      greedy: !0
    },
    variable: [
      {
        pattern: /(^\$ORIGIN[ \t]+)\S+/m,
        lookbehind: !0
      },
      {
        pattern: /(^|\s)@(?=\s|$)/,
        lookbehind: !0
      }
    ],
    keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
    class: {
      // https://tools.ietf.org/html/rfc1035#page-13
      pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
      lookbehind: !0,
      alias: "keyword"
    },
    type: {
      // https://en.wikipedia.org/wiki/List_of_DNS_record_types
      pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
      lookbehind: !0,
      alias: "keyword"
    },
    punctuation: /[()]/
  }, e.languages["dns-zone"] = e.languages["dns-zone-file"];
}
Km.displayName = "docker";
Km.aliases = ["dockerfile"];
function Km(e) {
  (function(t) {
    var a = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source, i = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
      /<SP_BS>/g,
      function() {
        return a;
      }
    ), o = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source, l = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
      /<STR>/g,
      function() {
        return o;
      }
    ), c = {
      pattern: RegExp(o),
      greedy: !0
    }, d = {
      pattern: /(^[ \t]*)#.*/m,
      lookbehind: !0,
      greedy: !0
    };
    function m(f, b) {
      return f = f.replace(/<OPT>/g, function() {
        return l;
      }).replace(/<SP>/g, function() {
        return i;
      }), RegExp(f, b);
    }
    t.languages.docker = {
      instruction: {
        pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
        lookbehind: !0,
        greedy: !0,
        inside: {
          options: {
            pattern: m(
              /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
              "i"
            ),
            lookbehind: !0,
            greedy: !0,
            inside: {
              property: {
                pattern: /(^|\s)--[\w-]+/,
                lookbehind: !0
              },
              string: [
                c,
                {
                  pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                  lookbehind: !0
                }
              ],
              operator: /\\$/m,
              punctuation: /=/
            }
          },
          keyword: [
            {
              // https://docs.docker.com/engine/reference/builder/#healthcheck
              pattern: m(
                /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
                "i"
              ),
              lookbehind: !0,
              greedy: !0
            },
            {
              // https://docs.docker.com/engine/reference/builder/#from
              pattern: m(
                /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
                "i"
              ),
              lookbehind: !0,
              greedy: !0
            },
            {
              // https://docs.docker.com/engine/reference/builder/#onbuild
              pattern: m(/(^ONBUILD<SP>)\w+/.source, "i"),
              lookbehind: !0,
              greedy: !0
            },
            {
              pattern: /^\w+/,
              greedy: !0
            }
          ],
          comment: d,
          string: c,
          variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
          operator: /\\$/m
        }
      },
      comment: d
    }, t.languages.dockerfile = t.languages.docker;
  })(e);
}
Zm.displayName = "dot";
Zm.aliases = ["gv"];
function Zm(e) {
  (function(t) {
    var a = "(?:" + [
      // an identifier
      /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
      // a number
      /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
      // a double-quoted string
      /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
      // HTML-like string
      /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
    ].join("|") + ")", i = {
      markup: {
        pattern: /(^<)[\s\S]+(?=>$)/,
        lookbehind: !0,
        alias: ["language-markup", "language-html", "language-xml"],
        inside: t.languages.markup
      }
    };
    function o(l, c) {
      return RegExp(
        l.replace(/<ID>/g, function() {
          return a;
        }),
        c
      );
    }
    t.languages.dot = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
        greedy: !0
      },
      "graph-name": {
        pattern: o(
          /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
          "i"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "class-name",
        inside: i
      },
      "attr-value": {
        pattern: o(/(=[ \t\r\n]*)<ID>/.source),
        lookbehind: !0,
        greedy: !0,
        inside: i
      },
      "attr-name": {
        pattern: o(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
        lookbehind: !0,
        greedy: !0,
        inside: i
      },
      keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
      "compass-point": {
        pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
        lookbehind: !0,
        alias: "builtin"
      },
      node: {
        pattern: o(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
        lookbehind: !0,
        greedy: !0,
        inside: i
      },
      operator: /[=:]|-[->]/,
      punctuation: /[\[\]{};,]/
    }, t.languages.gv = t.languages.dot;
  })(e);
}
Qm.displayName = "ebnf";
Qm.aliases = [];
function Qm(e) {
  e.languages.ebnf = {
    comment: /\(\*[\s\S]*?\*\)/,
    string: {
      pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
      greedy: !0
    },
    special: {
      pattern: /\?[^?\r\n]*\?/,
      greedy: !0,
      alias: "class-name"
    },
    definition: {
      pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
      lookbehind: !0,
      alias: ["rule", "keyword"]
    },
    rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
    punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
    operator: /[-=|*/!]/
  };
}
Jm.displayName = "editorconfig";
Jm.aliases = [];
function Jm(e) {
  e.languages.editorconfig = {
    // https://editorconfig-specification.readthedocs.io
    comment: /[;#].*/,
    section: {
      pattern: /(^[ \t]*)\[.+\]/m,
      lookbehind: !0,
      alias: "selector",
      inside: {
        regex: /\\\\[\[\]{},!?.*]/,
        // Escape special characters with '\\'
        operator: /[!?]|\.\.|\*{1,2}/,
        punctuation: /[\[\]{},]/
      }
    },
    key: {
      pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
      lookbehind: !0,
      alias: "attr-name"
    },
    value: {
      pattern: /=.*/,
      alias: "attr-value",
      inside: {
        punctuation: /^=/
      }
    }
  };
}
eg.displayName = "eiffel";
eg.aliases = [];
function eg(e) {
  e.languages.eiffel = {
    comment: /--.*/,
    string: [
      // Aligned-verbatim-strings
      {
        pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
        greedy: !0
      },
      // Non-aligned-verbatim-strings
      {
        pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
        greedy: !0
      },
      // Single-line string
      {
        pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
        greedy: !0
      }
    ],
    // normal char | special char | char code
    char: /'(?:%.|[^%'\r\n])+'/,
    keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
    boolean: /\b(?:False|True)\b/i,
    // Convention: class-names are always all upper-case characters
    "class-name": /\b[A-Z][\dA-Z_]*\b/,
    number: [
      // hexa | octal | bin
      /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
      // Decimal
      /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
    ],
    punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
    operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
  };
}
tg.displayName = "ejs";
tg.aliases = ["eta"];
function tg(e) {
  e.register(Bt), e.register(Ft), (function(t) {
    t.languages.ejs = {
      delimiter: {
        pattern: /^<%[-_=]?|[-_]?%>$/,
        alias: "punctuation"
      },
      comment: /^#[\s\S]*/,
      "language-javascript": {
        pattern: /[\s\S]+/,
        inside: t.languages.javascript
      }
    }, t.hooks.add("before-tokenize", function(a) {
      var i = /<%(?!%)[\s\S]+?%>/g;
      t.languages["markup-templating"].buildPlaceholders(
        a,
        "ejs",
        i
      );
    }), t.hooks.add("after-tokenize", function(a) {
      t.languages["markup-templating"].tokenizePlaceholders(a, "ejs");
    }), t.languages.eta = t.languages.ejs;
  })(e);
}
ng.displayName = "elixir";
ng.aliases = [];
function ng(e) {
  e.languages.elixir = {
    doc: {
      pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
      inside: {
        attribute: /^@\w+/,
        string: /['"][\s\S]+/
      }
    },
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
    regex: {
      pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
      greedy: !0
    },
    string: [
      {
        // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
        pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      },
      {
        pattern: /("""|''')[\s\S]*?\1/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      },
      {
        // Multi-line strings are allowed
        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      }
    ],
    atom: {
      // Look-behind prevents bad highlighting of the :: operator
      pattern: /(^|[^:]):\w+/,
      lookbehind: !0,
      alias: "symbol"
    },
    module: {
      pattern: /\b[A-Z]\w*\b/,
      alias: "class-name"
    },
    // Look-ahead prevents bad highlighting of the :: operator
    "attr-name": /\b\w+\??:(?!:)/,
    argument: {
      // Look-behind prevents bad highlighting of the && operator
      pattern: /(^|[^&])&\d+/,
      lookbehind: !0,
      alias: "variable"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "variable"
    },
    function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
    number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
    keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
    boolean: /\b(?:false|nil|true)\b/,
    operator: [
      /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
      {
        // We don't want to match <<
        pattern: /([^<])<(?!<)/,
        lookbehind: !0
      },
      {
        // We don't want to match >>
        pattern: /([^>])>(?!>)/,
        lookbehind: !0
      }
    ],
    punctuation: /<<|>>|[.,%\[\]{}()]/
  }, e.languages.elixir.string.forEach(function(t) {
    t.inside = {
      interpolation: {
        pattern: /#\{[^}]+\}/,
        inside: {
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          },
          rest: e.languages.elixir
        }
      }
    };
  });
}
ag.displayName = "elm";
ag.aliases = [];
function ag(e) {
  e.languages.elm = {
    comment: /--.*|\{-[\s\S]*?-\}/,
    char: {
      pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
      greedy: !0
    },
    string: [
      {
        // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
        pattern: /"""[\s\S]*?"""/,
        greedy: !0
      },
      {
        pattern: /"(?:[^\\"\r\n]|\\.)*"/,
        greedy: !0
      }
    ],
    "import-statement": {
      // The imported or hidden names are not included in this import
      // statement. This is because we want to highlight those exactly like
      // we do for the names in the program.
      pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
      lookbehind: !0,
      inside: {
        keyword: /\b(?:as|exposing|import)\b/
      }
    },
    keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
    // These are builtin variables only. Constructors are highlighted later as a constant.
    builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
    // decimal integers and floating point numbers | hexadecimal integers
    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
    // Most of this is needed because of the meaning of a single '.'.
    // If it stands alone freely, it is the function composition.
    // It may also be a separator between a module name and an identifier => no
    // operator. If it comes together with other special characters it is an
    // operator too.
    // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
    // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
    operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
    // In Elm, nearly everything is a variable, do not highlight these.
    hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
    constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
    punctuation: /[{}[\]|(),.:]/
  };
}
Ru.displayName = "lua";
Ru.aliases = [];
function Ru(e) {
  e.languages.lua = {
    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: !0
    },
    number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    function: /(?!\d)\w+(?=\s*(?:[({]))/,
    operator: [
      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
      {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: !0
      }
    ],
    punctuation: /[\[\](){},;]|\.+|:+/
  };
}
rg.displayName = "etlua";
rg.aliases = [];
function rg(e) {
  e.register(Ru), e.register(Ft), (function(t) {
    t.languages.etlua = {
      delimiter: {
        pattern: /^<%[-=]?|-?%>$/,
        alias: "punctuation"
      },
      "language-lua": {
        pattern: /[\s\S]+/,
        inside: t.languages.lua
      }
    }, t.hooks.add("before-tokenize", function(a) {
      var i = /<%[\s\S]+?%>/g;
      t.languages["markup-templating"].buildPlaceholders(
        a,
        "etlua",
        i
      );
    }), t.hooks.add("after-tokenize", function(a) {
      t.languages["markup-templating"].tokenizePlaceholders(a, "etlua");
    });
  })(e);
}
ig.displayName = "erb";
ig.aliases = [];
function ig(e) {
  e.register(Ft), e.register(wi), (function(t) {
    t.languages.erb = {
      delimiter: {
        pattern: /^(\s*)<%=?|%>(?=\s*$)/,
        lookbehind: !0,
        alias: "punctuation"
      },
      ruby: {
        pattern: /\s*\S[\s\S]*/,
        alias: "language-ruby",
        inside: t.languages.ruby
      }
    }, t.hooks.add("before-tokenize", function(a) {
      var i = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
      t.languages["markup-templating"].buildPlaceholders(
        a,
        "erb",
        i
      );
    }), t.hooks.add("after-tokenize", function(a) {
      t.languages["markup-templating"].tokenizePlaceholders(a, "erb");
    });
  })(e);
}
sg.displayName = "erlang";
sg.aliases = [];
function sg(e) {
  e.languages.erlang = {
    comment: /%.+/,
    string: {
      pattern: /"(?:\\.|[^\\"\r\n])*"/,
      greedy: !0
    },
    "quoted-function": {
      pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
      alias: "function"
    },
    "quoted-atom": {
      pattern: /'(?:\\.|[^\\'\r\n])+'/,
      alias: "atom"
    },
    boolean: /\b(?:false|true)\b/,
    keyword: /\b(?:after|begin|case|catch|end|fun|if|of|receive|try|when)\b/,
    number: [
      /\$\\?./,
      /\b\d+#[a-z0-9]+/i,
      /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
    ],
    function: /\b[a-z][\w@]*(?=\()/,
    variable: {
      // Look-behind is used to prevent wrong highlighting of atoms containing "@"
      pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
      lookbehind: !0
    },
    operator: [
      /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
      {
        // We don't want to match <<
        pattern: /(^|[^<])<(?!<)/,
        lookbehind: !0
      },
      {
        // We don't want to match >>
        pattern: /(^|[^>])>(?!>)/,
        lookbehind: !0
      }
    ],
    atom: /\b[a-z][\w@]*/,
    punctuation: /[()[\]{}:;,.#|]|<<|>>/
  };
}
og.displayName = "excel-formula";
og.aliases = ["xls", "xlsx"];
function og(e) {
  e.languages["excel-formula"] = {
    comment: {
      pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"]|"")*"(?!")/,
      greedy: !0
    },
    reference: {
      // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
      // Sales!B2
      // 'Winter sales'!B2
      // [Sales.xlsx]Jan!B2:B5
      // D:\Reports\[Sales.xlsx]Jan!B2:B5
      // '[Sales.xlsx]Jan sales'!B2:B5
      // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
      pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
      greedy: !0,
      alias: "string",
      inside: {
        operator: /!$/,
        punctuation: /'/,
        sheet: {
          pattern: /[^[\]]+$/,
          alias: "function"
        },
        file: {
          pattern: /\[[^[\]]+\]$/,
          inside: {
            punctuation: /[[\]]/
          }
        },
        path: /[\s\S]+/
      }
    },
    "function-name": {
      pattern: /\b[A-Z]\w*(?=\()/i,
      alias: "builtin"
    },
    range: {
      pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
      alias: "selector",
      inside: {
        operator: /:/,
        cell: /\$?[A-Z]+\$?\d+/i,
        column: /\$?[A-Z]+/i,
        row: /\$?\d+/
      }
    },
    cell: {
      // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
      // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
      pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
      alias: "selector"
    },
    number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
    boolean: /\b(?:FALSE|TRUE)\b/i,
    operator: /[-+*/^%=&,]|<[=>]?|>=?/,
    punctuation: /[[\]();{}|]/
  }, e.languages.xlsx = e.languages.xls = e.languages["excel-formula"];
}
lg.displayName = "fsharp";
lg.aliases = [];
function lg(e) {
  e.register(ze), e.languages.fsharp = e.languages.extend("clike", {
    comment: [
      {
        pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
      lookbehind: !0,
      inside: {
        operator: /->|\*/,
        punctuation: /\./
      }
    },
    keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
    number: [
      /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
      /\b0b[01]+(?:uy|y)?\b/,
      /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
      /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
    ],
    operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
  }), e.languages.insertBefore("fsharp", "keyword", {
    preprocessor: {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: !0,
      alias: "property",
      inside: {
        directive: {
          pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
          lookbehind: !0,
          alias: "keyword"
        }
      }
    }
  }), e.languages.insertBefore("fsharp", "punctuation", {
    "computation-expression": {
      pattern: /\b[_a-z]\w*(?=\s*\{)/i,
      alias: "keyword"
    }
  }), e.languages.insertBefore("fsharp", "string", {
    annotation: {
      pattern: /\[<.+?>\]/,
      greedy: !0,
      inside: {
        punctuation: /^\[<|>\]$/,
        "class-name": {
          pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
          lookbehind: !0
        },
        "annotation-content": {
          pattern: /[\s\S]+/,
          inside: e.languages.fsharp
        }
      }
    },
    char: {
      pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
      greedy: !0
    }
  });
}
ug.displayName = "factor";
ug.aliases = [];
function ug(e) {
  (function(t) {
    var a = {
      function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
    }, i = {
      number: /\\[^\s']|%\w/
    }, o = {
      comment: [
        {
          // ! single-line exclamation point comments with whitespace after/around the !
          pattern: /(^|\s)(?:! .*|!$)/,
          lookbehind: !0,
          inside: a
        },
        {
          // /* comment */, /* comment*/
          pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          inside: a
        },
        {
          // ![[ comment ]] , ![===[ comment]===]
          pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          inside: a
        }
      ],
      number: [
        {
          // basic base 10 integers 9, -9
          pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
          lookbehind: !0
        },
        {
          // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
          pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
          lookbehind: !0
        },
        {
          // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
          pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
          lookbehind: !0
        },
        {
          // positive mixed numbers 23+1/5 +23+1/5
          pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
          lookbehind: !0
        },
        {
          // negative mixed numbers -23-1/5
          pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
          lookbehind: !0
        },
        {
          // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
          // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
          pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
          lookbehind: !0
        },
        {
          // NAN literal syntax NAN: 80000deadbeef, NAN: a
          pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
          lookbehind: !0
        },
        {
          /*
          base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
          "The normalized hex form 0x1.MMMMMMMMMMMMM[pP]EEEE allows any floating-point number to be specified precisely.
          The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
          <https://docs.factorcode.org/content/article-syntax-floats.html>
          */
          pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
          lookbehind: !0
        }
      ],
      // R/ regexp?\/\\/
      regexp: {
        pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
        lookbehind: !0,
        alias: "number",
        inside: {
          variable: /\\\S/,
          keyword: /[+?*\[\]^$(){}.|]/,
          operator: {
            pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
            lookbehind: !0
          }
        }
      },
      boolean: {
        pattern: /(^|\s)[tf](?=\s|$)/,
        lookbehind: !0
      },
      // SBUF" asd", URL" ://...", P" /etc/"
      "custom-string": {
        pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
        lookbehind: !0,
        greedy: !0,
        alias: "string",
        inside: {
          number: /\\\S|%\w|\//
        }
      },
      "multiline-string": [
        {
          // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
          pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: {
            number: i.number,
            // trailing semicolon on its own line
            "semicolon-or-setlocal": {
              pattern: /([\r\n][ \t]*);(?=\s|$)/,
              lookbehind: !0,
              alias: "function"
            }
          }
        },
        {
          // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
          pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: i
        },
        {
          // [[ string ]], [==[ string]==]
          pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: i
        }
      ],
      "special-using": {
        pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
        lookbehind: !0,
        alias: "function",
        inside: {
          // this is essentially a regex for vocab names, which i don't want to specify
          // but the USING: gets picked up as a vocab name
          string: {
            pattern: /(\s)[^:\s]+/,
            lookbehind: !0
          }
        }
      },
      /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
      trying to do better is more work and regex-computation-time than it's worth though.
      - we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
      - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
      - we'd like if the following variable name conventions were recognised specifically:
      special row variables = ..a b..
      type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
      word throws unconditional error = *
      any other word-like variable name = a ? q' etc
      https://docs.factorcode.org/content/article-effects.html
      these are pretty complicated to highlight properly without a real parser, and therefore out of scope
      the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
      */
      // current solution is not great
      "stack-effect-delimiter": [
        {
          // opening parenthesis
          pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // middle --
          pattern: /(\s)--(?=\s)/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // closing parenthesis
          pattern: /(\s)\)(?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }
      ],
      combinators: {
        pattern: null,
        lookbehind: !0,
        alias: "keyword"
      },
      "kernel-builtin": {
        pattern: null,
        lookbehind: !0,
        alias: "variable"
      },
      "sequences-builtin": {
        pattern: null,
        lookbehind: !0,
        alias: "variable"
      },
      "math-builtin": {
        pattern: null,
        lookbehind: !0,
        alias: "variable"
      },
      "constructor-word": {
        // <array> but not <=>
        pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      "other-builtin-syntax": {
        pattern: null,
        lookbehind: !0,
        alias: "operator"
      },
      /*
      full list of supported word naming conventions: (the convention appears outside of the [brackets])
      set-[x]
      change-[x]
      with-[x]
      new-[x]
      >[string]
      [base]>
      [string]>[number]
      +[symbol]+
      [boolean-word]?
      ?[of]
      [slot-reader]>>
      >>[slot-setter]
      [slot-writer]<<
      ([implementation-detail])
      [mutater]!
      [variant]*
      [prettyprint].
      $[help-markup]
      <constructors>, SYNTAX:, etc are supported by their own patterns.
      `with` and `new` from `kernel` are their own builtins.
      see <https://docs.factorcode.org/content/article-conventions.html>
      */
      "conventionally-named-word": {
        pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      "colon-syntax": {
        pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
        lookbehind: !0,
        greedy: !0,
        alias: "function"
      },
      "semicolon-or-setlocal": {
        pattern: /(\s)(?:;|:>)(?=\s|$)/,
        lookbehind: !0,
        alias: "function"
      },
      // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
      "curly-brace-literal-delimiter": [
        {
          // opening
          pattern: /(^|\s)[a-z]*\{(?=\s)/i,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // closing
          pattern: /(\s)\}(?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }
      ],
      // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
      "quotation-delimiter": [
        {
          // opening
          pattern: /(^|\s)\[(?=\s)/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // closing
          pattern: /(\s)\](?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }
      ],
      "normal-word": {
        pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
        lookbehind: !0
      },
      /*
      basic first-class string "a"
      with escaped double-quote "a\""
      escaped backslash "\\"
      and general escapes since Factor has so many "\N"
      syntax that works in the reference implementation that isn't fully
      supported because it's an implementation detail:
      "string 1""string 2" -> 2 strings (works anyway)
      "string"5 -> string, 5
      "string"[ ] -> string, quotation
      { "a"} -> array<string>
      the rest of those examples all properly recognise the string, but not
      the other object (number, quotation, etc)
      this is fine for a regex-only implementation.
      */
      string: {
        pattern: /"(?:\\\S|[^"\\])*"/,
        greedy: !0,
        inside: i
      }
    }, l = function(f) {
      return (f + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
    }, c = function(f) {
      return new RegExp("(^|\\s)(?:" + f.map(l).join("|") + ")(?=\\s|$)");
    }, d = {
      "kernel-builtin": [
        "or",
        "2nipd",
        "4drop",
        "tuck",
        "wrapper",
        "nip",
        "wrapper?",
        "callstack>array",
        "die",
        "dupd",
        "callstack",
        "callstack?",
        "3dup",
        "hashcode",
        "pick",
        "4nip",
        "build",
        ">boolean",
        "nipd",
        "clone",
        "5nip",
        "eq?",
        "?",
        "=",
        "swapd",
        "2over",
        "clear",
        "2dup",
        "get-retainstack",
        "not",
        "tuple?",
        "dup",
        "3nipd",
        "call",
        "-rotd",
        "object",
        "drop",
        "assert=",
        "assert?",
        "-rot",
        "execute",
        "boa",
        "get-callstack",
        "curried?",
        "3drop",
        "pickd",
        "overd",
        "over",
        "roll",
        "3nip",
        "swap",
        "and",
        "2nip",
        "rotd",
        "throw",
        "(clone)",
        "hashcode*",
        "spin",
        "reach",
        "4dup",
        "equal?",
        "get-datastack",
        "assert",
        "2drop",
        "<wrapper>",
        "boolean?",
        "identity-hashcode",
        "identity-tuple?",
        "null",
        "composed?",
        "new",
        "5drop",
        "rot",
        "-roll",
        "xor",
        "identity-tuple",
        "boolean"
      ],
      "other-builtin-syntax": [
        // syntax
        "=======",
        "recursive",
        "flushable",
        ">>",
        "<<<<<<",
        "M\\",
        "B",
        "PRIVATE>",
        "\\",
        "======",
        "final",
        "inline",
        "delimiter",
        "deprecated",
        "<PRIVATE",
        ">>>>>>",
        "<<<<<<<",
        "parse-complex",
        "malformed-complex",
        "read-only",
        ">>>>>>>",
        "call-next-method",
        "<<",
        "foldable",
        // literals
        "$",
        "$[",
        "${"
      ],
      "sequences-builtin": [
        "member-eq?",
        "mismatch",
        "append",
        "assert-sequence=",
        "longer",
        "repetition",
        "clone-like",
        "3sequence",
        "assert-sequence?",
        "last-index-from",
        "reversed",
        "index-from",
        "cut*",
        "pad-tail",
        "join-as",
        "remove-eq!",
        "concat-as",
        "but-last",
        "snip",
        "nths",
        "nth",
        "sequence",
        "longest",
        "slice?",
        "<slice>",
        "remove-nth",
        "tail-slice",
        "empty?",
        "tail*",
        "member?",
        "virtual-sequence?",
        "set-length",
        "drop-prefix",
        "iota",
        "unclip",
        "bounds-error?",
        "unclip-last-slice",
        "non-negative-integer-expected",
        "non-negative-integer-expected?",
        "midpoint@",
        "longer?",
        "?set-nth",
        "?first",
        "rest-slice",
        "prepend-as",
        "prepend",
        "fourth",
        "sift",
        "subseq-start",
        "new-sequence",
        "?last",
        "like",
        "first4",
        "1sequence",
        "reverse",
        "slice",
        "virtual@",
        "repetition?",
        "set-last",
        "index",
        "4sequence",
        "max-length",
        "set-second",
        "immutable-sequence",
        "first2",
        "first3",
        "supremum",
        "unclip-slice",
        "suffix!",
        "insert-nth",
        "tail",
        "3append",
        "short",
        "suffix",
        "concat",
        "flip",
        "immutable?",
        "reverse!",
        "2sequence",
        "sum",
        "delete-all",
        "indices",
        "snip-slice",
        "<iota>",
        "check-slice",
        "sequence?",
        "head",
        "append-as",
        "halves",
        "sequence=",
        "collapse-slice",
        "?second",
        "slice-error?",
        "product",
        "bounds-check?",
        "bounds-check",
        "immutable",
        "virtual-exemplar",
        "harvest",
        "remove",
        "pad-head",
        "last",
        "set-fourth",
        "cartesian-product",
        "remove-eq",
        "shorten",
        "shorter",
        "reversed?",
        "shorter?",
        "shortest",
        "head-slice",
        "pop*",
        "tail-slice*",
        "but-last-slice",
        "iota?",
        "append!",
        "cut-slice",
        "new-resizable",
        "head-slice*",
        "sequence-hashcode",
        "pop",
        "set-nth",
        "?nth",
        "second",
        "join",
        "immutable-sequence?",
        "<reversed>",
        "3append-as",
        "virtual-sequence",
        "subseq?",
        "remove-nth!",
        "length",
        "last-index",
        "lengthen",
        "assert-sequence",
        "copy",
        "move",
        "third",
        "first",
        "tail?",
        "set-first",
        "prefix",
        "bounds-error",
        "<repetition>",
        "exchange",
        "surround",
        "cut",
        "min-length",
        "set-third",
        "push-all",
        "head?",
        "subseq-start-from",
        "delete-slice",
        "rest",
        "sum-lengths",
        "head*",
        "infimum",
        "remove!",
        "glue",
        "slice-error",
        "subseq",
        "push",
        "replace-slice",
        "subseq-as",
        "unclip-last"
      ],
      "math-builtin": [
        "number=",
        "next-power-of-2",
        "?1+",
        "fp-special?",
        "imaginary-part",
        "float>bits",
        "number?",
        "fp-infinity?",
        "bignum?",
        "fp-snan?",
        "denominator",
        "gcd",
        "*",
        "+",
        "fp-bitwise=",
        "-",
        "u>=",
        "/",
        ">=",
        "bitand",
        "power-of-2?",
        "log2-expects-positive",
        "neg?",
        "<",
        "log2",
        ">",
        "integer?",
        "number",
        "bits>double",
        "2/",
        "zero?",
        "bits>float",
        "float?",
        "shift",
        "ratio?",
        "rect>",
        "even?",
        "ratio",
        "fp-sign",
        "bitnot",
        ">fixnum",
        "complex?",
        "/i",
        "integer>fixnum",
        "/f",
        "sgn",
        ">bignum",
        "next-float",
        "u<",
        "u>",
        "mod",
        "recip",
        "rational",
        ">float",
        "2^",
        "integer",
        "fixnum?",
        "neg",
        "fixnum",
        "sq",
        "bignum",
        ">rect",
        "bit?",
        "fp-qnan?",
        "simple-gcd",
        "complex",
        "<fp-nan>",
        "real",
        ">fraction",
        "double>bits",
        "bitor",
        "rem",
        "fp-nan-payload",
        "real-part",
        "log2-expects-positive?",
        "prev-float",
        "align",
        "unordered?",
        "float",
        "fp-nan?",
        "abs",
        "bitxor",
        "integer>fixnum-strict",
        "u<=",
        "odd?",
        "<=",
        "/mod",
        ">integer",
        "real?",
        "rational?",
        "numerator"
      ]
      // that's all for now
    };
    Object.keys(d).forEach(function(f) {
      o[f].pattern = c(d[f]);
    });
    var m = [
      // kernel
      "2bi",
      "while",
      "2tri",
      "bi*",
      "4dip",
      "both?",
      "same?",
      "tri@",
      "curry",
      "prepose",
      "3bi",
      "?if",
      "tri*",
      "2keep",
      "3keep",
      "curried",
      "2keepd",
      "when",
      "2bi*",
      "2tri*",
      "4keep",
      "bi@",
      "keepdd",
      "do",
      "unless*",
      "tri-curry",
      "if*",
      "loop",
      "bi-curry*",
      "when*",
      "2bi@",
      "2tri@",
      "with",
      "2with",
      "either?",
      "bi",
      "until",
      "3dip",
      "3curry",
      "tri-curry*",
      "tri-curry@",
      "bi-curry",
      "keepd",
      "compose",
      "2dip",
      "if",
      "3tri",
      "unless",
      "tuple",
      "keep",
      "2curry",
      "tri",
      "most",
      "while*",
      "dip",
      "composed",
      "bi-curry@",
      // sequences
      "find-last-from",
      "trim-head-slice",
      "map-as",
      "each-from",
      "none?",
      "trim-tail",
      "partition",
      "if-empty",
      "accumulate*",
      "reject!",
      "find-from",
      "accumulate-as",
      "collector-for-as",
      "reject",
      "map",
      "map-sum",
      "accumulate!",
      "2each-from",
      "follow",
      "supremum-by",
      "map!",
      "unless-empty",
      "collector",
      "padding",
      "reduce-index",
      "replicate-as",
      "infimum-by",
      "trim-tail-slice",
      "count",
      "find-index",
      "filter",
      "accumulate*!",
      "reject-as",
      "map-integers",
      "map-find",
      "reduce",
      "selector",
      "interleave",
      "2map",
      "filter-as",
      "binary-reduce",
      "map-index-as",
      "find",
      "produce",
      "filter!",
      "replicate",
      "cartesian-map",
      "cartesian-each",
      "find-index-from",
      "map-find-last",
      "3map-as",
      "3map",
      "find-last",
      "selector-as",
      "2map-as",
      "2map-reduce",
      "accumulate",
      "each",
      "each-index",
      "accumulate*-as",
      "when-empty",
      "all?",
      "collector-as",
      "push-either",
      "new-like",
      "collector-for",
      "2selector",
      "push-if",
      "2all?",
      "map-reduce",
      "3each",
      "any?",
      "trim-slice",
      "2reduce",
      "change-nth",
      "produce-as",
      "2each",
      "trim",
      "trim-head",
      "cartesian-find",
      "map-index",
      // math
      "if-zero",
      "each-integer",
      "unless-zero",
      "(find-integer)",
      "when-zero",
      "find-last-integer",
      "(all-integers?)",
      "times",
      "(each-integer)",
      "find-integer",
      "all-integers?",
      // math.combinators
      "unless-negative",
      "if-positive",
      "when-positive",
      "when-negative",
      "unless-positive",
      "if-negative",
      // combinators
      "case",
      "2cleave",
      "cond>quot",
      "case>quot",
      "3cleave",
      "wrong-values",
      "to-fixed-point",
      "alist>quot",
      "cond",
      "cleave",
      "call-effect",
      "recursive-hashcode",
      "spread",
      "deep-spread>quot",
      // combinators.short-circuit
      "2||",
      "0||",
      "n||",
      "0&&",
      "2&&",
      "3||",
      "1||",
      "1&&",
      "n&&",
      "3&&",
      // combinators.smart
      "smart-unless*",
      "keep-inputs",
      "reduce-outputs",
      "smart-when*",
      "cleave>array",
      "smart-with",
      "smart-apply",
      "smart-if",
      "inputs/outputs",
      "output>sequence-n",
      "map-outputs",
      "map-reduce-outputs",
      "dropping",
      "output>array",
      "smart-map-reduce",
      "smart-2map-reduce",
      "output>array-n",
      "nullary",
      "input<sequence",
      "append-outputs",
      "drop-inputs",
      "inputs",
      "smart-2reduce",
      "drop-outputs",
      "smart-reduce",
      "preserving",
      "smart-when",
      "outputs",
      "append-outputs-as",
      "smart-unless",
      "smart-if*",
      "sum-outputs",
      "input<sequence-unsafe",
      "output>sequence"
      // tafn
    ];
    o.combinators.pattern = c(m), t.languages.factor = o;
  })(e);
}
cg.displayName = "false";
cg.aliases = [];
function cg(e) {
  (function(t) {
    t.languages.false = {
      comment: {
        pattern: /\{[^}]*\}/
      },
      string: {
        pattern: /"[^"]*"/,
        greedy: !0
      },
      "character-code": {
        pattern: /'(?:[^\r]|\r\n?)/,
        alias: "number"
      },
      "assembler-code": {
        pattern: /\d+`/,
        alias: "important"
      },
      number: /\d+/,
      operator: /[-!#$%&'*+,./:;=>?@\\^_`|~]/,
      punctuation: /\[|\]/,
      variable: /[a-z]/,
      "non-standard": {
        pattern: /[()<BDO]/,
        alias: "bold"
      }
    };
  })(e);
}
dg.displayName = "firestore-security-rules";
dg.aliases = [];
function dg(e) {
  e.register(ze), e.languages["firestore-security-rules"] = e.languages.extend(
    "clike",
    {
      comment: /\/\/.*/,
      keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
      operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
    }
  ), delete e.languages["firestore-security-rules"]["class-name"], e.languages.insertBefore("firestore-security-rules", "keyword", {
    path: {
      pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        variable: {
          pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
          inside: {
            operator: /=/,
            keyword: /\*\*/,
            punctuation: /[.$(){}]/
          }
        },
        punctuation: /\//
      }
    },
    method: {
      // to make the pattern shorter, the actual method names are omitted
      pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
      lookbehind: !0,
      alias: "builtin",
      inside: {
        punctuation: /,/
      }
    }
  });
}
pg.displayName = "flow";
pg.aliases = [];
function pg(e) {
  e.register(Bt), (function(t) {
    t.languages.flow = t.languages.extend("javascript", {}), t.languages.insertBefore("flow", "keyword", {
      type: [
        {
          pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/,
          alias: "class-name"
        }
      ]
    }), t.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete t.languages.flow.parameter, t.languages.insertBefore("flow", "operator", {
      "flow-punctuation": {
        pattern: /\{\||\|\}/,
        alias: "punctuation"
      }
    }), Array.isArray(t.languages.flow.keyword) || (t.languages.flow.keyword = [t.languages.flow.keyword]), t.languages.flow.keyword.unshift(
      {
        pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
        lookbehind: !0
      }
    );
  })(e);
}
fg.displayName = "fortran";
fg.aliases = [];
function fg(e) {
  e.languages.fortran = {
    "quoted-number": {
      pattern: /[BOZ](['"])[A-F0-9]+\1/i,
      alias: "number"
    },
    string: {
      pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
      inside: {
        comment: {
          pattern: /(&(?:\r\n?|\n)\s*)!.*/,
          lookbehind: !0
        }
      }
    },
    comment: {
      pattern: /!.*/,
      greedy: !0
    },
    boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
    keyword: [
      // Types
      /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
      // END statements
      /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
      // Statements
      /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
      // Others
      /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
    ],
    operator: [
      /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
      {
        // Use lookbehind to prevent confusion with (/ /)
        pattern: /(^|(?!\().)\/(?!\))/,
        lookbehind: !0
      }
    ],
    punctuation: /\(\/|\/\)|[(),;:&]/
  };
}
mg.displayName = "ftl";
mg.aliases = [];
function mg(e) {
  e.register(Ft), (function(t) {
    for (var a = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source, i = 0; i < 2; i++)
      a = a.replace(/<expr>/g, function() {
        return a;
      });
    a = a.replace(/<expr>/g, /[^\s\S]/.source);
    var o = {
      comment: /<#--[\s\S]*?-->/,
      string: [
        {
          // raw string
          pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
          greedy: !0
        },
        {
          pattern: RegExp(
            /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
              /<expr>/g,
              function() {
                return a;
              }
            )
          ),
          greedy: !0,
          inside: {
            interpolation: {
              pattern: RegExp(
                /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
                  /<expr>/g,
                  function() {
                    return a;
                  }
                )
              ),
              lookbehind: !0,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: null
              }
            }
          }
        }
      ],
      keyword: /\b(?:as)\b/,
      boolean: /\b(?:false|true)\b/,
      "builtin-function": {
        pattern: /((?:^|[^?])\?\s*)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      function: /\b\w+(?=\s*\()/,
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
      punctuation: /[,;.:()[\]{}]/
    };
    o.string[1].inside.interpolation.inside.rest = o, t.languages.ftl = {
      "ftl-comment": {
        // the pattern is shortened to be more efficient
        pattern: /^<#--[\s\S]*/,
        alias: "comment"
      },
      "ftl-directive": {
        pattern: /^<[\s\S]+>$/,
        inside: {
          directive: {
            pattern: /(^<\/?)[#@][a-z]\w*/i,
            lookbehind: !0,
            alias: "keyword"
          },
          punctuation: /^<\/?|\/?>$/,
          content: {
            pattern: /\s*\S[\s\S]*/,
            alias: "ftl",
            inside: o
          }
        }
      },
      "ftl-interpolation": {
        pattern: /^\$\{[\s\S]*\}$/,
        inside: {
          punctuation: /^\$\{|\}$/,
          content: {
            pattern: /\s*\S[\s\S]*/,
            alias: "ftl",
            inside: o
          }
        }
      }
    }, t.hooks.add("before-tokenize", function(l) {
      var c = RegExp(
        /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
          /<expr>/g,
          function() {
            return a;
          }
        ),
        "gi"
      );
      t.languages["markup-templating"].buildPlaceholders(
        l,
        "ftl",
        c
      );
    }), t.hooks.add("after-tokenize", function(l) {
      t.languages["markup-templating"].tokenizePlaceholders(l, "ftl");
    });
  })(e);
}
gg.displayName = "gml";
gg.aliases = ["gamemakerlanguage"];
function gg(e) {
  e.register(ze), e.languages.gamemakerlanguage = e.languages.gml = e.languages.extend("clike", {
    keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
    number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
    operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
    constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
    variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
  });
}
hg.displayName = "gap";
hg.aliases = [];
function hg(e) {
  e.languages.gap = {
    shell: {
      pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
      greedy: !0,
      inside: {
        gap: {
          pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
          lookbehind: !0,
          inside: null
          // see below
        },
        punctuation: /^gap>/
      }
    },
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        continuation: {
          pattern: /([\r\n])>/,
          lookbehind: !0,
          alias: "punctuation"
        }
      }
    },
    keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: {
      pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
      lookbehind: !0
    },
    continuation: {
      pattern: /([\r\n])>/,
      lookbehind: !0,
      alias: "punctuation"
    },
    operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
    punctuation: /[()[\]{},;.:]/
  }, e.languages.gap.shell.inside.gap.inside = e.languages.gap;
}
bg.displayName = "gcode";
bg.aliases = [];
function bg(e) {
  e.languages.gcode = {
    comment: /;.*|\B\(.*?\)\B/,
    string: {
      pattern: /"(?:""|[^"])*"/,
      greedy: !0
    },
    keyword: /\b[GM]\d+(?:\.\d+)?\b/,
    property: /\b[A-Z]/,
    checksum: {
      pattern: /(\*)\d+/,
      lookbehind: !0,
      alias: "number"
    },
    // T0:0:0
    punctuation: /[:*]/
  };
}
Eg.displayName = "gdscript";
Eg.aliases = [];
function Eg(e) {
  e.languages.gdscript = {
    comment: /#.*/,
    string: {
      pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
      greedy: !0
    },
    "class-name": {
      // class_name Foo, extends Bar, class InnerClass
      // export(int) var baz, export(int, 0) var i
      // as Node
      // const FOO: int = 9, var bar: bool = true
      // func add(reference: Item, amount: int) -> Item:
      pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
      lookbehind: !0
    },
    keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
    function: /\b[a-z_]\w*(?=[ \t]*\()/i,
    variable: /\$\w+/,
    number: [
      /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
      /\b(?:INF|NAN|PI|TAU)\b/
    ],
    constant: /\b[A-Z][A-Z_\d]*\b/,
    boolean: /\b(?:false|true)\b/,
    operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
    punctuation: /[.:,;()[\]{}]/
  };
}
yg.displayName = "gedcom";
yg.aliases = [];
function yg(e) {
  e.languages.gedcom = {
    "line-value": {
      // Preceded by level, optional pointer, and tag
      pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
      lookbehind: !0,
      inside: {
        pointer: {
          pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
          alias: "variable"
        }
      }
    },
    record: {
      // Preceded by level and optional pointer
      pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
      lookbehind: !0,
      alias: "tag"
    },
    level: {
      pattern: /(^[\t ]*)\d+/m,
      lookbehind: !0,
      alias: "number"
    },
    pointer: {
      pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
      alias: "variable"
    }
  };
}
Tg.displayName = "gettext";
Tg.aliases = ["po"];
function Tg(e) {
  e.languages.gettext = {
    comment: [
      {
        pattern: /# .*/,
        greedy: !0,
        alias: "translator-comment"
      },
      {
        pattern: /#\..*/,
        greedy: !0,
        alias: "extracted-comment"
      },
      {
        pattern: /#:.*/,
        greedy: !0,
        alias: "reference-comment"
      },
      {
        pattern: /#,.*/,
        greedy: !0,
        alias: "flag-comment"
      },
      {
        pattern: /#\|.*/,
        greedy: !0,
        alias: "previously-untranslated-comment"
      },
      {
        pattern: /#.*/,
        greedy: !0
      }
    ],
    string: {
      pattern: /(^|[^\\])"(?:[^"\\]|\\.)*"/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /^msg(?:ctxt|id|id_plural|str)\b/m,
    number: /\b\d+\b/,
    punctuation: /[\[\]]/
  }, e.languages.po = e.languages.gettext;
}
Sg.displayName = "gherkin";
Sg.aliases = [];
function Sg(e) {
  (function(t) {
    var a = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
    t.languages.gherkin = {
      pystring: {
        pattern: /("""|''')[\s\S]+?\1/,
        alias: "string"
      },
      comment: {
        pattern: /(^[ \t]*)#.*/m,
        lookbehind: !0
      },
      tag: {
        pattern: /(^[ \t]*)@\S*/m,
        lookbehind: !0
      },
      feature: {
        pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Caracterstica|Egenskab|Egenskap|Eiginleiki|Feature|Fa|Fitur|Fonctionnalit|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcionalitate|Funcionalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitte|Funkcionalnost|Funkcja|Funksie|Funktionalitt|Funktionalitit|Funzionalit|Hwaet|Hwt|Jellemz|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogunost|Moznosti|Monosti|OH HAI|Omadus|Ominaisuus|Osobina|zellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Poadavek|Poiadavka|Pretty much|Qap|Qu'meH 'ut|Savyb|Tnh nng|Trajto|Vermo|Vlastnos|Waciwo|Znailnost||||||||||||||||  || || ||||||||||):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
        lookbehind: !0,
        inside: {
          important: {
            pattern: /(:)[^\r\n]+/,
            lookbehind: !0
          },
          keyword: /[^:\r\n]+:/
        }
      },
      scenario: {
        pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|r|Agtergrond|All y'all|Antecedentes|Antecedents|Atburars|Atburarsir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bi cnh|Cefndir|Cenario|Cenrio|Cenario de Fundo|Cenrio de Fundo|Cenarios|Cenrios|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineao do Cenrio|Dis is what went down|D liu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenrio|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatknyv|Forgatknyv vzlat|Fundo|Gemi|Grundlage|Hannergrond|ghantoH|Httr|Heave to|Istorik|Juhtumid|Keadaan|Khung kch bn|Khung tnh hung|Kch bn|Koncept|Konsep skenario|Kontks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lsing Atburarsar|Lsing Dma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Nrt Scenra|Nrt Scne|Nrt Scenru|Oris scenarija|rnekler|Osnova|Osnova Scenra|Osnova scne|Osnutek|Ozadje|Paraugs|Pavyzdiai|Pldk|Piemri|Plan du scnario|Plan du Scnario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozad|Pozadie|Pozadina|Prklady|Pklady|Primer|Primeri|Primjeri|Przykady|Raamstsenaarium|Reckon it's like|Rerefons|Scenr|Scn|Scenarie|Scenarij|Scenarijai|Scenarijaus ablonas|Scenariji|Scenrijs|Scenrijs pc parauga|Scenarijus|Scenario|Scnario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se e|Se the|Se e|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo tasla|Shiver me timbers|Situcija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structur scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwr swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tnh hung|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Zaoenia|| ||||||||||||||||||  || | | || | |||||||| ||| || |||| ||   || ||| |||| |  |||||||||||||||||| ||||||||||||||||||):[^:\r\n]*/m,
        lookbehind: !0,
        inside: {
          important: {
            pattern: /(:)[^\r\n]*/,
            lookbehind: !0
          },
          keyword: /[^:\r\n]+:/
        }
      },
      "table-body": {
        // Look-behind is used to skip the table head, which has the same format as any table row
        pattern: RegExp("(" + a + ")(?:" + a + ")+"),
        lookbehind: !0,
        inside: {
          outline: {
            pattern: /<[^>]+>/,
            alias: "variable"
          },
          td: {
            pattern: /\s*[^\s|][^|]*/,
            alias: "string"
          },
          punctuation: /\|/
        }
      },
      "table-head": {
        pattern: RegExp(a),
        inside: {
          th: {
            pattern: /\s*[^\s|][^|]*/,
            alias: "variable"
          },
          punctuation: /\|/
        }
      },
      atrule: {
        pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A tak|A taktie|A tie|A zrove|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Ats|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Bit|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Cnd|Cand|Cando|Ce|Cuando|e|a e|a|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Dai fiind|Dai fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitao|Do|Dun|Duota|urh|Eeldades|Ef|Eer ki|Entao|Ento|Entn|E|En|Entonces|Epi|s|Etant donne|Etant donn|Et|tant donnes|tant donne|tant donn|Etant donnes|Etant donns|tant donns|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeli|Jeeli|Kad|Kada|Kadar|Kai|Kaj|Kdy|Ke|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|L sa a|L|Logo|Lorsqu'<|Lorsque|m|Maar|Mais|Majc|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Nr|Nr|Nato|Nhng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Per|Podano|Pokia|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|S|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|i|i|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Th|Thurh|Toda|Too right|Un|Und|ugeholl|V|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za pedpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakadajc|Zaradi|Zatati|a e|a||egar|urh|||||| |||||||||||||||||||||  ||||||||||||, |||||||||||||||||||||| |||||||| |||||||||||||||||||| ||||| ||||||||||||||<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<)(?=[ \t])/m,
        lookbehind: !0
      },
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
        inside: {
          outline: {
            pattern: /<[^>]+>/,
            alias: "variable"
          }
        }
      },
      outline: {
        pattern: /<[^>]+>/,
        alias: "variable"
      }
    };
  })(e);
}
_g.displayName = "git";
_g.aliases = [];
function _g(e) {
  e.languages.git = {
    /*
     * A simple one line comment like in a git status command
     * For instance:
     * $ git status
     * # On branch infinite-scroll
     * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
     * # and have 1 and 2 different commits each, respectively.
     * nothing to commit (working directory clean)
     */
    comment: /^#.*/m,
    /*
     * Regexp to match the changed lines in a git diff output. Check the example below.
     */
    deleted: /^[-].*/m,
    inserted: /^\+.*/m,
    /*
     * a string (double and simple quote)
     */
    string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    /*
     * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
     * For instance:
     * $ git add file.txt
     */
    command: {
      pattern: /^.*\$ git .*$/m,
      inside: {
        /*
         * A git command can contain a parameter starting by a single or a double dash followed by a string
         * For instance:
         * $ git diff --cached
         * $ git log -p
         */
        parameter: /\s--?\w+/
      }
    },
    /*
     * Coordinates displayed in a git diff command
     * For instance:
     * $ git diff
     * diff --git file.txt file.txt
     * index 6214953..1d54a52 100644
     * --- file.txt
     * +++ file.txt
     * @@ -1 +1,2 @@
     * -Here's my tetx file
     * +Here's my text file
     * +And this is the second line
     */
    coord: /^@@.*@@$/m,
    /*
     * Match a "commit [SHA1]" line in a git log output.
     * For instance:
     * $ git log
     * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
     * Author: lgiraudel
     * Date:   Mon Feb 17 11:18:34 2014 +0100
     *
     *     Add of a new line
     */
    "commit-sha1": /^commit \w{40}$/m
  };
}
Ag.displayName = "glsl";
Ag.aliases = [];
function Ag(e) {
  e.register(jn), e.languages.glsl = e.languages.extend("c", {
    keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
  });
}
Ng.displayName = "gn";
Ng.aliases = ["gni"];
function Ng(e) {
  e.languages.gn = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    "string-literal": {
      pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
          lookbehind: !0,
          inside: {
            number: /^\$0x[\s\S]{2}$/,
            variable: /^\$\w+$/,
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            expression: {
              pattern: /[\s\S]+/,
              inside: null
              // see below
            }
          }
        },
        string: /[\s\S]+/
      }
    },
    keyword: /\b(?:else|if)\b/,
    boolean: /\b(?:false|true)\b/,
    "builtin-function": {
      // a few functions get special highlighting to improve readability
      pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
      alias: "keyword"
    },
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
    number: /-?\b\d+\b/,
    operator: /[-+!=<>]=?|&&|\|\|/,
    punctuation: /[(){}[\],.]/
  }, e.languages.gn["string-literal"].inside.interpolation.inside.expression.inside = e.languages.gn, e.languages.gni = e.languages.gn;
}
Rg.displayName = "linker-script";
Rg.aliases = ["ld"];
function Rg(e) {
  e.languages["linker-script"] = {
    comment: {
      pattern: /(^|\s)\/\*[\s\S]*?(?:$|\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    identifier: {
      pattern: /"[^"\r\n]*"/,
      greedy: !0
    },
    "location-counter": {
      pattern: /\B\.\B/,
      alias: "important"
    },
    section: {
      pattern: /(^|[^\w*])\.\w+\b/,
      lookbehind: !0,
      alias: "keyword"
    },
    function: /\b[A-Z][A-Z_]*(?=\s*\()/,
    number: /\b(?:0[xX][a-fA-F0-9]+|\d+)[KM]?\b/,
    operator: />>=?|<<=?|->|\+\+|--|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?/,
    punctuation: /[(){},;]/
  }, e.languages.ld = e.languages["linker-script"];
}
vg.displayName = "go";
vg.aliases = [];
function vg(e) {
  e.register(ze), e.languages.go = e.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|false|iota|nil|true)\b/,
    number: [
      // binary and octal integers
      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
      // hexadecimal integers and floats
      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      // decimal integers and floats
      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
  }), e.languages.insertBefore("go", "string", {
    char: {
      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
      greedy: !0
    }
  }), delete e.languages.go["class-name"];
}
Cg.displayName = "go-module";
Cg.aliases = ["go-mod"];
function Cg(e) {
  e.languages["go-mod"] = e.languages["go-module"] = {
    comment: {
      pattern: /\/\/.*/,
      greedy: !0
    },
    version: {
      pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
      lookbehind: !0,
      alias: "number"
    },
    "go-version": {
      pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
      lookbehind: !0,
      alias: "number"
    },
    keyword: {
      pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
      lookbehind: !0
    },
    operator: /=>/,
    punctuation: /[()[\],]/
  };
}
wg.displayName = "gradle";
wg.aliases = [];
function wg(e) {
  e.register(ze), (function(t) {
    var a = {
      pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
      lookbehind: !0,
      inside: {
        "interpolation-punctuation": {
          pattern: /^\$\{?|\}$/,
          alias: "punctuation"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: null
        }
      }
    };
    t.languages.gradle = t.languages.extend("clike", {
      string: {
        pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
        greedy: !0
      },
      keyword: /\b(?:apply|def|dependencies|else|if|implementation|import|plugin|plugins|project|repositories|repository|sourceSets|tasks|val)\b/,
      number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
      operator: {
        pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
        lookbehind: !0
      },
      punctuation: /\.+|[{}[\];(),:$]/
    }), t.languages.insertBefore("gradle", "string", {
      shebang: {
        pattern: /#!.+/,
        alias: "comment",
        greedy: !0
      },
      "interpolation-string": {
        pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
        greedy: !0,
        inside: {
          interpolation: a,
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("gradle", "punctuation", {
      "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    }), t.languages.insertBefore("gradle", "function", {
      annotation: {
        pattern: /(^|[^.])@\w+/,
        lookbehind: !0,
        alias: "punctuation"
      }
    }), a.inside.expression.inside = t.languages.gradle;
  })(e);
}
kg.displayName = "graphql";
kg.aliases = [];
function kg(e) {
  e.languages.graphql = {
    comment: /#.*/,
    description: {
      pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
      greedy: !0,
      alias: "string",
      inside: {
        "language-markdown": {
          pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
          lookbehind: !0,
          inside: e.languages.markdown
        }
      }
    },
    string: {
      pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
      greedy: !0
    },
    number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    boolean: /\b(?:false|true)\b/,
    variable: /\$[a-z_]\w*/i,
    directive: {
      pattern: /@[a-z_]\w*/i,
      alias: "function"
    },
    "attr-name": {
      pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
      greedy: !0
    },
    "atom-input": {
      pattern: /\b[A-Z]\w*Input\b/,
      alias: "class-name"
    },
    scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
    constant: /\b[A-Z][A-Z_\d]*\b/,
    "class-name": {
      pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
      lookbehind: !0
    },
    fragment: {
      pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
      lookbehind: !0,
      alias: "function"
    },
    "definition-mutation": {
      pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
      lookbehind: !0,
      alias: "function"
    },
    "definition-query": {
      pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
      lookbehind: !0,
      alias: "function"
    },
    keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
    operator: /[!=|&]|\.{3}/,
    "property-query": /\w+(?=\s*\()/,
    object: /\w+(?=\s*\{)/,
    punctuation: /[!(){}\[\]:=,]/,
    property: /\w+/
  }, e.hooks.add("after-tokenize", function(a) {
    if (a.language !== "graphql")
      return;
    var i = a.tokens.filter(function(R) {
      return typeof R != "string" && R.type !== "comment" && R.type !== "scalar";
    }), o = 0;
    function l(R) {
      return i[o + R];
    }
    function c(R, C) {
      C = C || 0;
      for (var L = 0; L < R.length; L++) {
        var x = l(L + C);
        if (!x || x.type !== R[L])
          return !1;
      }
      return !0;
    }
    function d(R, C) {
      for (var L = 1, x = o; x < i.length; x++) {
        var Y = i[x], q = Y.content;
        if (Y.type === "punctuation" && typeof q == "string") {
          if (R.test(q))
            L++;
          else if (C.test(q) && (L--, L === 0))
            return x;
        }
      }
      return -1;
    }
    function m(R, C) {
      var L = R.alias;
      L ? Array.isArray(L) || (R.alias = L = [L]) : R.alias = L = [], L.push(C);
    }
    for (; o < i.length; ) {
      var f = i[o++];
      if (f.type === "keyword" && f.content === "mutation") {
        var b = [];
        if (c(["definition-mutation", "punctuation"]) && l(1).content === "(") {
          o += 2;
          var E = d(/^\($/, /^\)$/);
          if (E === -1)
            continue;
          for (; o < E; o++) {
            var T = l(0);
            T.type === "variable" && (m(T, "variable-input"), b.push(T.content));
          }
          o = E + 1;
        }
        if (c(["punctuation", "property-query"]) && l(0).content === "{" && (o++, m(l(0), "property-mutation"), b.length > 0)) {
          var S = d(/^\{$/, /^\}$/);
          if (S === -1)
            continue;
          for (var _ = o; _ < S; _++) {
            var k = i[_];
            k.type === "variable" && b.indexOf(k.content) >= 0 && m(k, "variable-input");
          }
        }
      }
    }
  });
}
Ig.displayName = "groovy";
Ig.aliases = [];
function Ig(e) {
  e.register(ze), (function(t) {
    var a = {
      pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
      lookbehind: !0,
      inside: {
        "interpolation-punctuation": {
          pattern: /^\$\{?|\}$/,
          alias: "punctuation"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: null
          // see below
        }
      }
    };
    t.languages.groovy = t.languages.extend("clike", {
      string: {
        // https://groovy-lang.org/syntax.html#_dollar_slashy_string
        pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
        greedy: !0
      },
      keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
      number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
      operator: {
        pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
        lookbehind: !0
      },
      punctuation: /\.+|[{}[\];(),:$]/
    }), t.languages.insertBefore("groovy", "string", {
      shebang: {
        pattern: /#!.+/,
        alias: "comment",
        greedy: !0
      },
      "interpolation-string": {
        // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
        // simple division (see JS regex), so find a fix maybe?
        pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
        greedy: !0,
        inside: {
          interpolation: a,
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("groovy", "punctuation", {
      "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    }), t.languages.insertBefore("groovy", "function", {
      annotation: {
        pattern: /(^|[^.])@\w+/,
        lookbehind: !0,
        alias: "punctuation"
      }
    }), a.inside.expression.inside = t.languages.groovy;
  })(e);
}
Og.displayName = "less";
Og.aliases = [];
function Og(e) {
  e.register(Sr), e.languages.less = e.languages.extend("css", {
    comment: [
      /\/\*[\s\S]*?\*\//,
      {
        pattern: /(^|[^\\])\/\/.*/,
        lookbehind: !0
      }
    ],
    atrule: {
      pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        punctuation: /[:()]/
      }
    },
    // selectors and mixins are considered the same
    selector: {
      pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        // mixin parameters
        variable: /@+[\w-]+/
      }
    },
    property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
    operator: /[+\-*\/]/
  }), e.languages.insertBefore("less", "property", {
    variable: [
      // Variable declaration (the colon must be consumed!)
      {
        pattern: /@[\w-]+\s*:/,
        inside: {
          punctuation: /:/
        }
      },
      // Variable usage
      /@@?[\w-]+/
    ],
    "mixin-usage": {
      pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
      lookbehind: !0,
      alias: "function"
    }
  });
}
xg.displayName = "scss";
xg.aliases = [];
function xg(e) {
  e.register(Sr), e.languages.scss = e.languages.extend("css", {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: !0
    },
    atrule: {
      pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
      inside: {
        rule: /@[\w-]+/
        // See rest below
      }
    },
    // url, compassified
    url: /(?:[-a-z]+-)?url(?=\()/i,
    // CSS selector regex is not appropriate for Sass
    // since there can be lot more things (var, @ directive, nesting..)
    // a selector must start at the end of a property or after a brace (end of other rules or nesting)
    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
    // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
    // can "pass" as a selector- e.g: proper#{$erty})
    // this one was hard to do, so please be careful if you edit this one :)
    selector: {
      // Initial look-ahead is used to prevent matching of blank selectors
      pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
      inside: {
        parent: {
          pattern: /&/,
          alias: "important"
        },
        placeholder: /%[-\w]+/,
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
      }
    },
    property: {
      pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
      inside: {
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
      }
    }
  }), e.languages.insertBefore("scss", "atrule", {
    keyword: [
      /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
      {
        pattern: /( )(?:from|through)(?= )/,
        lookbehind: !0
      }
    ]
  }), e.languages.insertBefore("scss", "important", {
    // var and interpolated vars
    variable: /\$[-\w]+|#\{\$[-\w]+\}/
  }), e.languages.insertBefore("scss", "function", {
    "module-modifier": {
      pattern: /\b(?:as|hide|show|with)\b/i,
      alias: "keyword"
    },
    placeholder: {
      pattern: /%[-\w]+/,
      alias: "selector"
    },
    statement: {
      pattern: /\B!(?:default|optional)\b/i,
      alias: "keyword"
    },
    boolean: /\b(?:false|true)\b/,
    null: {
      pattern: /\bnull\b/,
      alias: "keyword"
    },
    operator: {
      pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
      lookbehind: !0
    }
  }), e.languages.scss.atrule.inside.rest = e.languages.scss;
}
Lg.displayName = "textile";
Lg.aliases = [];
function Lg(e) {
  e.register(xt), (function(t) {
    var a = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source, i = /\)|\((?![^|()\n]+\))/.source;
    function o(E, T) {
      return RegExp(
        E.replace(/<MOD>/g, function() {
          return "(?:" + a + ")";
        }).replace(/<PAR>/g, function() {
          return "(?:" + i + ")";
        }),
        T || ""
      );
    }
    var l = {
      css: {
        pattern: /\{[^{}]+\}/,
        inside: {
          rest: t.languages.css
        }
      },
      "class-id": {
        pattern: /(\()[^()]+(?=\))/,
        lookbehind: !0,
        alias: "attr-value"
      },
      lang: {
        pattern: /(\[)[^\[\]]+(?=\])/,
        lookbehind: !0,
        alias: "attr-value"
      },
      // Anything else is punctuation (the first pattern is for row/col spans inside tables)
      punctuation: /[\\\/]\d+|\S/
    }, c = t.languages.textile = t.languages.extend("markup", {
      phrase: {
        pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
        lookbehind: !0,
        inside: {
          // h1. Header 1
          "block-tag": {
            pattern: o(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
            inside: {
              modifier: {
                pattern: o(
                  /(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source
                ),
                lookbehind: !0,
                inside: l
              },
              tag: /^[a-z]\w*/,
              punctuation: /\.$/
            }
          },
          // # List item
          // * List item
          list: {
            pattern: o(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
            inside: {
              modifier: {
                pattern: o(/(^[*#]+)<MOD>+/.source),
                lookbehind: !0,
                inside: l
              },
              punctuation: /^[*#]+/
            }
          },
          // | cell | cell | cell |
          table: {
            // Modifiers can be applied to the row: {color:red}.|1|2|3|
            // or the cell: |{color:red}.1|2|3|
            pattern: o(
              /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source,
              "m"
            ),
            inside: {
              modifier: {
                // Modifiers for rows after the first one are
                // preceded by a pipe and a line feed
                pattern: o(
                  /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
                ),
                lookbehind: !0,
                inside: l
              },
              punctuation: /\||^\./
            }
          },
          inline: {
            // eslint-disable-next-line regexp/no-super-linear-backtracking
            pattern: o(
              /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
            ),
            lookbehind: !0,
            inside: {
              // Note: superscripts and subscripts are not handled specifically
              // *bold*, **bold**
              bold: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                lookbehind: !0
              },
              // _italic_, __italic__
              italic: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^(__?)<MOD>*).+?(?=\2)/.source),
                lookbehind: !0
              },
              // ??cite??
              cite: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                lookbehind: !0,
                alias: "string"
              },
              // @code@
              code: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^@<MOD>*).+?(?=@)/.source),
                lookbehind: !0,
                alias: "keyword"
              },
              // +inserted+
              inserted: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^\+<MOD>*).+?(?=\+)/.source),
                lookbehind: !0
              },
              // -deleted-
              deleted: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^-<MOD>*).+?(?=-)/.source),
                lookbehind: !0
              },
              // %span%
              span: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^%<MOD>*).+?(?=%)/.source),
                lookbehind: !0
              },
              modifier: {
                pattern: o(
                  /(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source
                ),
                lookbehind: !0,
                inside: l
              },
              punctuation: /[*_%?@+\-^~]+/
            }
          },
          // [alias]http://example.com
          "link-ref": {
            pattern: /^\[[^\]]+\]\S+$/m,
            inside: {
              string: {
                pattern: /(^\[)[^\]]+(?=\])/,
                lookbehind: !0
              },
              url: {
                pattern: /(^\])\S+$/,
                lookbehind: !0
              },
              punctuation: /[\[\]]/
            }
          },
          // "text":http://example.com
          // "text":link-ref
          link: {
            // eslint-disable-next-line regexp/no-super-linear-backtracking
            pattern: o(
              /"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source
            ),
            inside: {
              text: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: o(/(^"<MOD>*)[^"]+(?=")/.source),
                lookbehind: !0
              },
              modifier: {
                pattern: o(/(^")<MOD>+/.source),
                lookbehind: !0,
                inside: l
              },
              url: {
                pattern: /(:).+/,
                lookbehind: !0
              },
              punctuation: /[":]/
            }
          },
          // !image.jpg!
          // !image.jpg(Title)!:http://example.com
          image: {
            pattern: o(
              /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source
            ),
            inside: {
              source: {
                pattern: o(
                  /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
                ),
                lookbehind: !0,
                alias: "url"
              },
              modifier: {
                pattern: o(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                lookbehind: !0,
                inside: l
              },
              url: {
                pattern: /(:).+/,
                lookbehind: !0
              },
              punctuation: /[!:]/
            }
          },
          // Footnote[1]
          footnote: {
            pattern: /\b\[\d+\]/,
            alias: "comment",
            inside: {
              punctuation: /\[|\]/
            }
          },
          // CSS(Cascading Style Sheet)
          acronym: {
            pattern: /\b[A-Z\d]+\([^)]+\)/,
            inside: {
              comment: {
                pattern: /(\()[^()]+(?=\))/,
                lookbehind: !0
              },
              punctuation: /[()]/
            }
          },
          // Prism(C)
          mark: {
            pattern: /\b\((?:C|R|TM)\)/,
            alias: "comment",
            inside: {
              punctuation: /[()]/
            }
          }
        }
      }
    }), d = c.phrase.inside, m = {
      inline: d.inline,
      link: d.link,
      image: d.image,
      footnote: d.footnote,
      acronym: d.acronym,
      mark: d.mark
    };
    c.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
    var f = d.inline.inside;
    f.bold.inside = m, f.italic.inside = m, f.inserted.inside = m, f.deleted.inside = m, f.span.inside = m;
    var b = d.table.inside;
    b.inline = m.inline, b.link = m.link, b.image = m.image, b.footnote = m.footnote, b.acronym = m.acronym, b.mark = m.mark;
  })(e);
}
Dg.displayName = "haml";
Dg.aliases = [];
function Dg(e) {
  e.register(wi), (function(t) {
    t.languages.haml = {
      // Multiline stuff should appear before the rest
      "multiline-comment": {
        pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
        lookbehind: !0,
        alias: "comment"
      },
      "multiline-code": [
        {
          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
          lookbehind: !0,
          inside: t.languages.ruby
        },
        {
          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
          lookbehind: !0,
          inside: t.languages.ruby
        }
      ],
      // See at the end of the file for known filters
      filter: {
        pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
        lookbehind: !0,
        inside: {
          "filter-name": {
            pattern: /^:[\w-]+/,
            alias: "symbol"
          }
        }
      },
      markup: {
        pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
        lookbehind: !0,
        inside: t.languages.markup
      },
      doctype: {
        pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
        lookbehind: !0
      },
      tag: {
        // Allows for one nested group of braces
        pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
        lookbehind: !0,
        inside: {
          attributes: [
            {
              // Lookbehind tries to prevent interpolations from breaking it all
              // Allows for one nested group of braces
              pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
              lookbehind: !0,
              inside: t.languages.ruby
            },
            {
              pattern: /\([^)]+\)/,
              inside: {
                "attr-value": {
                  pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                  lookbehind: !0
                },
                "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                punctuation: /[=(),]/
              }
            },
            {
              pattern: /\[[^\]]+\]/,
              inside: t.languages.ruby
            }
          ],
          punctuation: /[<>]/
        }
      },
      code: {
        pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
        lookbehind: !0,
        inside: t.languages.ruby
      },
      // Interpolations in plain text
      interpolation: {
        pattern: /#\{[^}]+\}/,
        inside: {
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          },
          ruby: {
            pattern: /[\s\S]+/,
            inside: t.languages.ruby
          }
        }
      },
      punctuation: {
        pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
        lookbehind: !0
      }
    };
    for (var a = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+", i = [
      "css",
      {
        filter: "coffee",
        language: "coffeescript"
      },
      "erb",
      "javascript",
      "less",
      "markdown",
      "ruby",
      "scss",
      "textile"
    ], o = {}, l = 0, c = i.length; l < c; l++) {
      var d = i[l];
      d = typeof d == "string" ? {
        filter: d,
        language: d
      } : d, t.languages[d.language] && (o["filter-" + d.filter] = {
        pattern: RegExp(
          a.replace("{{filter_name}}", function() {
            return d.filter;
          })
        ),
        lookbehind: !0,
        inside: {
          "filter-name": {
            pattern: /^:[\w-]+/,
            alias: "symbol"
          },
          text: {
            pattern: /[\s\S]+/,
            alias: [d.language, "language-" + d.language],
            inside: t.languages[d.language]
          }
        }
      });
    }
    t.languages.insertBefore("haml", "filter", o);
  })(e);
}
Mg.displayName = "handlebars";
Mg.aliases = ["hbs", "mustache"];
function Mg(e) {
  e.register(Ft), (function(t) {
    t.languages.handlebars = {
      comment: /\{\{![\s\S]*?\}\}/,
      delimiter: {
        pattern: /^\{\{\{?|\}\}\}?$/,
        alias: "punctuation"
      },
      string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
      boolean: /\b(?:false|true)\b/,
      block: {
        pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
        lookbehind: !0,
        alias: "keyword"
      },
      brackets: {
        pattern: /\[[^\]]+\]/,
        inside: {
          punctuation: /\[|\]/,
          variable: /[\s\S]+/
        }
      },
      punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
      variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
    }, t.hooks.add("before-tokenize", function(a) {
      var i = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
      t.languages["markup-templating"].buildPlaceholders(
        a,
        "handlebars",
        i
      );
    }), t.hooks.add("after-tokenize", function(a) {
      t.languages["markup-templating"].tokenizePlaceholders(
        a,
        "handlebars"
      );
    }), t.languages.hbs = t.languages.handlebars, t.languages.mustache = t.languages.handlebars;
  })(e);
}
po.displayName = "haskell";
po.aliases = ["hs"];
function po(e) {
  e.languages.haskell = {
    comment: {
      pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
      lookbehind: !0
    },
    char: {
      pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
      alias: "string"
    },
    string: {
      pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
      greedy: !0
    },
    keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
    "import-statement": {
      // The imported or hidden names are not included in this import
      // statement. This is because we want to highlight those exactly like
      // we do for the names in the program.
      pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
      lookbehind: !0,
      inside: {
        keyword: /\b(?:as|hiding|import|qualified)\b/,
        punctuation: /\./
      }
    },
    // These are builtin variables only. Constructors are highlighted later as a constant.
    builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
    // decimal integers and floating point numbers | octal integers | hexadecimal integers
    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
    operator: [
      {
        // infix operator
        pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
        greedy: !0
      },
      {
        // function composition
        pattern: /(\s)\.(?=\s)/,
        lookbehind: !0
      },
      // Most of this is needed because of the meaning of a single '.'.
      // If it stands alone freely, it is the function composition.
      // It may also be a separator between a module name and an identifier => no
      // operator. If it comes together with other special characters it is an
      // operator too.
      //
      // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
      /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
    ],
    // In Haskell, nearly everything is a variable, do not highlight these.
    hvariable: {
      pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
      inside: {
        punctuation: /\./
      }
    },
    constant: {
      pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
      inside: {
        punctuation: /\./
      }
    },
    punctuation: /[{}[\];(),.:]/
  }, e.languages.hs = e.languages.haskell;
}
Ug.displayName = "haxe";
Ug.aliases = [];
function Ug(e) {
  e.register(ze), e.languages.haxe = e.languages.extend("clike", {
    string: {
      // Strings can be multi-line
      pattern: /"(?:[^"\\]|\\[\s\S])*"/,
      greedy: !0
    },
    "class-name": [
      {
        pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
        lookbehind: !0
      },
      // based on naming convention
      /\b[A-Z]\w*/
    ],
    // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
    keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
    function: {
      pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
      greedy: !0
    },
    operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
  }), e.languages.insertBefore("haxe", "string", {
    "string-interpolation": {
      pattern: /'(?:[^'\\]|\\[\s\S])*'/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{?|\}$/,
              alias: "punctuation"
            },
            expression: {
              pattern: /[\s\S]+/,
              inside: e.languages.haxe
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  }), e.languages.insertBefore("haxe", "class-name", {
    regex: {
      pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
      greedy: !0,
      inside: {
        "regex-flags": /\b[a-z]+$/,
        "regex-source": {
          pattern: /^(~\/)[\s\S]+(?=\/$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: e.languages.regex
        },
        "regex-delimiter": /^~\/|\/$/
      }
    }
  }), e.languages.insertBefore("haxe", "keyword", {
    preprocessor: {
      pattern: /#(?:else|elseif|end|if)\b.*/,
      alias: "property"
    },
    metadata: {
      pattern: /@:?[\w.]+/,
      alias: "symbol"
    },
    reification: {
      pattern: /\$(?:\w+|(?=\{))/,
      alias: "important"
    }
  });
}
Bg.displayName = "hcl";
Bg.aliases = [];
function Bg(e) {
  e.languages.hcl = {
    comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
    heredoc: {
      pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
      greedy: !0,
      alias: "string"
    },
    keyword: [
      {
        pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
        inside: {
          type: {
            pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
            lookbehind: !0,
            alias: "variable"
          }
        }
      },
      {
        pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
        inside: {
          type: {
            pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
            lookbehind: !0,
            alias: "variable"
          }
        }
      },
      /[\w-]+(?=\s+\{)/
    ],
    property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
    string: {
      pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
          lookbehind: !0,
          inside: {
            type: {
              pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
              lookbehind: !0,
              alias: "variable"
            },
            keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
            function: /\w+(?=\()/,
            string: {
              pattern: /"(?:\\[\s\S]|[^\\"])*"/,
              greedy: !0
            },
            number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
            punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
          }
        }
      }
    },
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
    boolean: /\b(?:false|true)\b/i,
    punctuation: /[=\[\]{}]/
  };
}
Fg.displayName = "hlsl";
Fg.aliases = [];
function Fg(e) {
  e.register(jn), e.languages.hlsl = e.languages.extend("c", {
    // Regarding keywords and class names:
    // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
    "class-name": [
      e.languages.c["class-name"],
      /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
    ],
    keyword: [
      // HLSL keyword
      /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
      // scalar, vector, and matrix types
      /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
    ],
    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
    number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
    boolean: /\b(?:false|true)\b/
  });
}
Pg.displayName = "hoon";
Pg.aliases = [];
function Pg(e) {
  e.languages.hoon = {
    comment: {
      pattern: /::.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/,
      greedy: !0
    },
    constant: /%(?:\.[ny]|[\w-]+)/,
    "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
    function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
    keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
  };
}
Hg.displayName = "hpkp";
Hg.aliases = [];
function Hg(e) {
  e.languages.hpkp = {
    directive: {
      pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
      alias: "property"
    },
    operator: /=/,
    punctuation: /;/
  };
}
zg.displayName = "hsts";
zg.aliases = [];
function zg(e) {
  e.languages.hsts = {
    directive: {
      pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
      alias: "property"
    },
    operator: /=/,
    punctuation: /;/
  };
}
fo.displayName = "json";
fo.aliases = ["webmanifest"];
function fo(e) {
  e.languages.json = {
    property: {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
      lookbehind: !0,
      greedy: !0
    },
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    punctuation: /[{}[\],]/,
    operator: /:/,
    boolean: /\b(?:false|true)\b/,
    null: {
      pattern: /\bnull\b/,
      alias: "keyword"
    }
  }, e.languages.webmanifest = e.languages.json;
}
Gg.displayName = "uri";
Gg.aliases = ["url"];
function Gg(e) {
  e.languages.uri = {
    scheme: {
      pattern: /^[a-z][a-z0-9+.-]*:/im,
      greedy: !0,
      inside: {
        "scheme-delimiter": /:$/
      }
    },
    fragment: {
      pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
      inside: {
        "fragment-delimiter": /^#/
      }
    },
    query: {
      pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
      inside: {
        "query-delimiter": {
          pattern: /^\?/,
          greedy: !0
        },
        "pair-delimiter": /[&;]/,
        pair: {
          pattern: /^[^=][\s\S]*/,
          inside: {
            key: /^[^=]+/,
            value: {
              pattern: /(^=)[\s\S]+/,
              lookbehind: !0
            }
          }
        }
      }
    },
    authority: {
      pattern: RegExp(
        /^\/\//.source + // [ userinfo "@" ]
        /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
        ("(?:" + // IP-literal
        /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
        /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
        /(?::\d*)?/.source,
        "m"
      ),
      inside: {
        "authority-delimiter": /^\/\//,
        "user-info-segment": {
          pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
          inside: {
            "user-info-delimiter": /@$/,
            "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
          }
        },
        "port-segment": {
          pattern: /:\d*$/,
          inside: {
            "port-delimiter": /^:/,
            port: /^\d+/
          }
        },
        host: {
          pattern: /[\s\S]+/,
          inside: {
            "ip-literal": {
              pattern: /^\[[\s\S]+\]$/,
              inside: {
                "ip-literal-delimiter": /^\[|\]$/,
                "ipv-future": /^v[\s\S]+/,
                "ipv6-address": /^[\s\S]+/
              }
            },
            "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
          }
        }
      }
    },
    path: {
      pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
      inside: {
        "path-separator": /\//
      }
    }
  }, e.languages.url = e.languages.uri;
}
jg.displayName = "http";
jg.aliases = [];
function jg(e) {
  (function(t) {
    function a(b) {
      return RegExp("(^(?:" + b + "):[ 	]*(?![ 	]))[^]+", "i");
    }
    t.languages.http = {
      "request-line": {
        pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
        inside: {
          // HTTP Method
          method: {
            pattern: /^[A-Z]+\b/,
            alias: "property"
          },
          // Request Target e.g. http://example.com, /path/to/file
          "request-target": {
            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
            lookbehind: !0,
            alias: "url",
            inside: t.languages.uri
          },
          // HTTP Version
          "http-version": {
            pattern: /^(\s)HTTP\/[\d.]+/,
            lookbehind: !0,
            alias: "property"
          }
        }
      },
      "response-status": {
        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
        inside: {
          // HTTP Version
          "http-version": {
            pattern: /^HTTP\/[\d.]+/,
            alias: "property"
          },
          // Status Code
          "status-code": {
            pattern: /^(\s)\d+(?=\s)/,
            lookbehind: !0,
            alias: "number"
          },
          // Reason Phrase
          "reason-phrase": {
            pattern: /^(\s).+/,
            lookbehind: !0,
            alias: "string"
          }
        }
      },
      header: {
        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
        inside: {
          "header-value": [
            {
              pattern: a(/Content-Security-Policy/.source),
              lookbehind: !0,
              alias: ["csp", "languages-csp"],
              inside: t.languages.csp
            },
            {
              pattern: a(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: !0,
              alias: ["hpkp", "languages-hpkp"],
              inside: t.languages.hpkp
            },
            {
              pattern: a(/Strict-Transport-Security/.source),
              lookbehind: !0,
              alias: ["hsts", "languages-hsts"],
              inside: t.languages.hsts
            },
            {
              pattern: a(/[^:]+/.source),
              lookbehind: !0
            }
          ],
          "header-name": {
            pattern: /^[^:]+/,
            alias: "keyword"
          },
          punctuation: /^:/
        }
      }
    };
    var i = t.languages, o = {
      "application/javascript": i.javascript,
      "application/json": i.json || i.javascript,
      "application/xml": i.xml,
      "text/xml": i.xml,
      "text/html": i.html,
      "text/css": i.css,
      "text/plain": i.plain
    }, l = {
      "application/json": !0,
      "application/xml": !0
    };
    function c(b) {
      var E = b.replace(/^[a-z]+\//, ""), T = "\\w+/(?:[\\w.-]+\\+)+" + E + "(?![+\\w.-])";
      return "(?:" + b + "|" + T + ")";
    }
    var d;
    for (var m in o)
      if (o[m]) {
        d = d || {};
        var f = l[m] ? c(m) : m;
        d[m.replace(/\//g, "-")] = {
          pattern: RegExp(
            "(" + /content-type:\s*/.source + f + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source,
            "i"
          ),
          lookbehind: !0,
          inside: o[m]
        };
      }
    d && t.languages.insertBefore("http", "header", d);
  })(e);
}
$g.displayName = "ichigojam";
$g.aliases = [];
function $g(e) {
  e.languages.ichigojam = {
    comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
    string: {
      pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
      greedy: !0
    },
    number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
    function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
    label: /(?:\B@\S+)/,
    operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
    punctuation: /[\[,;:()\]]/
  };
}
qg.displayName = "icon";
qg.aliases = [];
function qg(e) {
  e.languages.icon = {
    comment: /#.*/,
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
      greedy: !0
    },
    number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
    "builtin-keyword": {
      pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
      alias: "variable"
    },
    directive: {
      pattern: /\$\w+/,
      alias: "builtin"
    },
    keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
    function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
    operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
    punctuation: /[\[\](){},;]/
  };
}
Yg.displayName = "icu-message-format";
Yg.aliases = [];
function Yg(e) {
  (function(t) {
    function a(m, f) {
      return f <= 0 ? /[]/.source : m.replace(/<SELF>/g, function() {
        return a(m, f - 1);
      });
    }
    var i = /'[{}:=,](?:[^']|'')*'(?!')/, o = {
      pattern: /''/,
      greedy: !0,
      alias: "operator"
    }, l = {
      pattern: i,
      greedy: !0,
      inside: {
        escape: o
      }
    }, c = a(
      /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
        /<STR>/g,
        function() {
          return i.source;
        }
      ),
      8
    ), d = {
      pattern: RegExp(c),
      inside: {
        message: {
          pattern: /^(\{)[\s\S]+(?=\}$)/,
          lookbehind: !0,
          inside: null
          // see below
        },
        "message-delimiter": {
          pattern: /./,
          alias: "punctuation"
        }
      }
    };
    t.languages["icu-message-format"] = {
      argument: {
        pattern: RegExp(c),
        greedy: !0,
        inside: {
          content: {
            pattern: /^(\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: {
              "argument-name": {
                pattern: /^(\s*)[^{}:=,\s]+/,
                lookbehind: !0
              },
              "choice-style": {
                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                lookbehind: !0,
                inside: {
                  punctuation: /\|/,
                  range: {
                    pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                    lookbehind: !0,
                    inside: {
                      operator: /[<#\u2264]/,
                      number: /\S+/
                    }
                  },
                  rest: null
                  // see below
                }
              },
              "plural-style": {
                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                lookbehind: !0,
                inside: {
                  offset: /^offset:\s*\d+/,
                  "nested-message": d,
                  selector: {
                    pattern: /=\d+|[^{}:=,\s]+/,
                    inside: {
                      keyword: /^(?:few|many|one|other|two|zero)$/
                    }
                  }
                }
              },
              "select-style": {
                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                lookbehind: !0,
                inside: {
                  "nested-message": d,
                  selector: {
                    pattern: /[^{}:=,\s]+/,
                    inside: {
                      keyword: /^other$/
                    }
                  }
                }
              },
              keyword: /\b(?:choice|plural|select|selectordinal)\b/,
              "arg-type": {
                pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                alias: "keyword"
              },
              "arg-skeleton": {
                pattern: /(,\s*)::[^{}:=,\s]+/,
                lookbehind: !0
              },
              "arg-style": {
                pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                lookbehind: !0
              },
              "arg-style-text": {
                pattern: RegExp(
                  /(^\s*,\s*(?=\S))/.source + a(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
                ),
                lookbehind: !0,
                alias: "string"
              },
              punctuation: /,/
            }
          },
          "argument-delimiter": {
            pattern: /./,
            alias: "operator"
          }
        }
      },
      escape: o,
      string: l
    }, d.inside.message.inside = t.languages["icu-message-format"], t.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = t.languages["icu-message-format"];
  })(e);
}
Vg.displayName = "idris";
Vg.aliases = ["idr"];
function Vg(e) {
  e.register(po), e.languages.idris = e.languages.extend("haskell", {
    comment: {
      pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
    },
    keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
    builtin: void 0
  }), e.languages.insertBefore("idris", "keyword", {
    "import-statement": {
      pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
      lookbehind: !0,
      inside: {
        punctuation: /\./
      }
    }
  }), e.languages.idr = e.languages.idris;
}
Wg.displayName = "ignore";
Wg.aliases = ["gitignore", "hgignore", "npmignore"];
function Wg(e) {
  (function(t) {
    t.languages.ignore = {
      // https://git-scm.com/docs/gitignore
      comment: /^#.*/m,
      entry: {
        pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
        alias: "string",
        inside: {
          operator: /^!|\*\*?|\?/,
          regex: {
            pattern: /(^|[^\\])\[[^\[\]]*\]/,
            lookbehind: !0
          },
          punctuation: /\//
        }
      }
    }, t.languages.gitignore = t.languages.ignore, t.languages.hgignore = t.languages.ignore, t.languages.npmignore = t.languages.ignore;
  })(e);
}
Xg.displayName = "inform7";
Xg.aliases = [];
function Xg(e) {
  e.languages.inform7 = {
    string: {
      pattern: /"[^"]*"/,
      inside: {
        substitution: {
          pattern: /\[[^\[\]]+\]/,
          inside: {
            delimiter: {
              pattern: /\[|\]/,
              alias: "punctuation"
            }
            // See rest below
          }
        }
      }
    },
    comment: {
      pattern: /\[[^\[\]]+\]/,
      greedy: !0
    },
    title: {
      pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
      alias: "important"
    },
    number: {
      pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
      lookbehind: !0
    },
    verb: {
      pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
      lookbehind: !0,
      alias: "operator"
    },
    keyword: {
      pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
      lookbehind: !0
    },
    property: {
      pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
      lookbehind: !0,
      alias: "symbol"
    },
    position: {
      pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
      lookbehind: !0,
      alias: "keyword"
    },
    type: {
      pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
      lookbehind: !0,
      alias: "variable"
    },
    punctuation: /[.,:;(){}]/
  }, e.languages.inform7.string.inside.substitution.inside.rest = e.languages.inform7, e.languages.inform7.string.inside.substitution.inside.rest.text = {
    pattern: /\S(?:\s*\S)*/,
    alias: "comment"
  };
}
Kg.displayName = "ini";
Kg.aliases = [];
function Kg(e) {
  e.languages.ini = {
    /**
     * The component mimics the behavior of the Win32 API parser.
     *
     * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
     */
    comment: {
      pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
      lookbehind: !0
    },
    section: {
      pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
      lookbehind: !0,
      inside: {
        "section-name": {
          pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
          lookbehind: !0,
          alias: "selector"
        },
        punctuation: /\[|\]/
      }
    },
    key: {
      pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
      lookbehind: !0,
      alias: "attr-name"
    },
    value: {
      pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
      lookbehind: !0,
      alias: "attr-value",
      inside: {
        "inner-value": {
          pattern: /^("|').+(?=\1$)/,
          lookbehind: !0
        }
      }
    },
    punctuation: /=/
  };
}
Zg.displayName = "io";
Zg.aliases = [];
function Zg(e) {
  e.languages.io = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
      lookbehind: !0,
      greedy: !0
    },
    "triple-quoted-string": {
      pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /"(?:\\.|[^\\\r\n"])*"/,
      greedy: !0
    },
    keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
    builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
    boolean: /\b(?:false|nil|true)\b/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
    operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
    punctuation: /[{}[\];(),.:]/
  };
}
Qg.displayName = "j";
Qg.aliases = [];
function Qg(e) {
  e.languages.j = {
    comment: {
      pattern: /\bNB\..*/,
      greedy: !0
    },
    string: {
      pattern: /'(?:''|[^'\r\n])*'/,
      greedy: !0
    },
    keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
    verb: {
      // Negative look-ahead prevents bad highlighting
      // of ^: ;. =. =: !. !:
      pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
      alias: "keyword"
    },
    number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
    adverb: {
      pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
      alias: "builtin"
    },
    operator: /[=a][.:]|_\./,
    conjunction: {
      pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
      alias: "variable"
    },
    punctuation: /[()]/
  };
}
ki.displayName = "java";
ki.aliases = [];
function ki(e) {
  e.register(ze), (function(t) {
    var a = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, i = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, o = {
      pattern: RegExp(
        /(^|[^\w.])/.source + i + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source
      ),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    t.languages.java = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [
        o,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(
            /(^|[^\w.])/.source + i + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source
          ),
          lookbehind: !0,
          inside: o.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(
            /(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + i + /[A-Z]\w*\b/.source
          ),
          lookbehind: !0,
          inside: o.inside
        }
      ],
      keyword: a,
      function: [
        t.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), t.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: !0,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: !0
      }
    }), t.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: !0,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": o,
          keyword: a,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(
            /(\bimport\s+)/.source + i + /(?:[A-Z]\w*|\*)(?=\s*;)/.source
          ),
          lookbehind: !0,
          inside: {
            namespace: o.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(
            /(\bimport\s+static\s+)/.source + i + /(?:\w+|\*)(?=\s*;)/.source
          ),
          lookbehind: !0,
          alias: "static",
          inside: {
            namespace: o.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
            /<keyword>/g,
            function() {
              return a.source;
            }
          )
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    });
  })(e);
}
Ii.displayName = "php";
Ii.aliases = [];
function Ii(e) {
  e.register(Ft), (function(t) {
    var a = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, i = [
      {
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      },
      {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: !0,
        lookbehind: !0
      },
      {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: !0,
        lookbehind: !0
      },
      /\b(?:null)\b/i,
      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ], o = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, l = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, c = /[{}\[\](),:;]/;
    t.languages.php = {
      delimiter: {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      comment: a,
      variable: /\$+(?:\w+\b|(?=\{))/,
      package: {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [
        {
          pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
          alias: "type-casting",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
          alias: "type-declaration",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          // yield from
          pattern: /(\byield\s+)from\b/i,
          lookbehind: !0
        },
        // `class` is always a keyword unlike other keywords
        /\bclass\b/i,
        {
          // https://www.php.net/manual/en/reserved.keywords.php
          //
          // keywords cannot be preceded by "->"
          // the complex lookbehind means `(?<!(?:->|::)\s*)`
          pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
          lookbehind: !0
        }
      ],
      "argument-name": {
        pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: !0
        },
        {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        },
        {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }
      ],
      constant: i,
      function: {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      property: {
        pattern: /(->\s*)\w+/,
        lookbehind: !0
      },
      number: o,
      operator: l,
      punctuation: c
    };
    var d = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: !0,
      inside: t.languages.php
    }, m = [
      {
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<'?|[';]$/
            }
          }
        }
      },
      {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<"?|[";]$/
            }
          },
          interpolation: d
        }
      },
      {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: !0
      },
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: !0
      },
      {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: !0,
        inside: {
          interpolation: d
        }
      }
    ];
    t.languages.insertBefore("php", "variable", {
      string: m,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            // inside can appear subset of php
            inside: {
              comment: a,
              string: m,
              "attribute-class-name": [
                {
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: !0,
                  lookbehind: !0
                },
                {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: ["class-name", "class-name-fully-qualified"],
                  greedy: !0,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\\/
                  }
                }
              ],
              constant: i,
              number: o,
              operator: l,
              punctuation: c
            }
          },
          delimiter: {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    }), t.hooks.add("before-tokenize", function(f) {
      if (/<\?/.test(f.code)) {
        var b = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        t.languages["markup-templating"].buildPlaceholders(
          f,
          "php",
          b
        );
      }
    }), t.hooks.add("after-tokenize", function(f) {
      t.languages["markup-templating"].tokenizePlaceholders(f, "php");
    });
  })(e);
}
Oi.displayName = "javadoclike";
Oi.aliases = [];
function Oi(e) {
  (function(t) {
    var a = t.languages.javadoclike = {
      parameter: {
        pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
        lookbehind: !0
      },
      keyword: {
        // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
        // @word, {@word}
        pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
        lookbehind: !0
      },
      punctuation: /[{}]/
    };
    function i(l, c) {
      var d = "doc-comment", m = t.languages[l];
      if (m) {
        var f = m[d];
        if (!f) {
          var b = {};
          b[d] = {
            pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
            lookbehind: !0,
            alias: "comment"
          }, m = t.languages.insertBefore(l, "comment", b), f = m[d];
        }
        if (f instanceof RegExp && (f = m[d] = {
          pattern: f
        }), Array.isArray(f))
          for (var E = 0, T = f.length; E < T; E++)
            f[E] instanceof RegExp && (f[E] = {
              pattern: f[E]
            }), c(f[E]);
        else
          c(f);
      }
    }
    function o(l, c) {
      typeof l == "string" && (l = [l]), l.forEach(function(d) {
        i(d, function(m) {
          m.inside || (m.inside = {}), m.inside.rest = c;
        });
      });
    }
    Object.defineProperty(a, "addSupport", {
      value: o
    }), a.addSupport(["java", "javascript", "php"], a);
  })(e);
}
Jg.displayName = "scala";
Jg.aliases = [];
function Jg(e) {
  e.register(ki), e.languages.scala = e.languages.extend("java", {
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: /<-|=>|\b(?:abstract|case|catch|class|def|derives|do|else|enum|extends|extension|final|finally|for|forSome|given|if|implicit|import|infix|inline|lazy|match|new|null|object|opaque|open|override|package|private|protected|return|sealed|self|super|this|throw|trait|transparent|try|type|using|val|var|while|with|yield)\b/,
    number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
    builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
    symbol: /'[^\d\s\\]\w*/
  }), e.languages.insertBefore("scala", "triple-quoted-string", {
    "string-interpolation": {
      pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
      greedy: !0,
      inside: {
        id: {
          pattern: /^\w+/,
          greedy: !0,
          alias: "function"
        },
        escape: {
          pattern: /\\\$"|\$[$"]/,
          greedy: !0,
          alias: "symbol"
        },
        interpolation: {
          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          greedy: !0,
          inside: {
            punctuation: /^\$\{?|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: e.languages.scala
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  }), delete e.languages.scala["class-name"], delete e.languages.scala.function, delete e.languages.scala.constant;
}
eh.displayName = "javadoc";
eh.aliases = [];
function eh(e) {
  e.register(ki), e.register(Oi), e.register(xt), (function(t) {
    var a = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m, i = /#\s*\w+(?:\s*\([^()]*\))?/.source, o = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
      /<mem>/g,
      function() {
        return i;
      }
    );
    t.languages.javadoc = t.languages.extend("javadoclike", {}), t.languages.insertBefore("javadoc", "keyword", {
      reference: {
        pattern: RegExp(
          /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + o + ")"
        ),
        lookbehind: !0,
        inside: {
          function: {
            pattern: /(#\s*)\w+(?=\s*\()/,
            lookbehind: !0
          },
          field: {
            pattern: /(#\s*)\w+/,
            lookbehind: !0
          },
          namespace: {
            pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
            inside: {
              punctuation: /\./
            }
          },
          "class-name": /\b[A-Z]\w*/,
          keyword: t.languages.java.keyword,
          punctuation: /[#()[\],.]/
        }
      },
      "class-name": {
        // @param <T> the first generic type parameter
        pattern: /(@param\s+)<[A-Z]\w*>/,
        lookbehind: !0,
        inside: {
          punctuation: /[.<>]/
        }
      },
      "code-section": [
        {
          pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
          lookbehind: !0,
          inside: {
            code: {
              // there can't be any HTML inside of {@code} tags
              pattern: a,
              lookbehind: !0,
              inside: t.languages.java,
              alias: "language-java"
            }
          }
        },
        {
          pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
          lookbehind: !0,
          inside: {
            line: {
              pattern: a,
              lookbehind: !0,
              inside: {
                // highlight HTML tags and entities
                tag: t.languages.markup.tag,
                entity: t.languages.markup.entity,
                code: {
                  // everything else is Java code
                  pattern: /.+/,
                  inside: t.languages.java,
                  alias: "language-java"
                }
              }
            }
          }
        }
      ],
      tag: t.languages.markup.tag,
      entity: t.languages.markup.entity
    }), t.languages.javadoclike.addSupport("java", t.languages.javadoc);
  })(e);
}
th.displayName = "javastacktrace";
th.aliases = [];
function th(e) {
  e.languages.javastacktrace = {
    // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
    // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
    // Caused by: com.example.myproject.MyProjectServletException
    // Caused by: MidLevelException: LowLevelException
    // Suppressed: Resource$CloseFailException: Resource ID = 0
    summary: {
      pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
      lookbehind: !0,
      inside: {
        keyword: {
          pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
          lookbehind: !0
        },
        // the current thread if the summary starts with 'Exception in thread'
        string: {
          pattern: /^(\s*)"[^"]*"/,
          lookbehind: !0
        },
        exceptions: {
          pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
          lookbehind: !0,
          inside: {
            "class-name": /[\w$]+$/,
            namespace: /\b[a-z]\w*\b/,
            punctuation: /\./
          }
        },
        message: {
          pattern: /(:\s*)\S.*/,
          lookbehind: !0,
          alias: "string"
        },
        punctuation: /:/
      }
    },
    // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
    // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
    // at java.base/java.lang.Class.forName0(Native Method)
    // at Util.<init>(Unknown Source)
    // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
    // at com.foo.loader//com.foo.bar.App.run(App.java:12)
    // at acme@2.1/org.acme.Lib.test(Lib.java:80)
    // at MyClass.mash(MyClass.java:9)
    //
    // More information:
    // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
    //
    // A valid Java module name is defined as:
    //   "A module name consists of one or more Java identifiers (3.8) separated by "." tokens."
    // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
    //
    // A Java module version is defined by this class:
    // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
    // This is the implementation of the `parse` method in JDK13:
    // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
    // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
    "stack-frame": {
      pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
      lookbehind: !0,
      inside: {
        keyword: {
          pattern: /^(\s*)at(?= )/,
          lookbehind: !0
        },
        source: [
          // (Main.java:15)
          // (Main.scala:15)
          {
            pattern: /(\()\w+\.\w+:\d+(?=\))/,
            lookbehind: !0,
            inside: {
              file: /^\w+\.\w+/,
              punctuation: /:/,
              "line-number": {
                pattern: /\b\d+\b/,
                alias: "number"
              }
            }
          },
          // (Unknown Source)
          // (Native Method)
          // (...something...)
          {
            pattern: /(\()[^()]*(?=\))/,
            lookbehind: !0,
            inside: {
              keyword: /^(?:Native Method|Unknown Source)$/
            }
          }
        ],
        "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
        function: /(?:<init>|[\w$]+)(?=\()/,
        "class-loader": {
          pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /\./
          }
        },
        module: {
          pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
          lookbehind: !0,
          inside: {
            version: {
              pattern: /(@)[\s\S]+/,
              lookbehind: !0,
              alias: "number"
            },
            punctuation: /[@.]/
          }
        },
        namespace: {
          pattern: /(?:\b[a-z]\w*\.)+/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /[()/.]/
      }
    },
    // ... 32 more
    // ... 32 common frames omitted
    more: {
      pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
      lookbehind: !0,
      inside: {
        punctuation: /\.{3}/,
        number: /\d+/,
        keyword: /\b[a-z]+(?: [a-z]+)*\b/
      }
    }
  };
}
nh.displayName = "jexl";
nh.aliases = [];
function nh(e) {
  e.languages.jexl = {
    string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
    transform: {
      pattern: /(\|\s*)[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
      alias: "function",
      lookbehind: !0
    },
    function: /[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
    number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
    operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
    boolean: /\b(?:false|true)\b/,
    keyword: /\bin\b/,
    punctuation: /[{}[\](),.]/
  };
}
ah.displayName = "jolie";
ah.aliases = [];
function ah(e) {
  e.register(ze), e.languages.jolie = e.languages.extend("clike", {
    string: {
      pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
      lookbehind: !0,
      greedy: !0
    },
    "class-name": {
      pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
      lookbehind: !0
    },
    keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
    function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
    operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
    punctuation: /[()[\]{},;.:]/,
    builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
  }), e.languages.insertBefore("jolie", "keyword", {
    aggregates: {
      pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
      lookbehind: !0,
      inside: {
        keyword: /\bwith\b/,
        "class-name": /\w+/,
        punctuation: /,/
      }
    },
    redirects: {
      pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
      lookbehind: !0,
      inside: {
        punctuation: /,/,
        "class-name": /\w+/,
        operator: /=>/
      }
    },
    property: {
      pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
    }
  });
}
rh.displayName = "jq";
rh.aliases = [];
function rh(e) {
  (function(t) {
    var a = /\\\((?:[^()]|\([^()]*\))*\)/.source, i = RegExp(
      /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
        /__/g,
        function() {
          return a;
        }
      )
    ), o = {
      interpolation: {
        pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + a),
        lookbehind: !0,
        inside: {
          content: {
            pattern: /^(\\\()[\s\S]+(?=\)$)/,
            lookbehind: !0,
            inside: null
            // see below
          },
          punctuation: /^\\\(|\)$/
        }
      }
    }, l = t.languages.jq = {
      comment: /#.*/,
      property: {
        pattern: RegExp(i.source + /(?=\s*:(?!:))/.source),
        lookbehind: !0,
        greedy: !0,
        inside: o
      },
      string: {
        pattern: i,
        lookbehind: !0,
        greedy: !0,
        inside: o
      },
      function: {
        pattern: /(\bdef\s+)[a-z_]\w+/i,
        lookbehind: !0
      },
      variable: /\B\$\w+/,
      "property-literal": {
        pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
        alias: "property"
      },
      keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
      operator: [
        {
          pattern: /\|=?/,
          alias: "pipe"
        },
        /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
      ],
      "c-style-function": {
        pattern: /\b[a-z_]\w*(?=\s*\()/i,
        alias: "function"
      },
      punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
      dot: {
        pattern: /\./,
        alias: "important"
      }
    };
    o.interpolation.inside.content.inside = l;
  })(e);
}
ih.displayName = "js-templates";
ih.aliases = [];
function ih(e) {
  e.register(Bt), (function(t) {
    var a = t.languages.javascript["template-string"], i = a.pattern.source, o = a.inside.interpolation, l = o.inside["interpolation-punctuation"], c = o.pattern.source;
    function d(_, k) {
      if (t.languages[_])
        return {
          pattern: RegExp("((?:" + k + ")\\s*)" + i),
          lookbehind: !0,
          greedy: !0,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "embedded-code": {
              pattern: /[\s\S]+/,
              alias: _
            }
          }
        };
    }
    t.languages.javascript["template-string"] = [
      // styled-jsx:
      //   css`a { color: #25F; }`
      // styled-components:
      //   styled.h1`color: red;`
      d(
        "css",
        /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source
      ),
      // html`<p></p>`
      // div.innerHTML = `<p></p>`
      d("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
      // svg`<path fill="#fff" d="M55.37 ..."/>`
      d("svg", /\bsvg/.source),
      // md`# h1`, markdown`## h2`
      d("markdown", /\b(?:markdown|md)/.source),
      // gql`...`, graphql`...`, graphql.experimental`...`
      d(
        "graphql",
        /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source
      ),
      // sql`...`
      d("sql", /\bsql/.source),
      // vanilla template string
      a
    ].filter(Boolean);
    function m(_, k) {
      return "___" + k.toUpperCase() + "_" + _ + "___";
    }
    function f(_, k, R) {
      var C = {
        code: _,
        grammar: k,
        language: R
      };
      return t.hooks.run("before-tokenize", C), C.tokens = t.tokenize(C.code, C.grammar), t.hooks.run("after-tokenize", C), C.tokens;
    }
    function b(_) {
      var k = {};
      k["interpolation-punctuation"] = l;
      var R = t.tokenize(_, k);
      if (R.length === 3) {
        var C = [1, 1];
        C.push.apply(
          C,
          f(R[1], t.languages.javascript, "javascript")
        ), R.splice.apply(R, C);
      }
      return new t.Token(
        "interpolation",
        R,
        o.alias,
        _
      );
    }
    function E(_, k, R) {
      var C = t.tokenize(_, {
        interpolation: {
          pattern: RegExp(c),
          lookbehind: !0
        }
      }), L = 0, x = {}, Y = C.map(function(K) {
        if (typeof K == "string")
          return K;
        for (var Q = K.content, U; _.indexOf(
          U = m(L++, R)
        ) !== -1; )
          ;
        return x[U] = Q, U;
      }).join(""), q = f(Y, k, R), D = Object.keys(x);
      L = 0;
      function G(K) {
        for (var Q = 0; Q < K.length; Q++) {
          if (L >= D.length)
            return;
          var U = K[Q];
          if (typeof U == "string" || typeof U.content == "string") {
            var ee = D[L], ae = typeof U == "string" ? U : (
              /** @type {string} */
              U.content
            ), ue = ae.indexOf(ee);
            if (ue !== -1) {
              ++L;
              var de = ae.substring(0, ue), ce = b(
                x[ee]
              ), j = ae.substring(ue + ee.length), se = [];
              if (de && se.push(de), se.push(ce), j) {
                var Ee = [j];
                G(Ee), se.push.apply(se, Ee);
              }
              typeof U == "string" ? (K.splice.apply(K, [Q, 1].concat(se)), Q += se.length - 1) : U.content = se;
            }
          } else {
            var Ne = U.content;
            Array.isArray(Ne) ? G(Ne) : G([Ne]);
          }
        }
      }
      return G(q), new t.Token(
        R,
        q,
        "language-" + R,
        _
      );
    }
    var T = {
      javascript: !0,
      js: !0,
      typescript: !0,
      ts: !0,
      jsx: !0,
      tsx: !0
    };
    t.hooks.add("after-tokenize", function(_) {
      if (!(_.language in T))
        return;
      function k(R) {
        for (var C = 0, L = R.length; C < L; C++) {
          var x = R[C];
          if (typeof x != "string") {
            var Y = x.content;
            if (!Array.isArray(Y)) {
              typeof Y != "string" && k([Y]);
              continue;
            }
            if (x.type === "template-string") {
              var q = Y[1];
              if (Y.length === 3 && typeof q != "string" && q.type === "embedded-code") {
                var D = S(q), G = q.alias, K = Array.isArray(G) ? G[0] : G, Q = t.languages[K];
                if (!Q)
                  continue;
                Y[1] = E(D, Q, K);
              }
            } else
              k(Y);
          }
        }
      }
      k(_.tokens);
    });
    function S(_) {
      return typeof _ == "string" ? _ : Array.isArray(_) ? _.map(S).join("") : S(_.content);
    }
  })(e);
}
mo.displayName = "typescript";
mo.aliases = ["ts"];
function mo(e) {
  e.register(Bt), (function(t) {
    t.languages.typescript = t.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), t.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete t.languages.typescript.parameter, delete t.languages.typescript["literal-property"];
    var a = t.languages.extend("typescript", {});
    delete a["class-name"], t.languages.typescript["class-name"].inside = a, t.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: !0,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: a
          }
        }
      }
    }), t.languages.ts = t.languages.typescript;
  })(e);
}
sh.displayName = "jsdoc";
sh.aliases = [];
function sh(e) {
  e.register(Oi), e.register(Bt), e.register(mo), (function(t) {
    var a = t.languages.javascript, i = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, o = "(@(?:arg|argument|param|property)\\s+(?:" + i + "\\s+)?)";
    t.languages.jsdoc = t.languages.extend("javadoclike", {
      parameter: {
        // @param {string} foo - foo bar
        pattern: RegExp(
          o + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source
        ),
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    }), t.languages.insertBefore("jsdoc", "keyword", {
      "optional-parameter": {
        // @param {string} [baz.foo="bar"] foo bar
        pattern: RegExp(
          o + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
        ),
        lookbehind: !0,
        inside: {
          parameter: {
            pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
            lookbehind: !0,
            inside: {
              punctuation: /\./
            }
          },
          code: {
            pattern: /(=)[\s\S]*(?=\]$)/,
            lookbehind: !0,
            inside: a,
            alias: "language-javascript"
          },
          punctuation: /[=[\]]/
        }
      },
      "class-name": [
        {
          pattern: RegExp(
            /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
              /<TYPE>/g,
              function() {
                return i;
              }
            )
          ),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        {
          pattern: RegExp("(@[a-z]+\\s+)" + i),
          lookbehind: !0,
          inside: {
            string: a.string,
            number: a.number,
            boolean: a.boolean,
            keyword: t.languages.typescript.keyword,
            operator: /=>|\.\.\.|[&|?:*]/,
            punctuation: /[.,;=<>{}()[\]]/
          }
        }
      ],
      example: {
        pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
        lookbehind: !0,
        inside: {
          code: {
            pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
            lookbehind: !0,
            inside: a,
            alias: "language-javascript"
          }
        }
      }
    }), t.languages.javadoclike.addSupport("javascript", t.languages.jsdoc);
  })(e);
}
oh.displayName = "n4js";
oh.aliases = ["n4jsd"];
function oh(e) {
  e.register(Bt), e.languages.n4js = e.languages.extend("javascript", {
    // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
    keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
  }), e.languages.insertBefore("n4js", "constant", {
    // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
    annotation: {
      pattern: /@+\w+/,
      alias: "operator"
    }
  }), e.languages.n4jsd = e.languages.n4js;
}
lh.displayName = "js-extras";
lh.aliases = [];
function lh(e) {
  e.register(Bt), (function(t) {
    t.languages.insertBefore("javascript", "function-variable", {
      "method-variable": {
        pattern: RegExp(
          "(\\.\\s*)" + t.languages.javascript["function-variable"].pattern.source
        ),
        lookbehind: !0,
        alias: ["function-variable", "method", "function", "property-access"]
      }
    }), t.languages.insertBefore("javascript", "function", {
      method: {
        pattern: RegExp(
          "(\\.\\s*)" + t.languages.javascript.function.source
        ),
        lookbehind: !0,
        alias: ["function", "property-access"]
      }
    }), t.languages.insertBefore("javascript", "constant", {
      "known-class-name": [
        {
          // standard built-ins
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
          pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
          alias: "class-name"
        },
        {
          // errors
          pattern: /\b(?:[A-Z]\w*)Error\b/,
          alias: "class-name"
        }
      ]
    });
    function a(m, f) {
      return RegExp(
        m.replace(/<ID>/g, function() {
          return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
        }),
        f
      );
    }
    t.languages.insertBefore("javascript", "keyword", {
      imports: {
        // https://tc39.es/ecma262/#sec-imports
        pattern: a(
          /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
        ),
        lookbehind: !0,
        inside: t.languages.javascript
      },
      exports: {
        // https://tc39.es/ecma262/#sec-exports
        pattern: a(
          /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
        ),
        lookbehind: !0,
        inside: t.languages.javascript
      }
    }), t.languages.javascript.keyword.unshift(
      {
        pattern: /\b(?:as|default|export|from|import)\b/,
        alias: "module"
      },
      {
        pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
        alias: "control-flow"
      },
      {
        pattern: /\bnull\b/,
        alias: ["null", "nil"]
      },
      {
        pattern: /\bundefined\b/,
        alias: "nil"
      }
    ), t.languages.insertBefore("javascript", "operator", {
      spread: {
        pattern: /\.{3}/,
        alias: "operator"
      },
      arrow: {
        pattern: /=>/,
        alias: "operator"
      }
    }), t.languages.insertBefore("javascript", "punctuation", {
      "property-access": {
        pattern: a(/(\.\s*)#?<ID>/.source),
        lookbehind: !0
      },
      "maybe-class-name": {
        pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
        lookbehind: !0
      },
      dom: {
        // this contains only a few commonly used DOM variables
        pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
        alias: "variable"
      },
      console: {
        pattern: /\bconsole(?=\s*\.)/,
        alias: "class-name"
      }
    });
    for (var i = [
      "function",
      "function-variable",
      "method",
      "method-variable",
      "property-access"
    ], o = 0; o < i.length; o++) {
      var l = i[o], c = t.languages.javascript[l];
      t.util.type(c) === "RegExp" && (c = t.languages.javascript[l] = {
        pattern: c
      });
      var d = c.inside || {};
      c.inside = d, d["maybe-class-name"] = /^[A-Z][\s\S]*/;
    }
  })(e);
}
uh.displayName = "json5";
uh.aliases = [];
function uh(e) {
  e.register(fo), (function(t) {
    var a = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
    t.languages.json5 = t.languages.extend("json", {
      property: [
        {
          pattern: RegExp(a.source + "(?=\\s*:)"),
          greedy: !0
        },
        {
          pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
          alias: "unquoted"
        }
      ],
      string: {
        pattern: a,
        greedy: !0
      },
      number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
    });
  })(e);
}
ch.displayName = "jsonp";
ch.aliases = [];
function ch(e) {
  e.register(fo), e.languages.jsonp = e.languages.extend("json", {
    punctuation: /[{}[\]();,.]/
  }), e.languages.insertBefore("jsonp", "punctuation", {
    function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
  });
}
dh.displayName = "jsstacktrace";
dh.aliases = [];
function dh(e) {
  e.languages.jsstacktrace = {
    "error-message": {
      pattern: /^\S.*/m,
      alias: "string"
    },
    "stack-frame": {
      pattern: /(^[ \t]+)at[ \t].*/m,
      lookbehind: !0,
      inside: {
        "not-my-code": {
          pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
          alias: "comment"
        },
        filename: {
          pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
          lookbehind: !0,
          alias: "url"
        },
        function: {
          pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /[()]/,
        keyword: /\b(?:at|new)\b/,
        alias: {
          pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
          alias: "variable"
        },
        "line-number": {
          pattern: /:\d+(?::\d+)?\b/,
          alias: "number",
          inside: {
            punctuation: /:/
          }
        }
      }
    }
  };
}
ph.displayName = "julia";
ph.aliases = [];
function ph(e) {
  e.languages.julia = {
    comment: {
      // support one level of nested comments
      // https://github.com/JuliaLang/julia/pull/6128
      pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
      lookbehind: !0
    },
    regex: {
      // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
      pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
      greedy: !0
    },
    string: {
      // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
      // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
      // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
      pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
      greedy: !0
    },
    char: {
      // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
      pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
    // https://docs.julialang.org/en/v1/manual/mathematical-operations/
    // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
    operator: /&&|\|\||[-+*^%&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~']/,
    punctuation: /::?|[{}[\]();,.?]/,
    // https://docs.julialang.org/en/v1/base/numbers/#Base.im
    constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[]/
  };
}
fh.displayName = "keepalived";
fh.aliases = [];
function fh(e) {
  e.languages.keepalived = {
    comment: {
      pattern: /[#!].*/,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
      lookbehind: !0,
      greedy: !0
    },
    // support IPv4, IPv6, subnet mask
    ip: {
      pattern: RegExp(
        /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
          /<ipv4>/g,
          function() {
            return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
          }
        ),
        "i"
      ),
      alias: "number"
    },
    // support *nix / Windows, directory / file
    path: {
      pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
      lookbehind: !0,
      alias: "string"
    },
    variable: /\$\{?\w+\}?/,
    email: {
      pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
      alias: "string"
    },
    "conditional-configuration": {
      pattern: /@\^?[\w-]+/,
      alias: "variable"
    },
    operator: /=/,
    property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
    constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
    number: {
      pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
      lookbehind: !0
    },
    boolean: /\b(?:false|no|off|on|true|yes)\b/,
    punctuation: /[\{\}]/
  };
}
mh.displayName = "keyman";
mh.aliases = [];
function mh(e) {
  e.languages.keyman = {
    comment: {
      pattern: /\bc .*/i,
      greedy: !0
    },
    string: {
      pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
      greedy: !0
    },
    "virtual-key": {
      pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
      greedy: !0,
      alias: "function"
      // alias for styles
    },
    // https://help.keyman.com/developer/language/guide/headers
    "header-keyword": {
      pattern: /&\w+/,
      alias: "bold"
      // alias for styles
    },
    "header-statement": {
      pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
      alias: "bold"
      // alias for styles
    },
    "rule-keyword": {
      pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
      alias: "keyword"
    },
    "structural-keyword": {
      pattern: /\b(?:ansi|begin|group|match|newcontext|nomatch|postkeystroke|readonly|unicode|using keys)\b/i,
      alias: "keyword"
    },
    "compile-target": {
      pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
      alias: "property"
    },
    // U+####, x###, d### characters and numbers
    number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
    operator: /[+>\\$]|\.\./,
    punctuation: /[()=,]/
  };
}
gh.displayName = "kotlin";
gh.aliases = ["kt", "kts"];
function gh(e) {
  e.register(ze), (function(t) {
    t.languages.kotlin = t.languages.extend("clike", {
      keyword: {
        // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
        pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
        lookbehind: !0
      },
      function: [
        {
          pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
          greedy: !0
        },
        {
          pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
      operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
    }), delete t.languages.kotlin["class-name"];
    var a = {
      "interpolation-punctuation": {
        pattern: /^\$\{?|\}$/,
        alias: "punctuation"
      },
      expression: {
        pattern: /[\s\S]+/,
        inside: t.languages.kotlin
      }
    };
    t.languages.insertBefore("kotlin", "string", {
      // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
      "string-literal": [
        {
          pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
          alias: "multiline",
          inside: {
            interpolation: {
              pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
              inside: a
            },
            string: /[\s\S]+/
          }
        },
        {
          pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
          alias: "singleline",
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
              lookbehind: !0,
              inside: a
            },
            string: /[\s\S]+/
          }
        }
      ],
      char: {
        // https://kotlinlang.org/spec/expressions.html#character-literals
        pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
        greedy: !0
      }
    }), delete t.languages.kotlin.string, t.languages.insertBefore("kotlin", "keyword", {
      annotation: {
        pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
        alias: "builtin"
      }
    }), t.languages.insertBefore("kotlin", "function", {
      label: {
        pattern: /\b\w+@|@\w+\b/,
        alias: "symbol"
      }
    }), t.languages.kt = t.languages.kotlin, t.languages.kts = t.languages.kotlin;
  })(e);
}
hh.displayName = "kumir";
hh.aliases = ["kum"];
function hh(e) {
  (function(t) {
    var a = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
    function i(o, l) {
      return RegExp(o.replace(/<nonId>/g, a), l);
    }
    t.languages.kumir = {
      comment: {
        pattern: /\|.*/
      },
      prolog: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
        greedy: !0
      },
      boolean: {
        pattern: i(/(^|[<nonId>])(?:|)(?=[<nonId>]|$)/.source),
        lookbehind: !0
      },
      "operator-word": {
        pattern: i(/(^|[<nonId>])(?:||)(?=[<nonId>]|$)/.source),
        lookbehind: !0,
        alias: "keyword"
      },
      "system-variable": {
        pattern: i(/(^|[<nonId>])(?=[<nonId>]|$)/.source),
        lookbehind: !0,
        alias: "keyword"
      },
      type: [
        {
          pattern: i(
            /(^|[<nonId>])(?:||||)(?:\x20*)?(?=[<nonId>]|$)/.source
          ),
          lookbehind: !0,
          alias: "builtin"
        },
        {
          pattern: i(
            /(^|[<nonId>])(?:|||)(?=[<nonId>]|$)/.source
          ),
          lookbehind: !0,
          alias: "important"
        }
      ],
      /**
       * Should be performed after searching for type names because of "".
       * "" is a reserved word, but never used without a preceding type name.
       * "", "", and "" are not reserved words.
       */
      keyword: {
        pattern: i(
          /(^|[<nonId>])(?:|(?:\x20*)?|||[]||||||||||||(?:(?:\x20+|_))?|(?:(?:\x20+|_))?|||||||||?||||||)(?=[<nonId>]|$)/.source
        ),
        lookbehind: !0
      },
      /** Should be performed after searching for reserved words. */
      name: {
        // eslint-disable-next-line regexp/no-super-linear-backtracking
        pattern: i(
          /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
        ),
        lookbehind: !0
      },
      /** Should be performed after searching for names. */
      number: {
        pattern: i(
          /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
          "i"
        ),
        lookbehind: !0
      },
      /** Should be performed after searching for words. */
      punctuation: /:=|[(),:;\[\]]/,
      /**
       * Should be performed after searching for
       * - numeric constants (because of "+" and "-");
       * - punctuation marks (because of ":=" and "=").
       */
      "operator-char": {
        pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
        alias: "operator"
      }
    }, t.languages.kum = t.languages.kumir;
  })(e);
}
bh.displayName = "kusto";
bh.aliases = [];
function bh(e) {
  e.languages.kusto = {
    comment: {
      pattern: /\/\/.*/,
      greedy: !0
    },
    string: {
      pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
      greedy: !0
    },
    verb: {
      pattern: /(\|\s*)[a-z][\w-]*/i,
      lookbehind: !0,
      alias: "keyword"
    },
    command: {
      pattern: /\.[a-z][a-z\d-]*\b/,
      alias: "keyword"
    },
    "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
    keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
    boolean: /\b(?:false|null|true)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/,
    datetime: [
      {
        // RFC 822 + RFC 850
        pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
        alias: "number"
      },
      {
        // ISO 8601
        pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
        alias: "number"
      }
    ],
    number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mn]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
    operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
    punctuation: /[()\[\]{},;.:]/
  };
}
Eh.displayName = "latex";
Eh.aliases = ["context", "tex"];
function Eh(e) {
  (function(t) {
    var a = /\\(?:[^a-z()[\]]|[a-z*]+)/i, i = {
      "equation-command": {
        pattern: a,
        alias: "regex"
      }
    };
    t.languages.latex = {
      comment: /%.*/,
      // the verbatim environment prints whitespace to the document
      cdata: {
        pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
        lookbehind: !0
      },
      /*
       * equations can be between $$ $$ or $ $ or \( \) or \[ \]
       * (all are multiline)
       */
      equation: [
        {
          pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
          inside: i,
          alias: "string"
        },
        {
          pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
          lookbehind: !0,
          inside: i,
          alias: "string"
        }
      ],
      /*
       * arguments which are keywords or references are highlighted
       * as keywords
       */
      keyword: {
        pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
        lookbehind: !0
      },
      url: {
        pattern: /(\\url\{)[^}]+(?=\})/,
        lookbehind: !0
      },
      /*
       * section or chapter headlines are highlighted as bold so that
       * they stand out more
       */
      headline: {
        pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
        lookbehind: !0,
        alias: "class-name"
      },
      function: {
        pattern: a,
        alias: "selector"
      },
      punctuation: /[[\]{}&]/
    }, t.languages.tex = t.languages.latex, t.languages.context = t.languages.latex;
  })(e);
}
yh.displayName = "latte";
yh.aliases = [];
function yh(e) {
  e.register(ze), e.register(Ft), e.register(Ii), (function(t) {
    t.languages.latte = {
      comment: /^\{\*[\s\S]*/,
      "latte-tag": {
        // https://latte.nette.org/en/tags
        pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
        lookbehind: !0,
        alias: "important"
      },
      delimiter: {
        pattern: /^\{\/?|\}$/,
        alias: "punctuation"
      },
      php: {
        pattern: /\S(?:[\s\S]*\S)?/,
        alias: "language-php",
        inside: t.languages.php
      }
    };
    var a = t.languages.extend("markup", {});
    t.languages.insertBefore(
      "inside",
      "attr-value",
      {
        "n-attr": {
          pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
          inside: {
            "attr-name": {
              pattern: /^[^\s=]+/,
              alias: "important"
            },
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                punctuation: [
                  /^=/,
                  {
                    pattern: /^(\s*)["']|["']$/,
                    lookbehind: !0
                  }
                ],
                php: {
                  pattern: /\S(?:[\s\S]*\S)?/,
                  inside: t.languages.php
                }
              }
            }
          }
        }
      },
      a.tag
    ), t.hooks.add("before-tokenize", function(i) {
      if (i.language === "latte") {
        var o = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
        t.languages["markup-templating"].buildPlaceholders(
          i,
          "latte",
          o
        ), i.grammar = a;
      }
    }), t.hooks.add("after-tokenize", function(i) {
      t.languages["markup-templating"].tokenizePlaceholders(i, "latte");
    });
  })(e);
}
go.displayName = "scheme";
go.aliases = [];
function go(e) {
  (function(t) {
    t.languages.scheme = {
      // this supports "normal" single-line comments:
      //   ; comment
      // and (potentially nested) multiline comments:
      //   #| comment #| nested |# still comment |#
      // (only 1 level of nesting is supported)
      comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: !0
      },
      symbol: {
        pattern: /'[^()\[\]#'\s]+/,
        greedy: !0
      },
      char: {
        pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
        greedy: !0
      },
      "lambda-parameter": [
        // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
        {
          pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
          lookbehind: !0
        },
        {
          pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
          lookbehind: !0
        }
      ],
      keyword: {
        pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
        lookbehind: !0
      },
      builtin: {
        // all functions of the base library of R7RS plus some of built-ins of R5Rs
        pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
        lookbehind: !0
      },
      operator: {
        pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
        lookbehind: !0
      },
      number: {
        // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
        //
        // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
        // <num R>       := <prefix R><complex R>
        // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
        // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
        // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
        // <ureal R>     := <uint R>(?:\/<uint R>)?
        //                | <decimal R>
        //
        // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
        // <uint R>      := <digit R>+
        // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
        // <radix 2>     := #b
        // <radix 8>     := #o
        // <radix 10>    := (?:#d)?
        // <radix 16>    := #x
        // <digit 2>     := [01]
        // <digit 8>     := [0-7]
        // <digit 10>    := \d
        // <digit 16>    := [0-9a-f]
        //
        // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
        // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
        // pattern:
        pattern: RegExp(
          a({
            "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
            "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
            "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
            "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
            "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
            "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
            "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
            "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
            "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
            "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
            "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
          }),
          "i"
        ),
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
        lookbehind: !0
      },
      function: {
        pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
        lookbehind: !0
      },
      identifier: {
        pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
        lookbehind: !0,
        greedy: !0
      },
      punctuation: /[()\[\]']/
    };
    function a(i) {
      for (var o in i)
        i[o] = i[o].replace(/<[\w\s]+>/g, function(l) {
          return "(?:" + i[l].trim() + ")";
        });
      return i[o];
    }
  })(e);
}
Th.displayName = "lilypond";
Th.aliases = ["ly"];
function Th(e) {
  e.register(go), (function(t) {
    for (var a = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source, i = 5, o = 0; o < i; o++)
      a = a.replace(/<expr>/g, function() {
        return a;
      });
    a = a.replace(/<expr>/g, /[^\s\S]/.source);
    var l = t.languages.lilypond = {
      comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
      "embedded-scheme": {
        pattern: RegExp(
          /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
            /<expr>/g,
            function() {
              return a;
            }
          ),
          "m"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          scheme: {
            pattern: /^(#)[\s\S]+$/,
            lookbehind: !0,
            alias: "language-scheme",
            inside: {
              "embedded-lilypond": {
                pattern: /#\{[\s\S]*?#\}/,
                greedy: !0,
                inside: {
                  punctuation: /^#\{|#\}$/,
                  lilypond: {
                    pattern: /[\s\S]+/,
                    alias: "language-lilypond",
                    inside: null
                    // see below
                  }
                }
              },
              rest: t.languages.scheme
            }
          },
          punctuation: /#/
        }
      },
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\\new\s+)[\w-]+/,
        lookbehind: !0
      },
      keyword: {
        pattern: /\\[a-z][-\w]*/i,
        inside: {
          punctuation: /^\\/
        }
      },
      operator: /[=|]|<<|>>/,
      punctuation: {
        pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
        lookbehind: !0
      },
      number: /\b\d+(?:\/\d+)?\b/
    };
    l["embedded-scheme"].inside.scheme.inside["embedded-lilypond"].inside.lilypond.inside = l, t.languages.ly = l;
  })(e);
}
Sh.displayName = "liquid";
Sh.aliases = [];
function Sh(e) {
  e.register(Ft), e.languages.liquid = {
    comment: {
      pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
      lookbehind: !0
    },
    delimiter: {
      pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
      alias: "punctuation"
    },
    string: {
      pattern: /"[^"]*"|'[^']*'/,
      greedy: !0
    },
    keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
    object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
    function: [
      {
        pattern: /(\|\s*)\w+/,
        lookbehind: !0,
        alias: "filter"
      },
      {
        // array functions
        pattern: /(\.\s*)(?:first|last|size)/,
        lookbehind: !0
      }
    ],
    boolean: /\b(?:false|nil|true)\b/,
    range: {
      pattern: /\.\./,
      alias: "operator"
    },
    // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
    number: /\b\d+(?:\.\d+)?\b/,
    operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
    punctuation: /[.,\[\]()]/,
    empty: {
      pattern: /\bempty\b/,
      alias: "keyword"
    }
  }, e.hooks.add("before-tokenize", function(t) {
    var a = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g, i = !1;
    e.languages["markup-templating"].buildPlaceholders(
      t,
      "liquid",
      a,
      function(o) {
        var l = /^\{%-?\s*(\w+)/.exec(o);
        if (l) {
          var c = l[1];
          if (c === "raw" && !i)
            return i = !0, !0;
          if (c === "endraw")
            return i = !1, !0;
        }
        return !i;
      }
    );
  }), e.hooks.add("after-tokenize", function(t) {
    e.languages["markup-templating"].tokenizePlaceholders(t, "liquid");
  });
}
_h.displayName = "lisp";
_h.aliases = ["elisp", "emacs", "emacs-lisp"];
function _h(e) {
  (function(t) {
    function a(_) {
      return RegExp(/(\()/.source + "(?:" + _ + ")" + /(?=[\s\)])/.source);
    }
    function i(_) {
      return RegExp(
        /([\s([])/.source + "(?:" + _ + ")" + /(?=[\s)])/.source
      );
    }
    var o = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source, l = "&" + o, c = "(\\()", d = "(?=\\))", m = "(?=\\s)", f = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source, b = {
      // Three or four semicolons are considered a heading.
      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
      heading: {
        pattern: /;;;.*/,
        alias: ["comment", "title"]
      },
      comment: /;.*/,
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: !0,
        inside: {
          argument: /[-A-Z]+(?=[.,\s])/,
          symbol: RegExp("`" + o + "'")
        }
      },
      "quoted-symbol": {
        pattern: RegExp("#?'" + o),
        alias: ["variable", "symbol"]
      },
      "lisp-property": {
        pattern: RegExp(":" + o),
        alias: "property"
      },
      splice: {
        pattern: RegExp(",@?" + o),
        alias: ["symbol", "variable"]
      },
      keyword: [
        {
          pattern: RegExp(
            c + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + m
          ),
          lookbehind: !0
        },
        {
          pattern: RegExp(
            c + "(?:append|by|collect|concat|do|finally|for|in|return)" + m
          ),
          lookbehind: !0
        }
      ],
      declare: {
        pattern: a(/declare/.source),
        lookbehind: !0,
        alias: "keyword"
      },
      interactive: {
        pattern: a(/interactive/.source),
        lookbehind: !0,
        alias: "keyword"
      },
      boolean: {
        pattern: i(/nil|t/.source),
        lookbehind: !0
      },
      number: {
        pattern: i(/[-+]?\d+(?:\.\d*)?/.source),
        lookbehind: !0
      },
      defvar: {
        pattern: RegExp(c + "def(?:const|custom|group|var)\\s+" + o),
        lookbehind: !0,
        inside: {
          keyword: /^def[a-z]+/,
          variable: RegExp(o)
        }
      },
      defun: {
        pattern: RegExp(
          c + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + o + /\s+\(/.source + f + /\)/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^(?:cl-)?def\S+/,
          // See below, this property needs to be defined later so that it can
          // reference the language object.
          arguments: null,
          function: {
            pattern: RegExp("(^\\s)" + o),
            lookbehind: !0
          },
          punctuation: /[()]/
        }
      },
      lambda: {
        pattern: RegExp(
          c + "lambda\\s+\\(\\s*(?:&?" + o + "(?:\\s+&?" + o + ")*\\s*)?\\)"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^lambda/,
          // See below, this property needs to be defined later so that it can
          // reference the language object.
          arguments: null,
          punctuation: /[()]/
        }
      },
      car: {
        pattern: RegExp(c + o),
        lookbehind: !0
      },
      punctuation: [
        // open paren, brackets, and close paren
        /(?:['`,]?\(|[)\[\]])/,
        // cons
        {
          pattern: /(\s)\.(?=\s)/,
          lookbehind: !0
        }
      ]
    }, E = {
      "lisp-marker": RegExp(l),
      varform: {
        pattern: RegExp(
          /\(/.source + o + /\s+(?=\S)/.source + f + /\)/.source
        ),
        inside: b
      },
      argument: {
        pattern: RegExp(/(^|[\s(])/.source + o),
        lookbehind: !0,
        alias: "variable"
      },
      rest: b
    }, T = "\\S+(?:\\s+\\S+)*", S = {
      pattern: RegExp(c + f + d),
      lookbehind: !0,
      inside: {
        "rest-vars": {
          pattern: RegExp("&(?:body|rest)\\s+" + T),
          inside: E
        },
        "other-marker-vars": {
          pattern: RegExp("&(?:aux|optional)\\s+" + T),
          inside: E
        },
        keys: {
          pattern: RegExp("&key\\s+" + T + "(?:\\s+&allow-other-keys)?"),
          inside: E
        },
        argument: {
          pattern: RegExp(o),
          alias: "variable"
        },
        punctuation: /[()]/
      }
    };
    b.lambda.inside.arguments = S, b.defun.inside.arguments = t.util.clone(S), b.defun.inside.arguments.inside.sublist = S, t.languages.lisp = b, t.languages.elisp = b, t.languages.emacs = b, t.languages["emacs-lisp"] = b;
  })(e);
}
Ah.displayName = "livescript";
Ah.aliases = [];
function Ah(e) {
  e.languages.livescript = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0
      },
      {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0
      }
    ],
    "interpolated-string": {
      /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
       * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
      pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        variable: {
          pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
          lookbehind: !0
        },
        interpolation: {
          pattern: /(^|[^\\])#\{[^}]+\}/m,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^#\{|\}$/,
              alias: "variable"
            }
            // See rest below
          }
        },
        string: /[\s\S]+/
      }
    },
    string: [
      {
        pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      {
        pattern: /<\[[\s\S]*?\]>/,
        greedy: !0
      },
      /\\[^\s,;\])}]+/
    ],
    regex: [
      {
        pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
        greedy: !0,
        inside: {
          comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: !0
          }
        }
      },
      {
        pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
        greedy: !0
      }
    ],
    keyword: {
      pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
      lookbehind: !0
    },
    "keyword-operator": {
      pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
      lookbehind: !0,
      alias: "operator"
    },
    boolean: {
      pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
      lookbehind: !0
    },
    argument: {
      // Don't match .&. nor &&
      pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
      lookbehind: !0,
      alias: "variable"
    },
    number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
    identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
    operator: [
      // Spaced .
      {
        pattern: /( )\.(?= )/,
        lookbehind: !0
      },
      // Full list, in order:
      // .= .~ .. ...
      // .&. .^. .<<. .>>. .>>>.
      // := :: ::=
      // &&
      // || |>
      // < << <<< <<<<
      // <- <-- <-! <--!
      // <~ <~~ <~! <~~!
      // <| <= <?
      // > >> >= >?
      // - -- -> -->
      // + ++
      // @ @@
      // % %%
      // * **
      // ! != !~=
      // !~> !~~>
      // !-> !-->
      // ~ ~> ~~> ~=
      // = ==
      // ^ ^^
      // / ?
      /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
    ],
    punctuation: /[(){}\[\]|.,:;`]/
  }, e.languages.livescript["interpolated-string"].inside.interpolation.inside.rest = e.languages.livescript;
}
Nh.displayName = "llvm";
Nh.aliases = [];
function Nh(e) {
  (function(t) {
    t.languages.llvm = {
      comment: /;.*/,
      string: {
        pattern: /"[^"]*"/,
        greedy: !0
      },
      boolean: /\b(?:false|true)\b/,
      variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
      label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
      type: {
        pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
        alias: "class-name"
      },
      keyword: /\b[a-z_][a-z_0-9]*\b/,
      number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
      punctuation: /[{}[\];(),.!*=<>]/
    };
  })(e);
}
Rh.displayName = "log";
Rh.aliases = [];
function Rh(e) {
  e.languages.log = {
    string: {
      // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
      pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
      greedy: !0
    },
    exception: {
      pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
      lookbehind: !0,
      greedy: !0,
      alias: ["javastacktrace", "language-javastacktrace"],
      inside: e.languages.javastacktrace || {
        keyword: /\bat\b/,
        function: /[a-z_][\w$]*(?=\()/,
        punctuation: /[.:()]/
      }
    },
    level: [
      {
        pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
        alias: ["error", "important"]
      },
      {
        pattern: /\b(?:WARN|WARNING|WRN)\b/,
        alias: ["warning", "important"]
      },
      {
        pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
        alias: ["info", "keyword"]
      },
      {
        pattern: /\b(?:DBG|DEBUG|FINE)\b/,
        alias: ["debug", "keyword"]
      },
      {
        pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
        alias: ["trace", "comment"]
      }
    ],
    property: {
      pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
      lookbehind: !0
    },
    separator: {
      pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
      lookbehind: !0,
      alias: "comment"
    },
    url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
    email: {
      pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
      lookbehind: !0,
      alias: "url"
    },
    "ip-address": {
      pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
      alias: "constant"
    },
    "mac-address": {
      pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
      alias: "constant"
    },
    domain: {
      pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
      lookbehind: !0,
      alias: "constant"
    },
    uuid: {
      pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
      alias: "constant"
    },
    hash: {
      pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
      alias: "constant"
    },
    "file-path": {
      pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
      lookbehind: !0,
      greedy: !0,
      alias: "string"
    },
    date: {
      pattern: RegExp(
        /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
        "i"
      ),
      alias: "number"
    },
    time: {
      pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
      alias: "number"
    },
    boolean: /\b(?:false|null|true)\b/i,
    number: {
      pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
      lookbehind: !0
    },
    operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
    punctuation: /[\[\].,]/
  };
}
vh.displayName = "lolcode";
vh.aliases = [];
function vh(e) {
  e.languages.lolcode = {
    comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
    string: {
      pattern: /"(?::.|[^":])*"/,
      inside: {
        variable: /:\{[^}]+\}/,
        symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
      },
      greedy: !0
    },
    number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
    symbol: {
      pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
      lookbehind: !0,
      inside: {
        keyword: /A(?=\s)/
      }
    },
    label: {
      pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
      lookbehind: !0,
      alias: "string"
    },
    function: {
      pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
      lookbehind: !0
    },
    keyword: [
      {
        pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
        lookbehind: !0
      },
      /'Z(?=\s|,|$)/
    ],
    boolean: {
      pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
      lookbehind: !0
    },
    variable: {
      pattern: /(^|\s)IT(?=\s|,|$)/,
      lookbehind: !0
    },
    operator: {
      pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
      lookbehind: !0
    },
    punctuation: /\.{3}||,|!/
  };
}
Ch.displayName = "magma";
Ch.aliases = [];
function Ch(e) {
  e.languages.magma = {
    output: {
      pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
      lookbehind: !0,
      greedy: !0
    },
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
      lookbehind: !0,
      greedy: !0
    },
    // http://magma.maths.usyd.edu.au/magma/handbook/text/82
    keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
    boolean: /\b(?:false|true)\b/,
    generator: {
      pattern: /\b[a-z_]\w*(?=\s*<)/i,
      alias: "class-name"
    },
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: {
      pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
      lookbehind: !0
    },
    operator: /->|[-+*/^~!|#=]|:=|\.\./,
    punctuation: /[()[\]{}<>,;.:]/
  };
}
wh.displayName = "makefile";
wh.aliases = [];
function wh(e) {
  e.languages.makefile = {
    comment: {
      pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
      lookbehind: !0
    },
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "builtin-target": {
      pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
      alias: "builtin"
    },
    target: {
      pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
      alias: "symbol",
      inside: {
        variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
      }
    },
    variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
    // Directives
    keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
    function: {
      pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
      lookbehind: !0
    },
    operator: /(?:::|[?:+!])?=|[|@]/,
    punctuation: /[:;(){}]/
  };
}
vu.displayName = "mata";
vu.aliases = [];
function vu(e) {
  (function(t) {
    var a = /\b(?:(?:col|row)?vector|matrix|scalar)\b/.source, i = /\bvoid\b|<org>|\b(?:complex|numeric|pointer(?:\s*\([^()]*\))?|real|string|(?:class|struct)\s+\w+|transmorphic)(?:\s*<org>)?/.source.replace(
      /<org>/g,
      a
    );
    t.languages.mata = {
      comment: {
        pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"|[`']".*?"[`']/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|struct)\s+)\w+(?=\s*(?:\{|\bextends\b))/,
        lookbehind: !0
      },
      type: {
        pattern: RegExp(i),
        alias: "class-name",
        inside: {
          punctuation: /[()]/,
          keyword: /\b(?:class|function|struct|void)\b/
        }
      },
      keyword: /\b(?:break|class|continue|do|else|end|extends|external|final|for|function|goto|if|pragma|private|protected|public|return|static|struct|unset|unused|version|virtual|while)\b/,
      constant: /\bNULL\b/,
      number: {
        pattern: /(^|[^\w.])(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|\d[a-f0-9]*(?:\.[a-f0-9]+)?x[+-]?\d+)i?(?![\w.])/i,
        lookbehind: !0
      },
      missing: {
        pattern: /(^|[^\w.])(?:\.[a-z]?)(?![\w.])/,
        lookbehind: !0,
        alias: "symbol"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      operator: /\.\.|\+\+|--|&&|\|\||:?(?:[!=<>]=|[+\-*/^<>&|:])|[!?=\\#`']/,
      punctuation: /[()[\]{},;.]/
    };
  })(e);
}
kh.displayName = "matlab";
kh.aliases = [];
function kh(e) {
  e.languages.matlab = {
    comment: [/%\{[\s\S]*?\}%/, /%.+/],
    string: {
      pattern: /\B'(?:''|[^'\r\n])*'/,
      greedy: !0
    },
    // FIXME We could handle imaginary numbers as a whole
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
    keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
    function: /\b(?!\d)\w+(?=\s*\()/,
    operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
    punctuation: /\.{3}|[.,;\[\](){}!]/
  };
}
Ih.displayName = "maxscript";
Ih.aliases = [];
function Ih(e) {
  (function(t) {
    var a = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
    t.languages.maxscript = {
      comment: {
        pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
        greedy: !0
      },
      string: {
        pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
        lookbehind: !0,
        greedy: !0
      },
      path: {
        pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
        greedy: !0,
        alias: "string"
      },
      "function-call": {
        pattern: RegExp(
          "((?:" + // start of line
          (/^/.source + "|" + // operators and other language constructs
          /[;=<>+\-*/^({\[]/.source + "|" + // keywords as part of statements
          /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + a.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + // variable
          ("(?!" + a.source + ")" + /[a-z_]/.source + "|" + // number
          /\d|-\.?\d/.source + "|" + // other expressions or literals
          /[({'"$@#?]/.source) + "))",
          "im"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "function"
      },
      "function-definition": {
        pattern: /(\b(?:fn|function)\s+)\w+\b/i,
        lookbehind: !0,
        alias: "function"
      },
      argument: {
        pattern: /\b[a-z_]\w*(?=:)/i,
        alias: "attr-name"
      },
      keyword: a,
      boolean: /\b(?:false|true)\b/,
      time: {
        pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
        lookbehind: !0,
        alias: "number"
      },
      number: [
        {
          pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
          lookbehind: !0
        },
        /\b(?:e|pi)\b/
      ],
      constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
      color: {
        pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
        alias: "constant"
      },
      operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
      punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
    };
  })(e);
}
Oh.displayName = "mel";
Oh.aliases = [];
function Oh(e) {
  e.languages.mel = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
      greedy: !0
    },
    code: {
      pattern: /`(?:\\.|[^\\`])*`/,
      greedy: !0,
      alias: "italic",
      inside: {
        delimiter: {
          pattern: /^`|`$/,
          alias: "punctuation"
        },
        statement: {
          pattern: /[\s\S]+/,
          inside: null
          // see below
        }
      }
    },
    string: {
      pattern: /"(?:\\.|[^\\"\r\n])*"/,
      greedy: !0
    },
    variable: /\$\w+/,
    number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
    flag: {
      pattern: /-[^\d\W]\w*/,
      alias: "operator"
    },
    keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
    function: {
      pattern: /((?:^|[{;])[ \t]*)[a-z_]\w*\b(?!\s*(?:\.(?!\.)|[[{=]))|\b[a-z_]\w*(?=[ \t]*\()/im,
      lookbehind: !0,
      greedy: !0
    },
    "tensor-punctuation": {
      pattern: /<<|>>/,
      alias: "punctuation"
    },
    operator: /\+[+=]?|-[-=]?|&&|\|\||[<>]=?|[*\/!=]=?|[%^]/,
    punctuation: /[.,:;?\[\](){}]/
  }, e.languages.mel.code.inside.statement.inside = e.languages.mel;
}
xh.displayName = "mermaid";
xh.aliases = [];
function xh(e) {
  e.languages.mermaid = {
    comment: {
      pattern: /%%.*/,
      greedy: !0
    },
    style: {
      pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
      lookbehind: !0,
      inside: {
        property: /\b\w[\w-]*(?=[ \t]*:)/,
        operator: /:/,
        punctuation: /,/
      }
    },
    "inter-arrow-label": {
      pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        arrow: {
          pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
          alias: "operator"
        },
        label: {
          pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
          lookbehind: !0,
          alias: "property"
        },
        "arrow-head": {
          pattern: /^\S+/,
          alias: ["arrow", "operator"]
        }
      }
    },
    arrow: [
      // This might look complex but it really isn't.
      // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
      // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
      // characters in the one lookbehind because that would create too many false negatives. So we have to split the
      // arrows into different patterns.
      {
        // ER diagram
        pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
        lookbehind: !0,
        alias: "operator"
      },
      {
        // flow chart
        // (?:==+|--+|-\.*-)
        pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
        lookbehind: !0,
        alias: "operator"
      },
      {
        // sequence diagram
        pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
        lookbehind: !0,
        alias: "operator"
      },
      {
        // class diagram
        pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
        lookbehind: !0,
        alias: "operator"
      }
    ],
    label: {
      pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    },
    text: {
      pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
      alias: "string"
    },
    string: {
      pattern: /"[^"\r\n]*"/,
      greedy: !0
    },
    annotation: {
      pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
      alias: "important"
    },
    keyword: [
      // This language has both case-sensitive and case-insensitive keywords
      {
        pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
        lookbehind: !0,
        greedy: !0
      }
    ],
    entity: /#[a-z0-9]+;/,
    operator: {
      pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
      lookbehind: !0
    },
    punctuation: /[(){};]/
  };
}
Lh.displayName = "metafont";
Lh.aliases = [];
function Lh(e) {
  e.languages.metafont = {
    // Syntax of METAFONT with the added (public) elements of PlainMETAFONT. Except for internal quantities they are expected to be rarely redefined. Freely inspired by the syntax of Christophe Grandsire for the Crimson Editor.
    comment: {
      pattern: /%.*/,
      greedy: !0
    },
    string: {
      pattern: /"[^\r\n"]*"/,
      greedy: !0
    },
    number: /\d*\.?\d+/,
    boolean: /\b(?:false|true)\b/,
    punctuation: [
      /[,;()]/,
      {
        pattern: /(^|[^{}])(?:\{|\})(?![{}])/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^[])\[(?!\[)/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^\]])\](?!\])/,
        lookbehind: !0
      }
    ],
    constant: [
      {
        pattern: /(^|[^!?])\?\?\?(?![!?])/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^/*\\])(?:\\|\\\\)(?![/*\\])/,
        lookbehind: !0
      },
      /\b(?:_|blankpicture|bp|cc|cm|dd|ditto|down|eps|epsilon|fullcircle|halfcircle|identity|in|infinity|left|mm|nullpen|nullpicture|origin|pc|penrazor|penspeck|pensquare|penstroke|proof|pt|quartercircle|relax|right|smoke|unitpixel|unitsquare|up)\b/
    ],
    quantity: {
      pattern: /\b(?:autorounding|blacker|boundarychar|charcode|chardp|chardx|chardy|charext|charht|charic|charwd|currentwindow|day|designsize|displaying|fillin|fontmaking|granularity|hppp|join_radius|month|o_correction|pausing|pen_(?:bot|lft|rt|top)|pixels_per_inch|proofing|showstopping|smoothing|time|tolerance|tracingcapsules|tracingchoices|tracingcommands|tracingedges|tracingequations|tracingmacros|tracingonline|tracingoutput|tracingpens|tracingrestores|tracingspecs|tracingstats|tracingtitles|turningcheck|vppp|warningcheck|xoffset|year|yoffset)\b/,
      alias: "keyword"
    },
    command: {
      pattern: /\b(?:addto|batchmode|charlist|cull|display|errhelp|errmessage|errorstopmode|everyjob|extensible|fontdimen|headerbyte|inner|interim|let|ligtable|message|newinternal|nonstopmode|numspecial|openwindow|outer|randomseed|save|scrollmode|shipout|show|showdependencies|showstats|showtoken|showvariable|special)\b/,
      alias: "builtin"
    },
    operator: [
      {
        pattern: /(^|[^>=<:|])(?:<|<=|=|=:|\|=:|\|=:>|=:\|>|=:\||\|=:\||\|=:\|>|\|=:\|>>|>|>=|:|:=|<>|::|\|\|:)(?![>=<:|])/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^+-])(?:\+|\+\+|-{1,3}|\+-\+)(?![+-])/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^/*\\])(?:\*|\*\*|\/)(?![/*\\])/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.])(?:\.{2,3})(?!\.)/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^@#&$])&(?![@#&$])/,
        lookbehind: !0
      },
      /\b(?:and|not|or)\b/
    ],
    macro: {
      pattern: /\b(?:abs|beginchar|bot|byte|capsule_def|ceiling|change_width|clear_pen_memory|clearit|clearpen|clearxy|counterclockwise|cullit|cutdraw|cutoff|decr|define_blacker_pixels|define_corrected_pixels|define_good_x_pixels|define_good_y_pixels|define_horizontal_corrected_pixels|define_pixels|define_whole_blacker_pixels|define_whole_pixels|define_whole_vertical_blacker_pixels|define_whole_vertical_pixels|dir|direction|directionpoint|div|dotprod|downto|draw|drawdot|endchar|erase|fill|filldraw|fix_units|flex|font_coding_scheme|font_extra_space|font_identifier|font_normal_shrink|font_normal_space|font_normal_stretch|font_quad|font_size|font_slant|font_x_height|gfcorners|gobble|gobbled|good\.(?:bot|lft|rt|top|x|y)|grayfont|hide|hround|imagerules|incr|interact|interpath|intersectionpoint|inverse|italcorr|killtext|labelfont|labels|lft|loggingall|lowres_fix|makegrid|makelabel(?:\.(?:bot|lft|rt|top)(?:\.nodot)?)?|max|min|mod|mode_def|mode_setup|nodisplays|notransforms|numtok|openit|penlabels|penpos|pickup|proofoffset|proofrule|proofrulethickness|range|reflectedabout|rotatedabout|rotatedaround|round|rt|savepen|screenchars|screenrule|screenstrokes|shipit|showit|slantfont|softjoin|solve|stop|superellipse|tensepath|thru|titlefont|top|tracingall|tracingnone|undraw|undrawdot|unfill|unfilldraw|upto|vround)\b/,
      alias: "function"
    },
    builtin: /\b(?:ASCII|angle|char|cosd|decimal|directiontime|floor|hex|intersectiontimes|jobname|known|length|makepath|makepen|mexp|mlog|normaldeviate|oct|odd|pencircle|penoffset|point|postcontrol|precontrol|reverse|rotated|sind|sqrt|str|subpath|substring|totalweight|turningnumber|uniformdeviate|unknown|xpart|xxpart|xypart|ypart|yxpart|yypart)\b/,
    keyword: /\b(?:also|at|atleast|begingroup|charexists|contour|controls|curl|cycle|def|delimiters|doublepath|dropping|dump|else|elseif|end|enddef|endfor|endgroup|endinput|exitif|exitunless|expandafter|fi|for|forever|forsuffixes|from|if|input|inwindow|keeping|kern|of|primarydef|quote|readstring|scaled|scantokens|secondarydef|shifted|skipto|slanted|step|tension|tertiarydef|to|transformed|until|vardef|withpen|withweight|xscaled|yscaled|zscaled)\b/,
    type: {
      pattern: /\b(?:boolean|expr|numeric|pair|path|pen|picture|primary|secondary|string|suffix|tertiary|text|transform)\b/,
      alias: "property"
    },
    variable: {
      pattern: /(^|[^@#&$])(?:@#|#@|#|@)(?![@#&$])|\b(?:aspect_ratio|currentpen|currentpicture|currenttransform|d|extra_beginchar|extra_endchar|extra_setup|h|localfont|mag|mode|screen_cols|screen_rows|w|whatever|x|y|z)\b/,
      lookbehind: !0
    }
  };
}
Dh.displayName = "mizar";
Dh.aliases = [];
function Dh(e) {
  e.languages.mizar = {
    comment: /::.+/,
    keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
    parameter: {
      pattern: /\$(?:10|\d)/,
      alias: "variable"
    },
    variable: /\b\w+(?=:)/,
    number: /(?:\b|-)\d+\b/,
    operator: /\.\.\.|->|&|\.?=/,
    punctuation: /\(#|#\)|[,:;\[\](){}]/
  };
}
Mh.displayName = "mongodb";
Mh.aliases = [];
function Mh(e) {
  e.register(Bt), (function(t) {
    var a = [
      // query and projection
      "$eq",
      "$gt",
      "$gte",
      "$in",
      "$lt",
      "$lte",
      "$ne",
      "$nin",
      "$and",
      "$not",
      "$nor",
      "$or",
      "$exists",
      "$type",
      "$expr",
      "$jsonSchema",
      "$mod",
      "$regex",
      "$text",
      "$where",
      "$geoIntersects",
      "$geoWithin",
      "$near",
      "$nearSphere",
      "$all",
      "$elemMatch",
      "$size",
      "$bitsAllClear",
      "$bitsAllSet",
      "$bitsAnyClear",
      "$bitsAnySet",
      "$comment",
      "$elemMatch",
      "$meta",
      "$slice",
      // update
      "$currentDate",
      "$inc",
      "$min",
      "$max",
      "$mul",
      "$rename",
      "$set",
      "$setOnInsert",
      "$unset",
      "$addToSet",
      "$pop",
      "$pull",
      "$push",
      "$pullAll",
      "$each",
      "$position",
      "$slice",
      "$sort",
      "$bit",
      // aggregation pipeline stages
      "$addFields",
      "$bucket",
      "$bucketAuto",
      "$collStats",
      "$count",
      "$currentOp",
      "$facet",
      "$geoNear",
      "$graphLookup",
      "$group",
      "$indexStats",
      "$limit",
      "$listLocalSessions",
      "$listSessions",
      "$lookup",
      "$match",
      "$merge",
      "$out",
      "$planCacheStats",
      "$project",
      "$redact",
      "$replaceRoot",
      "$replaceWith",
      "$sample",
      "$set",
      "$skip",
      "$sort",
      "$sortByCount",
      "$unionWith",
      "$unset",
      "$unwind",
      "$setWindowFields",
      // aggregation pipeline operators
      "$abs",
      "$accumulator",
      "$acos",
      "$acosh",
      "$add",
      "$addToSet",
      "$allElementsTrue",
      "$and",
      "$anyElementTrue",
      "$arrayElemAt",
      "$arrayToObject",
      "$asin",
      "$asinh",
      "$atan",
      "$atan2",
      "$atanh",
      "$avg",
      "$binarySize",
      "$bsonSize",
      "$ceil",
      "$cmp",
      "$concat",
      "$concatArrays",
      "$cond",
      "$convert",
      "$cos",
      "$dateFromParts",
      "$dateToParts",
      "$dateFromString",
      "$dateToString",
      "$dayOfMonth",
      "$dayOfWeek",
      "$dayOfYear",
      "$degreesToRadians",
      "$divide",
      "$eq",
      "$exp",
      "$filter",
      "$first",
      "$floor",
      "$function",
      "$gt",
      "$gte",
      "$hour",
      "$ifNull",
      "$in",
      "$indexOfArray",
      "$indexOfBytes",
      "$indexOfCP",
      "$isArray",
      "$isNumber",
      "$isoDayOfWeek",
      "$isoWeek",
      "$isoWeekYear",
      "$last",
      "$last",
      "$let",
      "$literal",
      "$ln",
      "$log",
      "$log10",
      "$lt",
      "$lte",
      "$ltrim",
      "$map",
      "$max",
      "$mergeObjects",
      "$meta",
      "$min",
      "$millisecond",
      "$minute",
      "$mod",
      "$month",
      "$multiply",
      "$ne",
      "$not",
      "$objectToArray",
      "$or",
      "$pow",
      "$push",
      "$radiansToDegrees",
      "$range",
      "$reduce",
      "$regexFind",
      "$regexFindAll",
      "$regexMatch",
      "$replaceOne",
      "$replaceAll",
      "$reverseArray",
      "$round",
      "$rtrim",
      "$second",
      "$setDifference",
      "$setEquals",
      "$setIntersection",
      "$setIsSubset",
      "$setUnion",
      "$size",
      "$sin",
      "$slice",
      "$split",
      "$sqrt",
      "$stdDevPop",
      "$stdDevSamp",
      "$strcasecmp",
      "$strLenBytes",
      "$strLenCP",
      "$substr",
      "$substrBytes",
      "$substrCP",
      "$subtract",
      "$sum",
      "$switch",
      "$tan",
      "$toBool",
      "$toDate",
      "$toDecimal",
      "$toDouble",
      "$toInt",
      "$toLong",
      "$toObjectId",
      "$toString",
      "$toLower",
      "$toUpper",
      "$trim",
      "$trunc",
      "$type",
      "$week",
      "$year",
      "$zip",
      "$count",
      "$dateAdd",
      "$dateDiff",
      "$dateSubtract",
      "$dateTrunc",
      "$getField",
      "$rand",
      "$sampleRate",
      "$setField",
      "$unsetField",
      // aggregation pipeline query modifiers
      "$comment",
      "$explain",
      "$hint",
      "$max",
      "$maxTimeMS",
      "$min",
      "$orderby",
      "$query",
      "$returnKey",
      "$showDiskLoc",
      "$natural"
    ], i = [
      "ObjectId",
      "Code",
      "BinData",
      "DBRef",
      "Timestamp",
      "NumberLong",
      "NumberDecimal",
      "MaxKey",
      "MinKey",
      "RegExp",
      "ISODate",
      "UUID"
    ];
    a = a.map(function(l) {
      return l.replace("$", "\\$");
    });
    var o = "(?:" + a.join("|") + ")\\b";
    t.languages.mongodb = t.languages.extend("javascript", {}), t.languages.insertBefore("mongodb", "string", {
      property: {
        pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
        greedy: !0,
        inside: {
          keyword: RegExp(`^(['"])?` + o + "(?:\\1)?$")
        }
      }
    }), t.languages.mongodb.string.inside = {
      url: {
        // url pattern
        pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
        greedy: !0
      },
      entity: {
        // ipv4
        pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
        greedy: !0
      }
    }, t.languages.insertBefore("mongodb", "constant", {
      builtin: {
        pattern: RegExp("\\b(?:" + i.join("|") + ")\\b"),
        alias: "keyword"
      }
    });
  })(e);
}
Uh.displayName = "monkey";
Uh.aliases = [];
function Uh(e) {
  e.languages.monkey = {
    comment: {
      pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
      greedy: !0
    },
    string: {
      pattern: /"[^"\r\n]*"/,
      greedy: !0
    },
    preprocessor: {
      pattern: /(^[ \t]*)#.+/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    },
    function: /\b\w+(?=\()/,
    "type-char": {
      pattern: /\b[?%#$]/,
      alias: "class-name"
    },
    number: {
      pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
      lookbehind: !0
    },
    keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
    operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
    punctuation: /[.,:;()\[\]]/
  };
}
Bh.displayName = "moonscript";
Bh.aliases = ["moon"];
function Bh(e) {
  e.languages.moonscript = {
    comment: /--.*/,
    string: [
      {
        pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
        greedy: !0
      },
      {
        pattern: /"[^"]*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /#\{[^{}]*\}/,
            inside: {
              moonscript: {
                pattern: /(^#\{)[\s\S]+(?=\})/,
                lookbehind: !0,
                inside: null
                // see beow
              },
              "interpolation-punctuation": {
                pattern: /#\{|\}/,
                alias: "punctuation"
              }
            }
          }
        }
      }
    ],
    "class-name": [
      {
        pattern: /(\b(?:class|extends)[ \t]+)\w+/,
        lookbehind: !0
      },
      // class-like names start with a capital letter
      /\b[A-Z]\w*/
    ],
    keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
    variable: /@@?\w*/,
    property: {
      pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
      lookbehind: !0
    },
    function: {
      pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
      inside: {
        punctuation: /\./
      }
    },
    boolean: /\b(?:false|true)\b/,
    number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
    operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
    punctuation: /[.,()[\]{}\\]/
  }, e.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = e.languages.moonscript, e.languages.moon = e.languages.moonscript;
}
Fh.displayName = "n1ql";
Fh.aliases = [];
function Fh(e) {
  e.languages.n1ql = {
    comment: {
      pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
      greedy: !0
    },
    string: {
      pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
      greedy: !0
    },
    identifier: {
      pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
      greedy: !0
    },
    parameter: /\$[\w.]+/,
    // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
    keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    boolean: /\b(?:FALSE|TRUE)\b/i,
    number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
    punctuation: /[;[\](),.{}:]/
  };
}
Ph.displayName = "nand2tetris-hdl";
Ph.aliases = [];
function Ph(e) {
  e.languages["nand2tetris-hdl"] = {
    comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
    number: /\b\d+\b/,
    operator: /=|\.\./,
    punctuation: /[{}[\];(),:]/
  };
}
Hh.displayName = "naniscript";
Hh.aliases = ["nani"];
function Hh(e) {
  (function(t) {
    var a = /\{[^\r\n\[\]{}]*\}/, i = {
      "quoted-string": {
        pattern: /"(?:[^"\\]|\\.)*"/,
        alias: "operator"
      },
      "command-param-id": {
        pattern: /(\s)\w+:/,
        lookbehind: !0,
        alias: "property"
      },
      "command-param-value": [
        {
          pattern: a,
          alias: "selector"
        },
        {
          pattern: /([\t ])\S+/,
          lookbehind: !0,
          greedy: !0,
          alias: "operator"
        },
        {
          pattern: /\S(?:.*\S)?/,
          alias: "operator"
        }
      ]
    };
    t.languages.naniscript = {
      // ; ...
      comment: {
        pattern: /^([\t ]*);.*/m,
        lookbehind: !0
      },
      // > ...
      // Define is a control line starting with '>' followed by a word, a space and a text.
      define: {
        pattern: /^>.+/m,
        alias: "tag",
        inside: {
          value: {
            pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
            lookbehind: !0,
            alias: "operator"
          },
          key: {
            pattern: /(^>)\w+/,
            lookbehind: !0
          }
        }
      },
      // # ...
      label: {
        pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
        lookbehind: !0,
        alias: "regex"
      },
      command: {
        pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
        lookbehind: !0,
        alias: "function",
        inside: {
          "command-name": /^@\w+/,
          expression: {
            pattern: a,
            greedy: !0,
            alias: "selector"
          },
          "command-params": {
            pattern: /\s*\S[\s\S]*/,
            inside: i
          }
        }
      },
      // Generic is any line that doesn't start with operators: ;>#@
      "generic-text": {
        pattern: /(^[ \t]*)[^#@>;\s].*/m,
        lookbehind: !0,
        alias: "punctuation",
        inside: {
          // \{ ... \} ... \[ ... \] ... \"
          "escaped-char": /\\[{}\[\]"]/,
          expression: {
            pattern: a,
            greedy: !0,
            alias: "selector"
          },
          "inline-command": {
            pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
            greedy: !0,
            alias: "function",
            inside: {
              "command-params": {
                pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                lookbehind: !0,
                inside: i
              },
              "command-param-name": {
                pattern: /^(\[[\t ]*)\w+/,
                lookbehind: !0,
                alias: "name"
              },
              "start-stop-char": /[\[\]]/
            }
          }
        }
      }
    }, t.languages.nani = t.languages.naniscript, t.hooks.add("after-tokenize", function(c) {
      var d = c.tokens;
      d.forEach(function(m) {
        if (typeof m != "string" && m.type === "generic-text") {
          var f = l(m);
          o(f) || (m.type = "bad-line", m.content = f);
        }
      });
    });
    function o(c) {
      for (var d = "[]{}", m = [], f = 0; f < c.length; f++) {
        var b = c[f], E = d.indexOf(b);
        if (E !== -1) {
          if (E % 2 === 0)
            m.push(E + 1);
          else if (m.pop() !== E)
            return !1;
        }
      }
      return m.length === 0;
    }
    function l(c) {
      return typeof c == "string" ? c : Array.isArray(c) ? c.map(l).join("") : l(c.content);
    }
  })(e);
}
zh.displayName = "nasm";
zh.aliases = [];
function zh(e) {
  e.languages.nasm = {
    comment: /;.*$/m,
    string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    label: {
      pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
      lookbehind: !0,
      alias: "function"
    },
    keyword: [
      /\[?BITS (?:16|32|64)\]?/,
      {
        pattern: /(^\s*)section\s*[a-z.]+:?/im,
        lookbehind: !0
      },
      /(?:extern|global)[^;\r\n]*/i,
      /(?:CPU|DEFAULT|FLOAT).*$/m
    ],
    register: {
      pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
      alias: "variable"
    },
    number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
    operator: /[\[\]*+\-\/%<>=&|$!]/
  };
}
Gh.displayName = "neon";
Gh.aliases = [];
function Gh(e) {
  e.languages.neon = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    datetime: {
      pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
      lookbehind: !0,
      alias: "number"
    },
    key: {
      pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
      lookbehind: !0,
      alias: "property"
    },
    number: {
      pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
      lookbehind: !0
    },
    boolean: {
      pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
      lookbehind: !0
    },
    null: {
      pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
      lookbehind: !0,
      alias: "keyword"
    },
    string: {
      pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
      lookbehind: !0,
      greedy: !0
    },
    literal: {
      pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
      lookbehind: !0,
      alias: "string"
    },
    punctuation: /[,:=[\]{}()-]/
  };
}
jh.displayName = "nevod";
jh.aliases = [];
function jh(e) {
  e.languages.nevod = {
    comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
    string: {
      pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
      greedy: !0,
      inside: {
        "string-attrs": /!$|!\*$|\*$/
      }
    },
    namespace: {
      pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
      lookbehind: !0
    },
    pattern: {
      pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
      lookbehind: !0,
      inside: {
        "pattern-name": {
          pattern: /^#?[a-zA-Z0-9\-.]+/,
          alias: "class-name"
        },
        fields: {
          pattern: /\(.*\)/,
          inside: {
            "field-name": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "variable"
            },
            punctuation: /[,()]/,
            operator: {
              pattern: /~/,
              alias: "field-hidden-mark"
            }
          }
        }
      }
    },
    search: {
      pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
      alias: "function",
      lookbehind: !0
    },
    keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
    "standard-pattern": {
      pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
      inside: {
        "standard-pattern-name": {
          pattern: /^[a-zA-Z0-9\-.]+/,
          alias: "builtin"
        },
        quantifier: {
          pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
          alias: "number"
        },
        "standard-pattern-attr": {
          pattern: /[a-zA-Z0-9\-.]+/,
          alias: "builtin"
        },
        punctuation: /[,()]/
      }
    },
    quantifier: {
      pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
      alias: "number"
    },
    operator: [
      {
        pattern: /=/,
        alias: "pattern-def"
      },
      {
        pattern: /&/,
        alias: "conjunction"
      },
      {
        pattern: /~/,
        alias: "exception"
      },
      {
        pattern: /\?/,
        alias: "optionality"
      },
      {
        pattern: /[[\]]/,
        alias: "repetition"
      },
      {
        pattern: /[{}]/,
        alias: "variation"
      },
      {
        pattern: /[+_]/,
        alias: "sequence"
      },
      {
        pattern: /\.{2,3}/,
        alias: "span"
      }
    ],
    "field-capture": [
      {
        pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
        lookbehind: !0,
        inside: {
          "field-name": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "variable"
          },
          colon: /:/
        }
      },
      {
        pattern: /[a-zA-Z0-9\-.]+\s*:/,
        inside: {
          "field-name": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "variable"
          },
          colon: /:/
        }
      }
    ],
    punctuation: /[:;,()]/,
    name: /[a-zA-Z0-9\-.]+/
  };
}
$h.displayName = "nginx";
$h.aliases = [];
function $h(e) {
  (function(t) {
    var a = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
    t.languages.nginx = {
      comment: {
        pattern: /(^|[\s{};])#.*/,
        lookbehind: !0,
        greedy: !0
      },
      directive: {
        pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          string: {
            pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
            lookbehind: !0,
            greedy: !0,
            inside: {
              escape: {
                pattern: /\\["'\\nrt]/,
                alias: "entity"
              },
              variable: a
            }
          },
          comment: {
            pattern: /(\s)#.*/,
            lookbehind: !0,
            greedy: !0
          },
          keyword: {
            pattern: /^\S+/,
            greedy: !0
          },
          // other patterns
          boolean: {
            pattern: /(\s)(?:off|on)(?!\S)/,
            lookbehind: !0
          },
          number: {
            pattern: /(\s)\d+[a-z]*(?!\S)/i,
            lookbehind: !0
          },
          variable: a
        }
      },
      punctuation: /[{};]/
    };
  })(e);
}
qh.displayName = "nim";
qh.aliases = [];
function qh(e) {
  e.languages.nim = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    string: {
      // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
      pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
      greedy: !0
    },
    char: {
      // Character literals are handled specifically to prevent issues with numeric type suffixes
      pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
      greedy: !0
    },
    function: {
      pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
      greedy: !0,
      inside: {
        operator: /\*$/
      }
    },
    // We don't want to highlight operators (and anything really) inside backticks
    identifier: {
      pattern: /`[^`\r\n]+`/,
      greedy: !0,
      inside: {
        punctuation: /`/
      }
    },
    // The negative look ahead prevents wrong highlighting of the .. operator
    number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
    keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
    operator: {
      // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
      // but allow the slice operator .. to take precedence over them
      // One can define his own operators in Nim so all combination of operators might be an operator.
      pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
      lookbehind: !0
    },
    punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
  };
}
Yh.displayName = "nix";
Yh.aliases = [];
function Yh(e) {
  e.languages.nix = {
    comment: {
      pattern: /\/\*[\s\S]*?\*\/|#.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
      greedy: !0,
      inside: {
        interpolation: {
          // The lookbehind ensures the ${} is not preceded by \ or ''
          pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
          lookbehind: !0,
          inside: null
          // see below
        }
      }
    },
    url: [
      /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
      {
        pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
        lookbehind: !0
      }
    ],
    antiquotation: {
      pattern: /\$(?=\{)/,
      alias: "important"
    },
    number: /\b\d+\b/,
    keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
    function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
    boolean: /\b(?:false|true)\b/,
    operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
    punctuation: /[{}()[\].,:;]/
  }, e.languages.nix.string.inside.interpolation.inside = e.languages.nix;
}
Vh.displayName = "nsis";
Vh.aliases = [];
function Vh(e) {
  e.languages.nsis = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: {
      pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|KnownFolderPath|LabelAddress|TempFileName|WinVer)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|RtlLanguage|ShellVarContextAll|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|Target|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
      lookbehind: !0
    },
    property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
    constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
    variable: /\$\w[\w\.]*/,
    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
    operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
    punctuation: /[{}[\];(),.:]/,
    important: {
      pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
      lookbehind: !0
    }
  };
}
Wh.displayName = "objectivec";
Wh.aliases = ["objc"];
function Wh(e) {
  e.register(jn), e.languages.objectivec = e.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete e.languages.objectivec["class-name"], e.languages.objc = e.languages.objectivec;
}
Xh.displayName = "ocaml";
Xh.aliases = [];
function Xh(e) {
  e.languages.ocaml = {
    comment: {
      pattern: /\(\*[\s\S]*?\*\)/,
      greedy: !0
    },
    char: {
      pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
      greedy: !0
    },
    string: [
      {
        pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
        greedy: !0
      },
      {
        pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
        greedy: !0
      }
    ],
    number: [
      // binary and octal
      /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
      // hexadecimal
      /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
      // decimal
      /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
    ],
    directive: {
      pattern: /\B#\w+/,
      alias: "property"
    },
    label: {
      pattern: /\B~\w+/,
      alias: "property"
    },
    "type-variable": {
      pattern: /\B'\w+/,
      alias: "function"
    },
    variant: {
      pattern: /`\w+/,
      alias: "symbol"
    },
    // For the list of keywords and operators,
    // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
    keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
    boolean: /\b(?:false|true)\b/,
    "operator-like-punctuation": {
      pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
      alias: "punctuation"
    },
    // Custom operators are allowed
    operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
    punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
  };
}
Kh.displayName = "odin";
Kh.aliases = [];
function Kh(e) {
  (function(t) {
    var a = /\\(?:["'\\abefnrtv]|0[0-7]{2}|U[\dA-Fa-f]{6}|u[\dA-Fa-f]{4}|x[\dA-Fa-f]{2})/;
    t.languages.odin = {
      /**
       * The current implementation supports only 1 level of nesting.
       *
       * @author Michael Schmidt
       * @author edukisto
       */
      comment: [
        {
          pattern: /\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:\*(?!\/)|[^*])*(?:\*\/|$))*(?:\*\/|$)/,
          greedy: !0
        },
        {
          pattern: /#![^\n\r]*/,
          greedy: !0
        },
        {
          pattern: /\/\/[^\n\r]*/,
          greedy: !0
        }
      ],
      /**
       * Should be found before strings because of '"'"- and '`'`-like sequences.
       */
      char: {
        pattern: /'(?:\\(?:.|[0Uux][0-9A-Fa-f]{1,6})|[^\n\r'\\])'/,
        greedy: !0,
        inside: {
          symbol: a
        }
      },
      string: [
        {
          pattern: /`[^`]*`/,
          greedy: !0
        },
        {
          pattern: /"(?:\\.|[^\n\r"\\])*"/,
          greedy: !0,
          inside: {
            symbol: a
          }
        }
      ],
      directive: {
        pattern: /#\w+/,
        alias: "property"
      },
      number: /\b0(?:b[01_]+|d[\d_]+|h_*(?:(?:(?:[\dA-Fa-f]_*){8}){1,2}|(?:[\dA-Fa-f]_*){4})|o[0-7_]+|x[\dA-F_a-f]+|z[\dAB_ab]+)\b|(?:\b\d+(?:\.(?!\.)\d*)?|\B\.\d+)(?:[Ee][+-]?\d*)?[ijk]?(?!\w)/,
      discard: {
        pattern: /\b_\b/,
        alias: "keyword"
      },
      "procedure-definition": {
        pattern: /\b\w+(?=[ \t]*(?::\s*){2}proc\b)/,
        alias: "function"
      },
      keyword: /\b(?:asm|auto_cast|bit_set|break|case|cast|context|continue|defer|distinct|do|dynamic|else|enum|fallthrough|for|foreign|if|import|in|map|matrix|not_in|or_else|or_return|package|proc|return|struct|switch|transmute|typeid|union|using|when|where)\b/,
      /**
       * false, nil, true can be used as procedure names. "_" and keywords can't.
       */
      "procedure-name": {
        pattern: /\b\w+(?=[ \t]*\()/,
        alias: "function"
      },
      boolean: /\b(?:false|nil|true)\b/,
      "constant-parameter-sign": {
        pattern: /\$/,
        alias: "important"
      },
      undefined: {
        pattern: /---/,
        alias: "operator"
      },
      arrow: {
        pattern: /->/,
        alias: "punctuation"
      },
      operator: /\+\+|--|\.\.[<=]?|(?:&~|[-!*+/=~]|[%&<>|]{1,2})=?|[?^]/,
      punctuation: /[(),.:;@\[\]{}]/
    };
  })(e);
}
Zh.displayName = "opencl";
Zh.aliases = [];
function Zh(e) {
  e.register(jn), (function(t) {
    t.languages.opencl = t.languages.extend("c", {
      // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
      keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
      // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
      // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
      // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
      number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
      boolean: /\b(?:false|true)\b/,
      "constant-opencl-kernel": {
        pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
        alias: "constant"
      }
    }), t.languages.insertBefore("opencl", "class-name", {
      // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
      // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
      "builtin-type": {
        pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
        alias: "keyword"
      }
    });
    var a = {
      // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
      "type-opencl-host": {
        pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
        alias: "keyword"
      },
      "boolean-opencl-host": {
        pattern: /\bCL_(?:FALSE|TRUE)\b/,
        alias: "boolean"
      },
      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
      "constant-opencl-host": {
        pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
        alias: "constant"
      },
      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
      "function-opencl-host": {
        pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
        alias: "function"
      }
    };
    t.languages.insertBefore("c", "keyword", a), t.languages.cpp && (a["type-opencl-host-cpp"] = {
      pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
      alias: "keyword"
    }, t.languages.insertBefore("cpp", "keyword", a));
  })(e);
}
Qh.displayName = "openqasm";
Qh.aliases = ["qasm"];
function Qh(e) {
  e.languages.openqasm = {
    comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
    string: {
      pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
      greedy: !0
    },
    keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
    "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
    function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
    constant: /\b(?:euler|pi|tau)\b|||/,
    number: {
      pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|s|ms|s)?/i,
      lookbehind: !0
    },
    operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
    punctuation: /[(){}\[\];,:.]/
  }, e.languages.qasm = e.languages.openqasm;
}
Jh.displayName = "oz";
Jh.aliases = [];
function Jh(e) {
  e.languages.oz = {
    comment: {
      pattern: /\/\*[\s\S]*?\*\/|%.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:[^"\\]|\\[\s\S])*"/,
      greedy: !0
    },
    atom: {
      pattern: /'(?:[^'\\]|\\[\s\S])*'/,
      greedy: !0,
      alias: "builtin"
    },
    keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
    function: [
      /\b[a-z][A-Za-z\d]*(?=\()/,
      {
        pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
        lookbehind: !0
      }
    ],
    number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
    variable: /`(?:[^`\\]|\\.)+`/,
    "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
    operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
    punctuation: /[\[\](){}.:;?]/
  };
}
eb.displayName = "parigp";
eb.aliases = [];
function eb(e) {
  e.languages.parigp = {
    comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
    string: {
      pattern: /"(?:[^"\\\r\n]|\\.)*"/,
      greedy: !0
    },
    // PARI/GP does not care about white spaces at all
    // so let's process the keywords to build an appropriate regexp
    // (e.g. "b *r *e *a *k", etc.)
    keyword: (function() {
      var t = [
        "breakpoint",
        "break",
        "dbg_down",
        "dbg_err",
        "dbg_up",
        "dbg_x",
        "forcomposite",
        "fordiv",
        "forell",
        "forpart",
        "forprime",
        "forstep",
        "forsubgroup",
        "forvec",
        "for",
        "iferr",
        "if",
        "local",
        "my",
        "next",
        "return",
        "until",
        "while"
      ];
      return t = t.map(function(a) {
        return a.split("").join(" *");
      }).join("|"), RegExp("\\b(?:" + t + ")\\b");
    })(),
    function: /\b\w(?:[\w ]*\w)?(?= *\()/,
    number: {
      // The lookbehind and the negative lookahead prevent from breaking the .. operator
      pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
      lookbehind: !0
    },
    operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
    punctuation: /[\[\]{}().,:;|]/
  };
}
tb.displayName = "parser";
tb.aliases = [];
function tb(e) {
  e.register(xt), (function(t) {
    var a = t.languages.parser = t.languages.extend("markup", {
      keyword: {
        pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
        lookbehind: !0
      },
      variable: {
        pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
        lookbehind: !0,
        inside: {
          punctuation: /\.|:+/
        }
      },
      function: {
        pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /(^@)(?:GET_|SET_)/,
            lookbehind: !0
          },
          punctuation: /\.|:+/
        }
      },
      escape: {
        pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
        alias: "builtin"
      },
      punctuation: /[\[\](){};]/
    });
    a = t.languages.insertBefore("parser", "keyword", {
      "parser-comment": {
        pattern: /(\s)#.*/,
        lookbehind: !0,
        alias: "comment"
      },
      expression: {
        // Allow for 3 levels of depth
        pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
        greedy: !0,
        lookbehind: !0,
        inside: {
          string: {
            pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
            lookbehind: !0
          },
          keyword: a.keyword,
          variable: a.variable,
          function: a.function,
          boolean: /\b(?:false|true)\b/,
          number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
          escape: a.escape,
          operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
          punctuation: a.punctuation
        }
      }
    }), t.languages.insertBefore(
      "inside",
      "punctuation",
      {
        expression: a.expression,
        keyword: a.keyword,
        variable: a.variable,
        function: a.function,
        escape: a.escape,
        "parser-punctuation": {
          pattern: a.punctuation,
          alias: "punctuation"
        }
      },
      a.tag.inside["attr-value"]
    );
  })(e);
}
nb.displayName = "pascal";
nb.aliases = ["objectpascal"];
function nb(e) {
  e.languages.pascal = {
    directive: {
      pattern: /\{\$[\s\S]*?\}/,
      greedy: !0,
      alias: ["marco", "property"]
    },
    comment: {
      pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
      greedy: !0
    },
    string: {
      pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
      greedy: !0
    },
    asm: {
      pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
      lookbehind: !0,
      greedy: !0,
      inside: null
      // see below
    },
    keyword: [
      {
        // Turbo Pascal
        pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
        lookbehind: !0
      },
      {
        // Free Pascal
        pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
        lookbehind: !0
      },
      {
        // Object Pascal
        pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
        lookbehind: !0
      },
      {
        // Modifiers
        pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
        lookbehind: !0
      }
    ],
    number: [
      // Hexadecimal, octal and binary
      /(?:[&%]\d+|\$[a-f\d]+)/i,
      // Decimal
      /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
    ],
    operator: [
      /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
      {
        pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
        lookbehind: !0
      }
    ],
    punctuation: /\(\.|\.\)|[()\[\]:;,.]/
  }, e.languages.pascal.asm.inside = e.languages.extend("pascal", {
    asm: void 0,
    keyword: void 0,
    operator: void 0
  }), e.languages.objectpascal = e.languages.pascal;
}
ab.displayName = "pascaligo";
ab.aliases = [];
function ab(e) {
  (function(t) {
    var a = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source, i = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
      /<braces>/g,
      function() {
        return a;
      }
    ), o = t.languages.pascaligo = {
      comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
      string: {
        pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
        greedy: !0
      },
      "class-name": [
        {
          pattern: RegExp(
            /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
              /<type>/g,
              function() {
                return i;
              }
            ),
            "i"
          ),
          lookbehind: !0,
          inside: null
          // see below
        },
        {
          pattern: RegExp(
            /<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
              return i;
            }),
            "i"
          ),
          inside: null
          // see below
        },
        {
          pattern: RegExp(
            /(:\s*)<type>/.source.replace(/<type>/g, function() {
              return i;
            })
          ),
          lookbehind: !0,
          inside: null
          // see below
        }
      ],
      keyword: {
        pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[^&])\b(?:False|True)\b/i,
        lookbehind: !0
      },
      builtin: {
        pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
        lookbehind: !0
      },
      function: /\b\w+(?=\s*\()/,
      number: [
        // Hexadecimal, octal and binary
        /%[01]+|&[0-7]+|\$[a-f\d]+/i,
        // Decimal
        /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
      ],
      operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
      punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
    }, l = [
      "comment",
      "keyword",
      "builtin",
      "operator",
      "punctuation"
    ].reduce(function(c, d) {
      return c[d] = o[d], c;
    }, {});
    o["class-name"].forEach(function(c) {
      c.inside = l;
    });
  })(e);
}
rb.displayName = "psl";
rb.aliases = [];
function rb(e) {
  e.languages.psl = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    string: {
      pattern: /"(?:\\.|[^\\"])*"/,
      greedy: !0,
      inside: {
        symbol: /\\[ntrbA-Z"\\]/
      }
    },
    "heredoc-string": {
      pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
      alias: "string",
      greedy: !0
    },
    keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
    constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
    boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
    variable: /\b(?:PslDebug|errno|exit_status)\b/,
    builtin: {
      pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
      alias: "builtin-function"
    },
    "foreach-variable": {
      pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
      lookbehind: !0,
      greedy: !0
    },
    function: /\b[_a-z]\w*\b(?=\s*\()/i,
    number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
    operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
    punctuation: /[(){}\[\];,]/
  };
}
ib.displayName = "pcaxis";
ib.aliases = ["px"];
function ib(e) {
  e.languages.pcaxis = {
    string: /"[^"]*"/,
    keyword: {
      pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        keyword: /^[-A-Z\d]+/,
        language: {
          pattern: /^(\s*)\[[-\w]+\]/,
          lookbehind: !0,
          inside: {
            punctuation: /^\[|\]$/,
            property: /[-\w]+/
          }
        },
        "sub-key": {
          pattern: /^(\s*)\S[\s\S]*/,
          lookbehind: !0,
          inside: {
            parameter: {
              pattern: /"[^"]*"/,
              alias: "property"
            },
            punctuation: /^\(|\)$|,/
          }
        }
      }
    },
    operator: /=/,
    tlist: {
      pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
      greedy: !0,
      inside: {
        function: /^TLIST/,
        property: {
          pattern: /^(\s*\(\s*)\w+/,
          lookbehind: !0
        },
        string: /"[^"]*"/,
        punctuation: /[(),]/,
        operator: /-/
      }
    },
    punctuation: /[;,]/,
    number: {
      pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
      lookbehind: !0
    },
    boolean: /NO|YES/
  }, e.languages.px = e.languages.pcaxis;
}
sb.displayName = "peoplecode";
sb.aliases = ["pcode"];
function sb(e) {
  e.languages.peoplecode = {
    comment: RegExp(
      [
        // C-style multiline comments
        /\/\*[\s\S]*?\*\//.source,
        // REM comments
        /\bREM[^;]*;/.source,
        // Nested <* *> comments
        /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
        // /+ +/ comments
        /\/\+[\s\S]*?\+\//.source
      ].join("|")
    ),
    string: {
      pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
      greedy: !0
    },
    variable: /%\w+/,
    "function-definition": {
      pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
      lookbehind: !0,
      alias: "function"
    },
    "class-name": {
      pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
      lookbehind: !0,
      inside: {
        punctuation: /:/
      }
    },
    keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
    "operator-keyword": {
      pattern: /\b(?:and|not|or)\b/i,
      alias: "operator"
    },
    function: /[_a-z]\w*(?=\s*\()/i,
    boolean: /\b(?:false|true)\b/i,
    number: /\b\d+(?:\.\d+)?\b/,
    operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
    punctuation: /[:.;,()[\]]/
  }, e.languages.pcode = e.languages.peoplecode;
}
ob.displayName = "perl";
ob.aliases = [];
function ob(e) {
  (function(t) {
    var a = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    t.languages.perl = {
      comment: [
        {
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      // TODO Could be nice to handle Heredoc too.
      string: [
        {
          pattern: RegExp(
            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              a
            ].join("|") + ")"
          ),
          greedy: !0
        },
        // "...", `...`
        {
          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
          greedy: !0
        },
        // '...'
        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
        {
          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
          greedy: !0
        }
      ],
      regex: [
        {
          pattern: RegExp(
            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              a
            ].join("|") + ")" + /[msixpodualngc]*/.source
          ),
          greedy: !0
        },
        // The lookbehinds prevent -s from breaking
        {
          pattern: RegExp(
            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              a + /\s*/.source + a
            ].join("|") + ")" + /[msixpodualngcer]*/.source
          ),
          lookbehind: !0,
          greedy: !0
        },
        // /.../
        // The look-ahead tries to prevent two divisions on
        // the same line from being highlighted as regex.
        // This does not support multi-line regex.
        {
          pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
          greedy: !0
        }
      ],
      // FIXME Not sure about the handling of ::, ', and #
      variable: [
        // ${^POSTMATCH}
        /[&*$@%]\{\^[A-Z]+\}/,
        // $^V
        /[&*$@%]\^[A-Z_]/,
        // ${...}
        /[&*$@%]#?(?=\{)/,
        // $foo
        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
        // $1
        /[&*$@%]\d+/,
        // $_, @_, %!
        // The negative lookahead prevents from breaking the %= operator
        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
      ],
      filehandle: {
        // <>, <FOO>, _
        pattern: /<(?![<=])\S*?>|\b_\b/,
        alias: "symbol"
      },
      "v-string": {
        // v1.2, 1.2.3
        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
        alias: "string"
      },
      function: {
        pattern: /(\bsub[ \t]+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
      operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
      punctuation: /[{}[\];(),:]/
    };
  })(e);
}
lb.displayName = "phpdoc";
lb.aliases = [];
function lb(e) {
  e.register(Oi), e.register(Ii), (function(t) {
    var a = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
    t.languages.phpdoc = t.languages.extend("javadoclike", {
      parameter: {
        pattern: RegExp(
          "(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + a + "\\s+)?)\\$\\w+"
        ),
        lookbehind: !0
      }
    }), t.languages.insertBefore("phpdoc", "keyword", {
      "class-name": [
        {
          pattern: RegExp(
            "(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + a
          ),
          lookbehind: !0,
          inside: {
            keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
            punctuation: /[|\\[\]()]/
          }
        }
      ]
    }), t.languages.javadoclike.addSupport("php", t.languages.phpdoc);
  })(e);
}
ub.displayName = "php-extras";
ub.aliases = [];
function ub(e) {
  e.register(Ii), e.languages.insertBefore("php", "variable", {
    this: {
      pattern: /\$this\b/,
      alias: "keyword"
    },
    global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
    scope: {
      pattern: /\b[\w\\]+::/,
      inside: {
        keyword: /\b(?:parent|self|static)\b/,
        punctuation: /::|\\/
      }
    }
  });
}
cb.displayName = "plant-uml";
cb.aliases = ["plantuml"];
function cb(e) {
  (function(t) {
    var a = /\$\w+|%[a-z]+%/, i = /\[[^[\]]*\]/.source, o = /(?:[drlu]|do|down|le|left|ri|right|up)/.source, l = "(?:-+" + o + "-+|\\.+" + o + "\\.+|-+(?:" + i + "-*)?|" + i + "-+|\\.+(?:" + i + "\\.*)?|" + i + "\\.+)", c = /(?:<{1,2}|\/{1,2}|\\{1,2}|<\||[#*^+}xo])/.source, d = /(?:>{1,2}|\/{1,2}|\\{1,2}|\|>|[#*^+{xo])/.source, m = /[[?]?[ox]?/.source, f = /[ox]?[\]?]?/.source, b = m + "(?:" + l + d + "|" + c + l + "(?:" + d + ")?)" + f;
    t.languages["plant-uml"] = {
      comment: {
        pattern: /(^[ \t]*)(?:'.*|\/'[\s\S]*?'\/)/m,
        lookbehind: !0,
        greedy: !0
      },
      preprocessor: {
        pattern: /(^[ \t]*)!.*/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          variable: a
        }
      },
      delimiter: {
        pattern: /(^[ \t]*)@(?:end|start)uml\b/m,
        lookbehind: !0,
        greedy: !0,
        alias: "punctuation"
      },
      arrow: {
        pattern: RegExp(
          /(^|[^-.<>?|\\[\]ox])/.source + b + /(?![-.<>?|\\\]ox])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "operator",
        inside: {
          expression: {
            pattern: /(\[)[^[\]]+(?=\])/,
            lookbehind: !0,
            inside: null
            // see below
          },
          punctuation: /\[(?=$|\])|^\]/
        }
      },
      string: {
        pattern: /"[^"]*"/,
        greedy: !0
      },
      text: {
        pattern: /(\[[ \t]*[\r\n]+(?![\r\n]))[^\]]*(?=\])/,
        lookbehind: !0,
        greedy: !0,
        alias: "string"
      },
      keyword: [
        {
          pattern: /^([ \t]*)(?:abstract\s+class|end\s+(?:box|fork|group|merge|note|ref|split|title)|(?:fork|split)(?:\s+again)?|activate|actor|agent|alt|annotation|artifact|autoactivate|autonumber|backward|binary|boundary|box|break|caption|card|case|circle|class|clock|cloud|collections|component|concise|control|create|critical|database|deactivate|destroy|detach|diamond|else|elseif|end|end[hr]note|endif|endswitch|endwhile|entity|enum|file|folder|footer|frame|group|[hr]?note|header|hexagon|hide|if|interface|label|legend|loop|map|namespace|network|newpage|node|nwdiag|object|opt|package|page|par|participant|person|queue|rectangle|ref|remove|repeat|restore|return|robust|scale|set|show|skinparam|stack|start|state|stop|storage|switch|title|together|usecase|usecase\/|while)(?=\s|$)/m,
          lookbehind: !0,
          greedy: !0
        },
        /\b(?:elseif|equals|not|while)(?=\s*\()/,
        /\b(?:as|is|then)\b/
      ],
      divider: {
        pattern: /^==.+==$/m,
        greedy: !0,
        alias: "important"
      },
      time: {
        pattern: /@(?:\d+(?:[:/]\d+){2}|[+-]?\d+|:[a-z]\w*(?:[+-]\d+)?)\b/i,
        greedy: !0,
        alias: "number"
      },
      color: {
        pattern: /#(?:[a-z_]+|[a-fA-F0-9]+)\b/,
        alias: "symbol"
      },
      variable: a,
      punctuation: /[:,;()[\]{}]|\.{3}/
    }, t.languages["plant-uml"].arrow.inside.expression.inside = t.languages["plant-uml"], t.languages.plantuml = t.languages["plant-uml"];
  })(e);
}
db.displayName = "plsql";
db.aliases = [];
function db(e) {
  e.register(co), e.languages.plsql = e.languages.extend("sql", {
    comment: {
      pattern: /\/\*[\s\S]*?\*\/|--.*/,
      greedy: !0
    },
    // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
    keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
    // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
    operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
  }), e.languages.insertBefore("plsql", "operator", {
    label: {
      pattern: /<<\s*\w+\s*>>/,
      alias: "symbol"
    }
  });
}
pb.displayName = "powerquery";
pb.aliases = ["mscript", "pq"];
function pb(e) {
  e.languages.powerquery = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: !0,
      greedy: !0
    },
    "quoted-identifier": {
      pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
      greedy: !0
    },
    string: {
      pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
      greedy: !0
    },
    constant: [
      /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
      /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
      /\bOccurrence\.(?:All|First|Last)\b/,
      /\bOrder\.(?:Ascending|Descending)\b/,
      /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
      /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
      /\bQuoteStyle\.(?:Csv|None)\b/,
      /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
      /\bGroupKind\.(?:Global|Local)\b/,
      /\bExtraValues\.(?:Error|Ignore|List)\b/,
      /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
      /\bJoinSide\.(?:Left|Right)\b/,
      /\bPrecision\.(?:Decimal|Double)\b/,
      /\bRelativePosition\.From(?:End|Start)\b/,
      /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
      /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
      /\bnull\b/
    ],
    boolean: /\b(?:false|true)\b/,
    keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
    function: {
      pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
      lookbehind: !0
    },
    "data-type": {
      pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
      alias: "class-name"
    },
    number: {
      pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
      lookbehind: !0
    },
    operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
    punctuation: /[,;\[\](){}]/
  }, e.languages.pq = e.languages.powerquery, e.languages.mscript = e.languages.powerquery;
}
fb.displayName = "powershell";
fb.aliases = [];
function fb(e) {
  (function(t) {
    var a = t.languages.powershell = {
      comment: [
        {
          pattern: /(^|[^`])<#[\s\S]*?#>/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^`])#.*/,
          lookbehind: !0
        }
      ],
      string: [
        {
          pattern: /"(?:`[\s\S]|[^`"])*"/,
          greedy: !0,
          inside: null
          // see below
        },
        {
          pattern: /'(?:[^']|'')*'/,
          greedy: !0
        }
      ],
      // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
      // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
      namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
      boolean: /\$(?:false|true)\b/i,
      variable: /\$\w+\b/,
      // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
      // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
      // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
      function: [
        /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
        /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
      ],
      // per http://technet.microsoft.com/en-us/library/hh847744.aspx
      keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
      operator: {
        pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
        lookbehind: !0
      },
      punctuation: /[|{}[\];(),.]/
    };
    a.string[0].inside = {
      function: {
        // Allow for one level of nesting
        pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
        lookbehind: !0,
        inside: a
      },
      boolean: a.boolean,
      variable: a.variable
    };
  })(e);
}
mb.displayName = "processing";
mb.aliases = [];
function mb(e) {
  e.register(ze), e.languages.processing = e.languages.extend("clike", {
    keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
    // Spaces are allowed between function name and parenthesis
    function: /\b\w+(?=\s*\()/,
    operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
  }), e.languages.insertBefore("processing", "number", {
    // Special case: XML is a type
    constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
    type: {
      pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
      alias: "class-name"
    }
  });
}
gb.displayName = "prolog";
gb.aliases = [];
function gb(e) {
  e.languages.prolog = {
    // Syntax depends on the implementation
    comment: {
      pattern: /\/\*[\s\S]*?\*\/|%.*/,
      greedy: !0
    },
    // Depending on the implementation, strings may allow escaped newlines and quote-escape
    string: {
      pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
      greedy: !0
    },
    builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
    // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
    function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
    number: /\b\d+(?:\.\d*)?/,
    // Custom operators are allowed
    operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
    punctuation: /[(){}\[\],]/
  };
}
hb.displayName = "promql";
hb.aliases = [];
function hb(e) {
  (function(t) {
    var a = [
      "sum",
      "min",
      "max",
      "avg",
      "group",
      "stddev",
      "stdvar",
      "count",
      "count_values",
      "bottomk",
      "topk",
      "quantile"
    ], i = [
      "on",
      "ignoring",
      "group_right",
      "group_left",
      "by",
      "without"
    ], o = ["offset"], l = a.concat(i, o);
    t.languages.promql = {
      comment: {
        pattern: /(^[ \t]*)#.*/m,
        lookbehind: !0
      },
      "vector-match": {
        // Match the comma-separated label lists inside vector matching:
        pattern: new RegExp(
          "((?:" + i.join("|") + ")\\s*)\\([^)]*\\)"
        ),
        lookbehind: !0,
        inside: {
          "label-key": {
            pattern: /\b[^,]+\b/,
            alias: "attr-name"
          },
          punctuation: /[(),]/
        }
      },
      "context-labels": {
        pattern: /\{[^{}]*\}/,
        inside: {
          "label-key": {
            pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
            alias: "attr-name"
          },
          "label-value": {
            pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
            greedy: !0,
            alias: "attr-value"
          },
          punctuation: /\{|\}|=~?|![=~]|,/
        }
      },
      "context-range": [
        {
          pattern: /\[[\w\s:]+\]/,
          // [1m]
          inside: {
            punctuation: /\[|\]|:/,
            "range-duration": {
              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
              alias: "number"
            }
          }
        },
        {
          pattern: /(\boffset\s+)\w+/,
          // offset 1m
          lookbehind: !0,
          inside: {
            "range-duration": {
              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
              alias: "number"
            }
          }
        }
      ],
      keyword: new RegExp("\\b(?:" + l.join("|") + ")\\b", "i"),
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
      operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
      punctuation: /[{};()`,.[\]]/
    };
  })(e);
}
bb.displayName = "properties";
bb.aliases = [];
function bb(e) {
  e.languages.properties = {
    comment: /^[ \t]*[#!].*$/m,
    value: {
      pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
      lookbehind: !0,
      alias: "attr-value"
    },
    key: {
      pattern: /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
      alias: "attr-name"
    },
    punctuation: /[=:]/
  };
}
Eb.displayName = "protobuf";
Eb.aliases = [];
function Eb(e) {
  e.register(ze), (function(t) {
    var a = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
    t.languages.protobuf = t.languages.extend("clike", {
      "class-name": [
        {
          pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
          lookbehind: !0
        },
        {
          pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
          lookbehind: !0
        }
      ],
      keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
      function: /\b[a-z_]\w*(?=\s*\()/i
    }), t.languages.insertBefore("protobuf", "operator", {
      map: {
        pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
        alias: "class-name",
        inside: {
          punctuation: /[<>.,]/,
          builtin: a
        }
      },
      builtin: a,
      "positional-class-name": {
        pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
        alias: "class-name",
        inside: {
          punctuation: /\./
        }
      },
      annotation: {
        pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
        lookbehind: !0
      }
    });
  })(e);
}
yb.displayName = "stylus";
yb.aliases = [];
function yb(e) {
  (function(t) {
    var a = {
      pattern: /(\b\d+)(?:%|[a-z]+)/,
      lookbehind: !0
    }, i = {
      pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
      lookbehind: !0
    }, o = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0
      },
      url: {
        pattern: /\burl\((["']?).*?\1\)/i,
        greedy: !0
      },
      string: {
        pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
        greedy: !0
      },
      interpolation: null,
      // See below
      func: null,
      // See below
      important: /\B!(?:important|optional)\b/i,
      keyword: {
        pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
        lookbehind: !0
      },
      hexcode: /#[\da-f]{3,6}/i,
      color: [
        /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
        {
          pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
          inside: {
            unit: a,
            number: i,
            function: /[\w-]+(?=\()/,
            punctuation: /[(),]/
          }
        }
      ],
      entity: /\\[\da-f]{1,8}/i,
      unit: a,
      boolean: /\b(?:false|true)\b/,
      operator: [
        // We want non-word chars around "-" because it is
        // accepted in property names.
        /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
      ],
      number: i,
      punctuation: /[{}()\[\];:,]/
    };
    o.interpolation = {
      pattern: /\{[^\r\n}:]+\}/,
      alias: "variable",
      inside: {
        delimiter: {
          pattern: /^\{|\}$/,
          alias: "punctuation"
        },
        rest: o
      }
    }, o.func = {
      pattern: /[\w-]+\([^)]*\).*/,
      inside: {
        function: /^[^(]+/,
        rest: o
      }
    }, t.languages.stylus = {
      "atrule-declaration": {
        pattern: /(^[ \t]*)@.+/m,
        lookbehind: !0,
        inside: {
          atrule: /^@[\w-]+/,
          rest: o
        }
      },
      "variable-declaration": {
        pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
        lookbehind: !0,
        inside: {
          variable: /^\S+/,
          rest: o
        }
      },
      statement: {
        pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
        lookbehind: !0,
        inside: {
          keyword: /^\S+/,
          rest: o
        }
      },
      // A property/value pair cannot end with a comma or a brace
      // It cannot have indented content unless it ended with a semicolon
      "property-declaration": {
        pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
        lookbehind: !0,
        inside: {
          property: {
            pattern: /^[^\s:]+/,
            inside: {
              interpolation: o.interpolation
            }
          },
          rest: o
        }
      },
      // A selector can contain parentheses only as part of a pseudo-element
      // It can span multiple lines.
      // It must end with a comma or an accolade or have indented content.
      selector: {
        pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
        lookbehind: !0,
        inside: {
          interpolation: o.interpolation,
          comment: o.comment,
          punctuation: /[{},]/
        }
      },
      func: o.func,
      string: o.string,
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0,
        greedy: !0
      },
      interpolation: o.interpolation,
      punctuation: /[{}()\[\];:.]/
    };
  })(e);
}
Tb.displayName = "twig";
Tb.aliases = [];
function Tb(e) {
  e.register(Ft), e.languages.twig = {
    comment: /^\{#[\s\S]*?#\}$/,
    "tag-name": {
      pattern: /(^\{%-?\s*)\w+/,
      lookbehind: !0,
      alias: "keyword"
    },
    delimiter: {
      pattern: /^\{[{%]-?|-?[%}]\}$/,
      alias: "punctuation"
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      inside: {
        punctuation: /^['"]|['"]$/
      }
    },
    keyword: /\b(?:even|if|odd)\b/,
    boolean: /\b(?:false|null|true)\b/,
    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
    operator: [
      {
        pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
        lookbehind: !0
      },
      /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
    ],
    punctuation: /[()\[\]{}:.,]/
  }, e.hooks.add("before-tokenize", function(t) {
    if (t.language === "twig") {
      var a = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
      e.languages["markup-templating"].buildPlaceholders(t, "twig", a);
    }
  }), e.hooks.add("after-tokenize", function(t) {
    e.languages["markup-templating"].tokenizePlaceholders(t, "twig");
  });
}
Sb.displayName = "pug";
Sb.aliases = [];
function Sb(e) {
  e.register(Bt), e.register(xt), (function(t) {
    t.languages.pug = {
      // Multiline stuff should appear before the rest
      // This handles both single-line and multi-line comments
      comment: {
        pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
        lookbehind: !0
      },
      // All the tag-related part is in lookbehind
      // so that it can be highlighted by the "tag" pattern
      "multiline-script": {
        pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
        lookbehind: !0,
        inside: t.languages.javascript
      },
      // See at the end of the file for known filters
      filter: {
        pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
        lookbehind: !0,
        inside: {
          "filter-name": {
            pattern: /^:[\w-]+/,
            alias: "variable"
          },
          text: /\S[\s\S]*/
        }
      },
      "multiline-plain-text": {
        pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
        lookbehind: !0
      },
      markup: {
        pattern: /(^[\t ]*)<.+/m,
        lookbehind: !0,
        inside: t.languages.markup
      },
      doctype: {
        pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
        lookbehind: !0
      },
      // This handle all conditional and loop keywords
      "flow-control": {
        pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
        lookbehind: !0,
        inside: {
          each: {
            pattern: /^each .+? in\b/,
            inside: {
              keyword: /\b(?:each|in)\b/,
              punctuation: /,/
            }
          },
          branch: {
            pattern: /^(?:case|default|else|if|unless|when|while)\b/,
            alias: "keyword"
          },
          rest: t.languages.javascript
        }
      },
      keyword: {
        pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
        lookbehind: !0
      },
      mixin: [
        // Declaration
        {
          pattern: /(^[\t ]*)mixin .+/m,
          lookbehind: !0,
          inside: {
            keyword: /^mixin/,
            function: /\w+(?=\s*\(|\s*$)/,
            punctuation: /[(),.]/
          }
        },
        // Usage
        {
          pattern: /(^[\t ]*)\+.+/m,
          lookbehind: !0,
          inside: {
            name: {
              pattern: /^\+\w+/,
              alias: "function"
            },
            rest: t.languages.javascript
          }
        }
      ],
      script: {
        pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
        lookbehind: !0,
        inside: t.languages.javascript
      },
      "plain-text": {
        pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
        lookbehind: !0
      },
      tag: {
        pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
        lookbehind: !0,
        inside: {
          attributes: [
            {
              pattern: /&[^(]+\([^)]+\)/,
              inside: t.languages.javascript
            },
            {
              pattern: /\([^)]+\)/,
              inside: {
                "attr-value": {
                  pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                  lookbehind: !0,
                  inside: t.languages.javascript
                },
                "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                punctuation: /[!=(),]+/
              }
            }
          ],
          punctuation: /:/,
          "attr-id": /#[\w\-]+/,
          "attr-class": /\.[\w\-]+/
        }
      },
      code: [
        {
          pattern: /(^[\t ]*(?:-|!?=)).+/m,
          lookbehind: !0,
          inside: t.languages.javascript
        }
      ],
      punctuation: /[.\-!=|]+/
    };
    for (var a = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source, i = [
      {
        filter: "atpl",
        language: "twig"
      },
      {
        filter: "coffee",
        language: "coffeescript"
      },
      "ejs",
      "handlebars",
      "less",
      "livescript",
      "markdown",
      {
        filter: "sass",
        language: "scss"
      },
      "stylus"
    ], o = {}, l = 0, c = i.length; l < c; l++) {
      var d = i[l];
      d = typeof d == "string" ? {
        filter: d,
        language: d
      } : d, t.languages[d.language] && (o["filter-" + d.filter] = {
        pattern: RegExp(
          a.replace("<filter_name>", function() {
            return d.filter;
          }),
          "m"
        ),
        lookbehind: !0,
        inside: {
          "filter-name": {
            pattern: /^:[\w-]+/,
            alias: "variable"
          },
          text: {
            pattern: /\S[\s\S]*/,
            alias: [d.language, "language-" + d.language],
            inside: t.languages[d.language]
          }
        }
      });
    }
    t.languages.insertBefore("pug", "filter", o);
  })(e);
}
_b.displayName = "puppet";
_b.aliases = [];
function _b(e) {
  (function(t) {
    t.languages.puppet = {
      heredoc: [
        // Matches the content of a quoted heredoc string (subject to interpolation)
        {
          pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
          lookbehind: !0,
          alias: "string",
          inside: {
            // Matches the end tag
            punctuation: /(?=\S).*\S(?= *$)/
            // See interpolation below
          }
        },
        // Matches the content of an unquoted heredoc string (no interpolation)
        {
          pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: {
            // Matches the end tag
            punctuation: /(?=\S).*\S(?= *$)/
          }
        },
        // Matches the start tag of heredoc strings
        {
          pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
          alias: "string",
          inside: {
            punctuation: {
              pattern: /(\().+?(?=\))/,
              lookbehind: !0
            }
          }
        }
      ],
      "multiline-comment": {
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0,
        alias: "comment"
      },
      regex: {
        // Must be prefixed with the keyword "node" or a non-word char
        pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          // Extended regexes must have the x flag. They can contain single-line comments.
          "extended-regex": {
            pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
            inside: {
              comment: /#.*/
            }
          }
        }
      },
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        // Allow for one nested level of double quotes inside interpolation
        pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
        greedy: !0,
        inside: {
          "double-quoted": {
            pattern: /^"[\s\S]*"$/,
            inside: {
              // See interpolation below
            }
          }
        }
      },
      variable: {
        pattern: /\$(?:::)?\w+(?:::\w+)*/,
        inside: {
          punctuation: /::/
        }
      },
      "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
      function: [
        {
          pattern: /(\.)(?!\d)\w+/,
          lookbehind: !0
        },
        /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
      ],
      number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
      boolean: /\b(?:false|true)\b/,
      // Includes words reserved for future use
      keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
      datatype: {
        pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
        alias: "symbol"
      },
      operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
      punctuation: /[\[\]{}().,;]|:+/
    };
    var a = [
      {
        // Allow for one nested level of braces inside interpolation
        pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
        lookbehind: !0,
        inside: {
          "short-variable": {
            // Negative look-ahead prevent wrong highlighting of functions
            pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
            lookbehind: !0,
            alias: "variable",
            inside: {
              punctuation: /::/
            }
          },
          delimiter: {
            pattern: /^\$/,
            alias: "variable"
          },
          rest: t.languages.puppet
        }
      },
      {
        pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
        lookbehind: !0,
        alias: "variable",
        inside: {
          punctuation: /::/
        }
      }
    ];
    t.languages.puppet.heredoc[0].inside.interpolation = a, t.languages.puppet.string.inside["double-quoted"].inside.interpolation = a;
  })(e);
}
Ab.displayName = "pure";
Ab.aliases = [];
function Ab(e) {
  (function(t) {
    t.languages.pure = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0
        },
        /#!.+/
      ],
      "inline-lang": {
        pattern: /%<[\s\S]+?%>/,
        greedy: !0,
        inside: {
          lang: {
            pattern: /(^%< *)-\*-.+?-\*-/,
            lookbehind: !0,
            alias: "comment"
          },
          delimiter: {
            pattern: /^%<.*|%>$/,
            alias: "punctuation"
          }
        }
      },
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: !0
      },
      number: {
        // The look-behind prevents wrong highlighting of the .. operator
        pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
        lookbehind: !0
      },
      keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
      function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
      special: {
        pattern: /\b__[a-z]+__\b/i,
        alias: "builtin"
      },
      // Any combination of operator chars can be an operator
      // eslint-disable-next-line no-misleading-character-class
      operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
      // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
      punctuation: /[(){}\[\];,|]/
    };
    var a = [
      "c",
      {
        lang: "c++",
        alias: "cpp"
      },
      "fortran"
    ], i = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
    a.forEach(function(o) {
      var l = o;
      if (typeof o != "string" && (l = o.alias, o = o.lang), t.languages[l]) {
        var c = {};
        c["inline-lang-" + l] = {
          pattern: RegExp(
            i.replace(
              "<lang>",
              o.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")
            ),
            "i"
          ),
          inside: t.util.clone(t.languages.pure["inline-lang"].inside)
        }, c["inline-lang-" + l].inside.rest = t.util.clone(
          t.languages[l]
        ), t.languages.insertBefore("pure", "inline-lang", c);
      }
    }), t.languages.c && (t.languages.pure["inline-lang"].inside.rest = t.util.clone(
      t.languages.c
    ));
  })(e);
}
Nb.displayName = "purebasic";
Nb.aliases = ["pbfasm"];
function Nb(e) {
  e.register(ze), e.languages.purebasic = e.languages.extend("clike", {
    comment: /;.*/,
    keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
    function: /\b\w+(?:\.\w+)?\s*(?=\()/,
    number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
    operator: /(?:@\*?|\?|\*)\w+\$?|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
  }), e.languages.insertBefore("purebasic", "keyword", {
    tag: /#\w+\$?/,
    asm: {
      pattern: /(^[\t ]*)!.*/m,
      lookbehind: !0,
      alias: "tag",
      inside: {
        comment: /;.*/,
        string: {
          pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: !0
        },
        // Anonymous label references, i.e.: jmp @b
        "label-reference-anonymous": {
          pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
          lookbehind: !0,
          alias: "fasm-label"
        },
        // Named label reference, i.e.: jne label1
        "label-reference-addressed": {
          pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
          lookbehind: !0,
          alias: "fasm-label"
        },
        keyword: [
          /\b(?:extern|global)\b[^;\r\n]*/i,
          /\b(?:CPU|DEFAULT|FLOAT)\b.*/
        ],
        function: {
          pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
          lookbehind: !0
        },
        "function-inline": {
          pattern: /(:\s*)[\da-z]+(?=\s)/i,
          lookbehind: !0,
          alias: "function"
        },
        label: {
          pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
          lookbehind: !0,
          alias: "fasm-label"
        },
        register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
        number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
        operator: /[\[\]*+\-/%<>=&|$!,.:]/
      }
    }
  }), delete e.languages.purebasic["class-name"], delete e.languages.purebasic.boolean, e.languages.pbfasm = e.languages.purebasic;
}
Rb.displayName = "purescript";
Rb.aliases = ["purs"];
function Rb(e) {
  e.register(po), e.languages.purescript = e.languages.extend("haskell", {
    keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|/,
    "import-statement": {
      // The imported or hidden names are not included in this import
      // statement. This is because we want to highlight those exactly like
      // we do for the names in the program.
      pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
      lookbehind: !0,
      inside: {
        keyword: /\b(?:as|hiding|import)\b/,
        punctuation: /\./
      }
    },
    // These are builtin functions only. Constructors are highlighted later as a constant.
    builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
    operator: [
      // Infix operators
      e.languages.haskell.operator[0],
      // ASCII operators
      e.languages.haskell.operator[2],
      // All UTF16 Unicode operator symbols
      // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
      // See https://github.com/PrismJS/prism/issues/3006 for more details.
      /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
    ]
  }), e.languages.purs = e.languages.purescript;
}
Cu.displayName = "python";
Cu.aliases = ["py"];
function Cu(e) {
  e.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0,
      greedy: !0
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, e.languages.python["string-interpolation"].inside.interpolation.inside.rest = e.languages.python, e.languages.py = e.languages.python;
}
vb.displayName = "qsharp";
vb.aliases = ["qs"];
function vb(e) {
  e.register(ze), (function(t) {
    function a(S, _) {
      return S.replace(/<<(\d+)>>/g, function(k, R) {
        return "(?:" + _[+R] + ")";
      });
    }
    function i(S, _, k) {
      return RegExp(a(S, _), "");
    }
    function o(S, _) {
      for (var k = 0; k < _; k++)
        S = S.replace(/<<self>>/g, function() {
          return "(?:" + S + ")";
        });
      return S.replace(/<<self>>/g, "[^\\s\\S]");
    }
    var l = {
      // keywords which represent a return or variable type
      type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
      // all other keywords
      other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
    };
    function c(S) {
      return "\\b(?:" + S.trim().replace(/ /g, "|") + ")\\b";
    }
    var d = RegExp(
      c(l.type + " " + l.other)
    ), m = /\b[A-Za-z_]\w*\b/.source, f = a(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [m]), b = {
      keyword: d,
      punctuation: /[<>()?,.:[\]]/
    }, E = /"(?:\\.|[^\\"])*"/.source;
    t.languages.qsharp = t.languages.extend("clike", {
      comment: /\/\/.*/,
      string: [
        {
          pattern: i(/(^|[^$\\])<<0>>/.source, [E]),
          lookbehind: !0,
          greedy: !0
        }
      ],
      "class-name": [
        {
          // open Microsoft.Quantum.Canon;
          // open Microsoft.Quantum.Canon as CN;
          pattern: i(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
            f
          ]),
          lookbehind: !0,
          inside: b
        },
        {
          // namespace Quantum.App1;
          pattern: i(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [f]),
          lookbehind: !0,
          inside: b
        }
      ],
      keyword: d,
      number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
      operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
      punctuation: /::|[{}[\];(),.:]/
    }), t.languages.insertBefore("qsharp", "number", {
      range: {
        pattern: /\.\./,
        alias: "operator"
      }
    });
    var T = o(
      a(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [E]),
      2
    );
    t.languages.insertBefore("qsharp", "string", {
      "interpolation-string": {
        pattern: i(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [T]),
        greedy: !0,
        inside: {
          interpolation: {
            pattern: i(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
              T
            ]),
            lookbehind: !0,
            inside: {
              punctuation: /^\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                alias: "language-qsharp",
                inside: t.languages.qsharp
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
  })(e), e.languages.qs = e.languages.qsharp;
}
Cb.displayName = "q";
Cb.aliases = [];
function Cb(e) {
  e.languages.q = {
    string: /"(?:\\.|[^"\\\r\n])*"/,
    comment: [
      // From http://code.kx.com/wiki/Reference/Slash:
      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
      {
        pattern: /([\t )\]}])\/.*/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
      {
        pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
        lookbehind: !0,
        greedy: !0
      },
      // From http://code.kx.com/wiki/Reference/Slash:
      // A \ on a line by itself with no preceding matching / will comment to end of file.
      {
        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
        greedy: !0
      },
      {
        pattern: /^#!.+/m,
        greedy: !0
      }
    ],
    symbol: /`(?::\S+|[\w.]*)/,
    datetime: {
      pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
      alias: "number"
    },
    // The negative look-ahead prevents bad highlighting
    // of verbs 0: and 1:
    number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
    keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
    adverb: {
      pattern: /['\/\\]:?|\beach\b/,
      alias: "function"
    },
    verb: {
      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
      alias: "operator"
    },
    punctuation: /[(){}\[\];.]/
  };
}
wb.displayName = "qml";
wb.aliases = [];
function wb(e) {
  e.register(Bt), (function(t) {
    for (var a = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source, i = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source, o = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
      return a;
    }).replace(/<comment>/g, function() {
      return i;
    }), l = 0; l < 2; l++)
      o = o.replace(/<expr>/g, function() {
        return o;
      });
    o = o.replace(/<expr>/g, "[^\\s\\S]"), t.languages.qml = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      "javascript-function": {
        pattern: RegExp(
          /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
            /<js>/g,
            function() {
              return o;
            }
          ),
          "m"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "language-javascript",
        inside: t.languages.javascript
      },
      "class-name": {
        pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
        lookbehind: !0
      },
      property: [
        {
          pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
          lookbehind: !0
        },
        {
          pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
          lookbehind: !0,
          inside: {
            keyword: /^property/,
            property: /\w+(?:\.\w+)*/
          }
        }
      ],
      "javascript-expression": {
        pattern: RegExp(
          /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
            /<js>/g,
            function() {
              return o;
            }
          ),
          "m"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "language-javascript",
        inside: t.languages.javascript
      },
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      keyword: /\b(?:as|import|on)\b/,
      punctuation: /[{}[\]:;,]/
    };
  })(e);
}
kb.displayName = "qore";
kb.aliases = [];
function kb(e) {
  e.register(ze), e.languages.qore = e.languages.extend("clike", {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
      lookbehind: !0
    },
    // Overridden to allow unescaped multi-line strings
    string: {
      pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
      greedy: !0
    },
    keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
    boolean: /\b(?:false|true)\b/i,
    function: /\$?\b(?!\d)\w+(?=\()/,
    number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
    operator: {
      pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
      lookbehind: !0
    },
    variable: /\$(?!\d)\w+\b/
  });
}
Ib.displayName = "r";
Ib.aliases = [];
function Ib(e) {
  e.languages.r = {
    comment: /#.*/,
    string: {
      pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "percent-operator": {
      // Includes user-defined operators
      // and %%, %*%, %/%, %in%, %o%, %x%
      pattern: /%[^%\s]*%/,
      alias: "operator"
    },
    boolean: /\b(?:FALSE|TRUE)\b/,
    ellipsis: /\.\.(?:\.|\d+)/,
    number: [
      /\b(?:Inf|NaN)\b/,
      /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
    ],
    keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
    operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
    punctuation: /[(){}\[\],;]/
  };
}
Ob.displayName = "racket";
Ob.aliases = ["rkt"];
function Ob(e) {
  e.register(go), e.languages.racket = e.languages.extend("scheme", {
    "lambda-parameter": {
      // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
      // this will just prevent false positives of the `function` pattern
      pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
      lookbehind: !0
    }
  }), e.languages.insertBefore("racket", "string", {
    lang: {
      pattern: /^#lang.+/m,
      greedy: !0,
      alias: "keyword"
    }
  }), e.languages.rkt = e.languages.racket;
}
xb.displayName = "cshtml";
xb.aliases = ["razor"];
function xb(e) {
  e.register(Ci), e.register(xt), (function(t) {
    var a = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source, i = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
    function o(L, x) {
      for (var Y = 0; Y < x; Y++)
        L = L.replace(/<self>/g, function() {
          return "(?:" + L + ")";
        });
      return L.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + i + ")").replace(/<comment>/g, "(?:" + a + ")");
    }
    var l = o(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2), c = o(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 1), d = o(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2), m = o(/<(?:[^<>'"@/]|<comment>|<self>)*>/.source, 1), f = /@/.source + /(?:await\b\s*)?/.source + "(?:" + /(?!await\b)\w+\b/.source + "|" + l + ")(?:" + /[?!]?\.\w+\b/.source + "|(?:" + m + ")?" + l + "|" + c + ")*" + /(?![?!\.(\[]|<(?!\/))/.source, b = /@(?![\w()])/.source + "|" + f, E = "(?:" + /"[^"@]*"|'[^'@]*'|[^\s'"@>=]+(?=[\s>])/.source + `|["'][^"'@]*(?:(?:` + b + `)[^"'@]*)+["'])`, T = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*<tagAttrValue>|(?=[\s/>])))+)?/.source.replace(
      /<tagAttrValue>/,
      E
    ), S = /(?!\d)[^\s>\/=$<%]+/.source + T + /\s*\/?>/.source, _ = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + T + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
    // eslint-disable-next-line regexp/strict
    /<\/?(?!\1\b)/.source + S + "|" + // nested start tag
    o(
      // eslint-disable-next-line regexp/strict
      /<\1/.source + T + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
      // eslint-disable-next-line regexp/strict
      /<\/?(?!\1\b)/.source + S + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
      /<\/\1\s*>/.source,
      2
    )) + ")*" + // eslint-disable-next-line regexp/strict
    /<\/\1\s*>/.source + "|" + /</.source + S + ")";
    t.languages.cshtml = t.languages.extend("markup", {});
    var k = t.languages.insertBefore(
      "csharp",
      "string",
      {
        html: {
          pattern: RegExp(_),
          greedy: !0,
          inside: t.languages.cshtml
        }
      },
      {
        csharp: t.languages.extend("csharp", {})
      }
    ), R = {
      pattern: /\S[\s\S]*/,
      alias: "language-csharp",
      inside: k
    }, C = {
      pattern: RegExp(/(^|[^@])/.source + f),
      lookbehind: !0,
      greedy: !0,
      alias: "variable",
      inside: {
        keyword: /^@/,
        csharp: R
      }
    };
    t.languages.cshtml.tag.pattern = RegExp(/<\/?/.source + S), t.languages.cshtml.tag.inside["attr-value"].pattern = RegExp(
      /=\s*/.source + E
    ), t.languages.insertBefore(
      "inside",
      "punctuation",
      {
        value: C
      },
      t.languages.cshtml.tag.inside["attr-value"]
    ), t.languages.insertBefore("cshtml", "prolog", {
      "razor-comment": {
        pattern: /@\*[\s\S]*?\*@/,
        greedy: !0,
        alias: "comment"
      },
      block: {
        pattern: RegExp(
          /(^|[^@])@/.source + "(?:" + [
            // @{ ... }
            d,
            // @code{ ... }
            /(?:code|functions)\s*/.source + d,
            // @for (...) { ... }
            /(?:for|foreach|lock|switch|using|while)\s*/.source + l + /\s*/.source + d,
            // @do { ... } while (...);
            /do\s*/.source + d + /\s*while\s*/.source + l + /(?:\s*;)?/.source,
            // @try { ... } catch (...) { ... } finally { ... }
            /try\s*/.source + d + /\s*catch\s*/.source + l + /\s*/.source + d + /\s*finally\s*/.source + d,
            // @if (...) {...} else if (...) {...} else {...}
            /if\s*/.source + l + /\s*/.source + d + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + l + ")?" + /\s*/.source + d + ")*",
            // @helper Ident(params) { ... }
            /helper\s+\w+\s*/.source + l + /\s*/.source + d
          ].join("|") + ")"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^@\w*/,
          csharp: R
        }
      },
      directive: {
        pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^@\w+/,
          csharp: R
        }
      },
      value: C,
      "delegate-operator": {
        pattern: /(^|[^@])@(?=<)/,
        lookbehind: !0,
        alias: "operator"
      }
    }), t.languages.razor = t.languages.cshtml;
  })(e);
}
wu.displayName = "jsx";
wu.aliases = [];
function wu(e) {
  e.register(Bt), e.register(xt), (function(t) {
    var a = t.util.clone(t.languages.javascript), i = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, o = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, l = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
    function c(f, b) {
      return f = f.replace(/<S>/g, function() {
        return i;
      }).replace(/<BRACES>/g, function() {
        return o;
      }).replace(/<SPREAD>/g, function() {
        return l;
      }), RegExp(f, b);
    }
    l = c(l).source, t.languages.jsx = t.languages.extend("markup", a), t.languages.jsx.tag.pattern = c(
      /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
    ), t.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, t.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, t.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, t.languages.jsx.tag.inside.comment = a.comment, t.languages.insertBefore(
      "inside",
      "attr-name",
      {
        spread: {
          pattern: c(/<SPREAD>/.source),
          inside: t.languages.jsx
        }
      },
      t.languages.jsx.tag
    ), t.languages.insertBefore(
      "inside",
      "special-attr",
      {
        script: {
          // Allow for two levels of nesting
          pattern: c(/=<BRACES>/.source),
          alias: "language-javascript",
          inside: {
            "script-punctuation": {
              pattern: /^=(?=\{)/,
              alias: "punctuation"
            },
            rest: t.languages.jsx
          }
        }
      },
      t.languages.jsx.tag
    );
    var d = function(f) {
      return f ? typeof f == "string" ? f : typeof f.content == "string" ? f.content : f.content.map(d).join("") : "";
    }, m = function(f) {
      for (var b = [], E = 0; E < f.length; E++) {
        var T = f[E], S = !1;
        if (typeof T != "string" && (T.type === "tag" && T.content[0] && T.content[0].type === "tag" ? T.content[0].content[0].content === "</" ? b.length > 0 && b[b.length - 1].tagName === d(T.content[0].content[1]) && b.pop() : T.content[T.content.length - 1].content === "/>" || b.push({
          tagName: d(T.content[0].content[1]),
          openedBraces: 0
        }) : b.length > 0 && T.type === "punctuation" && T.content === "{" ? b[b.length - 1].openedBraces++ : b.length > 0 && b[b.length - 1].openedBraces > 0 && T.type === "punctuation" && T.content === "}" ? b[b.length - 1].openedBraces-- : S = !0), (S || typeof T == "string") && b.length > 0 && b[b.length - 1].openedBraces === 0) {
          var _ = d(T);
          E < f.length - 1 && (typeof f[E + 1] == "string" || f[E + 1].type === "plain-text") && (_ += d(f[E + 1]), f.splice(E + 1, 1)), E > 0 && (typeof f[E - 1] == "string" || f[E - 1].type === "plain-text") && (_ = d(f[E - 1]) + _, f.splice(E - 1, 1), E--), f[E] = new t.Token(
            "plain-text",
            _,
            null,
            _
          );
        }
        T.content && typeof T.content != "string" && m(T.content);
      }
    };
    t.hooks.add("after-tokenize", function(f) {
      f.language !== "jsx" && f.language !== "tsx" || m(f.tokens);
    });
  })(e);
}
Lb.displayName = "tsx";
Lb.aliases = [];
function Lb(e) {
  e.register(wu), e.register(mo), (function(t) {
    var a = t.util.clone(t.languages.typescript);
    t.languages.tsx = t.languages.extend("jsx", a), delete t.languages.tsx.parameter, delete t.languages.tsx["literal-property"];
    var i = t.languages.tsx.tag;
    i.pattern = RegExp(
      /(^|[^\w$]|(?=<\/))/.source + "(?:" + i.pattern.source + ")",
      i.pattern.flags
    ), i.lookbehind = !0;
  })(e);
}
Db.displayName = "reason";
Db.aliases = [];
function Db(e) {
  e.register(ze), e.languages.reason = e.languages.extend("clike", {
    string: {
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
      greedy: !0
    },
    // 'class-name' must be matched *after* 'constructor' defined below
    "class-name": /\b[A-Z]\w*/,
    keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
    operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
  }), e.languages.insertBefore("reason", "class-name", {
    char: {
      pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
      greedy: !0
    },
    // Negative look-ahead prevents from matching things like String.capitalize
    constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
    label: {
      pattern: /\b[a-z]\w*(?=::)/,
      alias: "symbol"
    }
  }), delete e.languages.reason.function;
}
Mb.displayName = "rego";
Mb.aliases = [];
function Mb(e) {
  e.languages.rego = {
    comment: /#.*/,
    property: {
      pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
      lookbehind: !0,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
    boolean: /\b(?:false|true)\b/,
    function: {
      pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
      inside: {
        namespace: /\b\w+\b(?=\s*\.)/,
        punctuation: /\./
      }
    },
    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
    punctuation: /[,;.\[\]{}()]/
  };
}
Ub.displayName = "renpy";
Ub.aliases = ["rpy"];
function Ub(e) {
  e.languages.renpy = {
    comment: {
      pattern: /(^|[^\\])#.+/,
      lookbehind: !0
    },
    string: {
      pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
      greedy: !0
    },
    function: /\b[a-z_]\w*(?=\()/i,
    property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
    tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
    keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
    boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
    number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
    punctuation: /[{}[\];(),.:]/
  }, e.languages.rpy = e.languages.renpy;
}
Bb.displayName = "rescript";
Bb.aliases = ["res"];
function Bb(e) {
  e.languages.rescript = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    char: {
      pattern: /'(?:[^\r\n\\]|\\(?:.|\w+))'/,
      greedy: !0
    },
    string: {
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
      greedy: !0
    },
    "class-name": /\b[A-Z]\w*|@[a-z.]*|#[A-Za-z]\w*|#\d/,
    function: {
      pattern: /[a-zA-Z]\w*(?=\()|(\.)[a-z]\w*/,
      lookbehind: !0
    },
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    boolean: /\b(?:false|true)\b/,
    "attr-value": /[A-Za-z]\w*(?==)/,
    constant: {
      pattern: /(\btype\s+)[a-z]\w*/,
      lookbehind: !0
    },
    tag: {
      pattern: /(<)[a-z]\w*|(?:<\/)[a-z]\w*/,
      lookbehind: !0,
      inside: {
        operator: /<|>|\//
      }
    },
    keyword: /\b(?:and|as|assert|begin|bool|class|constraint|do|done|downto|else|end|exception|external|float|for|fun|function|if|in|include|inherit|initializer|int|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|string|switch|then|to|try|type|when|while|with)\b/,
    operator: /\.{3}|:[:=]?|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/,
    punctuation: /[(){}[\],;.]/
  }, e.languages.insertBefore("rescript", "string", {
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "tag"
            },
            rest: e.languages.rescript
          }
        },
        string: /[\s\S]+/
      }
    }
  }), e.languages.res = e.languages.rescript;
}
Fb.displayName = "rest";
Fb.aliases = [];
function Fb(e) {
  e.languages.rest = {
    table: [
      {
        pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
        lookbehind: !0,
        inside: {
          punctuation: /\||(?:\+[=-]+)+\+/
        }
      },
      {
        pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
        lookbehind: !0,
        inside: {
          punctuation: /[=-]+/
        }
      }
    ],
    // Directive-like patterns
    "substitution-def": {
      pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
      lookbehind: !0,
      inside: {
        substitution: {
          pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
          alias: "attr-value",
          inside: {
            punctuation: /^\||\|$/
          }
        },
        directive: {
          pattern: /( )(?! )[^:]+::/,
          lookbehind: !0,
          alias: "function",
          inside: {
            punctuation: /::$/
          }
        }
      }
    },
    "link-target": [
      {
        pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
        lookbehind: !0,
        alias: "string",
        inside: {
          punctuation: /^\[|\]$/
        }
      },
      {
        pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
        lookbehind: !0,
        alias: "string",
        inside: {
          punctuation: /^_|:$/
        }
      }
    ],
    directive: {
      pattern: /(^[\t ]*\.\. )[^:]+::/m,
      lookbehind: !0,
      alias: "function",
      inside: {
        punctuation: /::$/
      }
    },
    comment: {
      // The two alternatives try to prevent highlighting of blank comments
      pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
      lookbehind: !0
    },
    title: [
      // Overlined and underlined
      {
        pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
        inside: {
          punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
          important: /.+/
        }
      },
      // Underlined only
      {
        pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
        lookbehind: !0,
        inside: {
          punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
          important: /.+/
        }
      }
    ],
    hr: {
      pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
      lookbehind: !0,
      alias: "punctuation"
    },
    field: {
      pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
      lookbehind: !0,
      alias: "attr-name"
    },
    "command-line-option": {
      pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
      lookbehind: !0,
      alias: "symbol"
    },
    "literal-block": {
      pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
      inside: {
        "literal-block-punctuation": {
          pattern: /^::/,
          alias: "punctuation"
        }
      }
    },
    "quoted-literal-block": {
      pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
      inside: {
        "literal-block-punctuation": {
          pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
          alias: "punctuation"
        }
      }
    },
    "list-bullet": {
      pattern: /(^[\t ]*)(?:[*+\-]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
      lookbehind: !0,
      alias: "punctuation"
    },
    "doctest-block": {
      pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
      lookbehind: !0,
      inside: {
        punctuation: /^>>>/
      }
    },
    inline: [
      {
        pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
        lookbehind: !0,
        inside: {
          bold: {
            pattern: /(^\*\*).+(?=\*\*$)/,
            lookbehind: !0
          },
          italic: {
            pattern: /(^\*).+(?=\*$)/,
            lookbehind: !0
          },
          "inline-literal": {
            pattern: /(^``).+(?=``$)/,
            lookbehind: !0,
            alias: "symbol"
          },
          role: {
            pattern: /^:[^:]+:|:[^:]+:$/,
            alias: "function",
            inside: {
              punctuation: /^:|:$/
            }
          },
          "interpreted-text": {
            pattern: /(^`).+(?=`$)/,
            lookbehind: !0,
            alias: "attr-value"
          },
          substitution: {
            pattern: /(^\|).+(?=\|$)/,
            lookbehind: !0,
            alias: "attr-value"
          },
          punctuation: /\*\*?|``?|\|/
        }
      }
    ],
    link: [
      {
        pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
        alias: "string",
        inside: {
          punctuation: /^\[|\]_$/
        }
      },
      {
        pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
        alias: "string",
        inside: {
          punctuation: /^_?`|`$|`?_?_$/
        }
      }
    ],
    // Line block start,
    // quote attribution,
    // explicit markup start,
    // and anonymous hyperlink target shortcut (__)
    punctuation: {
      pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?||\.\.|__)(?= )|\.\.$)/m,
      lookbehind: !0
    }
  };
}
Pb.displayName = "rip";
Pb.aliases = [];
function Pb(e) {
  e.languages.rip = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    char: {
      pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
      greedy: !0
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    regex: {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
    builtin: /@|\bSystem\b/,
    boolean: /\b(?:false|true)\b/,
    date: /\b\d{4}-\d{2}-\d{2}\b/,
    time: /\b\d{2}:\d{2}:\d{2}\b/,
    datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
    symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
    number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
    punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
    reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
  };
}
Hb.displayName = "roboconf";
Hb.aliases = [];
function Hb(e) {
  e.languages.roboconf = {
    comment: /#.*/,
    keyword: {
      pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
      lookbehind: !0
    },
    component: {
      pattern: /[\w-]+(?=[ \t]*\{)/,
      alias: "variable"
    },
    property: /[\w.-]+(?=[ \t]*:)/,
    value: {
      pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
      lookbehind: !0,
      alias: "attr-value"
    },
    optional: {
      pattern: /\(optional\)/,
      alias: "builtin"
    },
    wildcard: {
      pattern: /(\.)\*/,
      lookbehind: !0,
      alias: "operator"
    },
    punctuation: /[{},.;:=]/
  };
}
zb.displayName = "robotframework";
zb.aliases = ["robot"];
function zb(e) {
  (function(t) {
    var a = {
      pattern: /(^[ \t]*| {2}|\t)#.*/m,
      lookbehind: !0,
      greedy: !0
    }, i = {
      pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
      lookbehind: !0,
      inside: {
        punctuation: /^[$@&%]\{|\}$/
      }
    };
    function o(m, f) {
      var b = {};
      b["section-header"] = {
        pattern: /^ ?\*{3}.+?\*{3}/,
        alias: "keyword"
      };
      for (var E in f)
        b[E] = f[E];
      return b.tag = {
        pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
        lookbehind: !0,
        inside: {
          punctuation: /\[|\]/
        }
      }, b.variable = i, b.comment = a, {
        pattern: RegExp(
          /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
            /<name>/g,
            function() {
              return m;
            }
          ),
          "im"
        ),
        alias: "section",
        inside: b
      };
    }
    var l = {
      pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
      lookbehind: !0,
      alias: "string"
    }, c = {
      pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
      lookbehind: !0,
      alias: "function",
      inside: {
        variable: i
      }
    }, d = {
      pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
      lookbehind: !0,
      inside: {
        variable: i
      }
    };
    t.languages.robotframework = {
      settings: o("Settings", {
        documentation: {
          pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
          lookbehind: !0,
          alias: "string"
        },
        property: {
          pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
          lookbehind: !0
        }
      }),
      variables: o("Variables"),
      "test-cases": o("Test Cases", {
        "test-name": c,
        documentation: l,
        property: d
      }),
      keywords: o("Keywords", {
        "keyword-name": c,
        documentation: l,
        property: d
      }),
      tasks: o("Tasks", {
        "task-name": c,
        documentation: l,
        property: d
      }),
      comment: a
    }, t.languages.robot = t.languages.robotframework;
  })(e);
}
Gb.displayName = "rust";
Gb.aliases = [];
function Gb(e) {
  (function(t) {
    for (var a = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, i = 0; i < 2; i++)
      a = a.replace(/<self>/g, function() {
        return a;
      });
    a = a.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), t.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + a),
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: !0
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: !0
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: !0,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: !0,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: !0,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, t.languages.rust["closure-params"].inside.rest = t.languages.rust, t.languages.rust.attribute.inside.string = t.languages.rust.string;
  })(e);
}
jb.displayName = "sas";
jb.aliases = [];
function jb(e) {
  (function(t) {
    var a = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source, i = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i, o = {
      pattern: RegExp(a + "[bx]"),
      alias: "number"
    }, l = {
      pattern: /&[a-z_]\w*/i
    }, c = {
      pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
      lookbehind: !0,
      alias: "keyword"
    }, d = {
      pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
      alias: "keyword",
      lookbehind: !0
    }, m = [
      /\/\*[\s\S]*?\*\//,
      {
        pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
        lookbehind: !0
      }
    ], f = {
      pattern: RegExp(a),
      greedy: !0
    }, b = /[$%@.(){}\[\];,\\]/, E = {
      pattern: /%?\b\w+(?=\()/,
      alias: "keyword"
    }, T = {
      function: E,
      "arg-value": {
        pattern: /(=\s*)[A-Z\.]+/i,
        lookbehind: !0
      },
      operator: /=/,
      "macro-variable": l,
      arg: {
        pattern: /[A-Z]+/i,
        alias: "keyword"
      },
      number: i,
      "numeric-constant": o,
      punctuation: b,
      string: f
    }, S = {
      pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
      inside: {
        keyword: /^(?:format|put)(?==)/i,
        equals: /=/,
        format: {
          pattern: /(?:\w|\$\d)+\.\d?/,
          alias: "number"
        }
      }
    }, _ = {
      pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
      inside: {
        keyword: /^(?:format|put)/i,
        format: {
          pattern: /[\w$]+\.\d?/,
          alias: "number"
        }
      }
    }, k = {
      pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
      lookbehind: !0,
      alias: "keyword"
    }, R = {
      pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
      lookbehind: !0,
      alias: "keyword"
    }, C = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source, L = {
      pattern: RegExp(
        /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
          /<act>/g,
          function() {
            return C;
          }
        ),
        "i"
      ),
      lookbehind: !0,
      inside: {
        keyword: RegExp(
          /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
            return C;
          }),
          "i"
        ),
        action: {
          pattern: /(?:action)/i,
          alias: "keyword"
        },
        comment: m,
        function: E,
        "arg-value": T["arg-value"],
        operator: T.operator,
        argument: T.arg,
        number: i,
        "numeric-constant": o,
        punctuation: b,
        string: f
      }
    }, x = {
      pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
      lookbehind: !0
    };
    t.languages.sas = {
      datalines: {
        pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
        lookbehind: !0,
        alias: "string",
        inside: {
          keyword: {
            pattern: /^(?:cards|(?:data)?lines)/i
          },
          punctuation: /;/
        }
      },
      "proc-sql": {
        pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
        lookbehind: !0,
        inside: {
          sql: {
            pattern: RegExp(
              /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
                /<str>/g,
                function() {
                  return a;
                }
              ),
              "im"
            ),
            alias: "language-sql",
            inside: t.languages.sql
          },
          "global-statements": k,
          "sql-statements": {
            pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
            lookbehind: !0,
            alias: "keyword"
          },
          number: i,
          "numeric-constant": o,
          punctuation: b,
          string: f
        }
      },
      "proc-groovy": {
        pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
        lookbehind: !0,
        inside: {
          comment: m,
          groovy: {
            pattern: RegExp(
              /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                /<str>/g,
                function() {
                  return a;
                }
              ),
              "im"
            ),
            lookbehind: !0,
            alias: "language-groovy",
            inside: t.languages.groovy
          },
          keyword: x,
          "submit-statement": R,
          "global-statements": k,
          number: i,
          "numeric-constant": o,
          punctuation: b,
          string: f
        }
      },
      "proc-lua": {
        pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
        lookbehind: !0,
        inside: {
          comment: m,
          lua: {
            pattern: RegExp(
              /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                /<str>/g,
                function() {
                  return a;
                }
              ),
              "im"
            ),
            lookbehind: !0,
            alias: "language-lua",
            inside: t.languages.lua
          },
          keyword: x,
          "submit-statement": R,
          "global-statements": k,
          number: i,
          "numeric-constant": o,
          punctuation: b,
          string: f
        }
      },
      "proc-cas": {
        pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
        lookbehind: !0,
        inside: {
          comment: m,
          "statement-var": {
            pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
            lookbehind: !0,
            inside: {
              statement: {
                pattern: /^saveresult\s+\S+/i,
                inside: {
                  keyword: /^(?:saveresult)/i
                }
              },
              rest: T
            }
          },
          "cas-actions": L,
          statement: {
            pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
            lookbehind: !0,
            inside: T
          },
          step: d,
          keyword: x,
          function: E,
          format: S,
          altformat: _,
          "global-statements": k,
          number: i,
          "numeric-constant": o,
          punctuation: b,
          string: f
        }
      },
      "proc-args": {
        pattern: RegExp(
          /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
            /<str>/g,
            function() {
              return a;
            }
          ),
          "im"
        ),
        lookbehind: !0,
        inside: T
      },
      /*Special keywords within macros*/
      "macro-keyword": c,
      "macro-variable": l,
      "macro-string-functions": {
        pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
        lookbehind: !0,
        inside: {
          function: {
            pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
            alias: "keyword"
          },
          "macro-keyword": c,
          "macro-variable": l,
          "escaped-char": {
            pattern: /%['"()<>=^~;,#]/
          },
          punctuation: b
        }
      },
      "macro-declaration": {
        pattern: /^%macro[^;]+(?=;)/im,
        inside: {
          keyword: /%macro/i
        }
      },
      "macro-end": {
        pattern: /^%mend[^;]+(?=;)/im,
        inside: {
          keyword: /%mend/i
        }
      },
      /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
      macro: {
        pattern: /%_\w+(?=\()/,
        alias: "keyword"
      },
      input: {
        pattern: /\binput\s[-\w\s/*.$&]+;/i,
        inside: {
          input: {
            alias: "keyword",
            pattern: /^input/i
          },
          comment: m,
          number: i,
          "numeric-constant": o
        }
      },
      "options-args": {
        pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
        lookbehind: !0,
        inside: T
      },
      "cas-actions": L,
      comment: m,
      function: E,
      format: S,
      altformat: _,
      "numeric-constant": o,
      datetime: {
        // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
        pattern: RegExp(a + "(?:dt?|t)"),
        alias: "number"
      },
      string: f,
      step: d,
      keyword: x,
      // In SAS Studio syntax highlighting, these operators are styled like keywords
      "operator-keyword": {
        pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
        alias: "operator"
      },
      // Decimal (1.2e23), hexadecimal (0c1x)
      number: i,
      operator: /\*\*?|\|\|?|!!?|?|<[>=]?|>[<=]?|[-+\/=&]|[~^]=?/,
      punctuation: b
    };
  })(e);
}
$b.displayName = "sass";
$b.aliases = [];
function $b(e) {
  e.register(Sr), (function(t) {
    t.languages.sass = t.languages.extend("css", {
      // Sass comments don't need to be closed, only indented
      comment: {
        pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
        lookbehind: !0,
        greedy: !0
      }
    }), t.languages.insertBefore("sass", "atrule", {
      // We want to consume the whole line
      "atrule-line": {
        // Includes support for = and + shortcuts
        pattern: /^(?:[ \t]*)[@+=].+/m,
        greedy: !0,
        inside: {
          atrule: /(?:@[\w-]+|[+=])/
        }
      }
    }), delete t.languages.sass.atrule;
    var a = /\$[-\w]+|#\{\$[-\w]+\}/, i = [
      /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
      {
        pattern: /(\s)-(?=\s)/,
        lookbehind: !0
      }
    ];
    t.languages.insertBefore("sass", "property", {
      // We want to consume the whole line
      "variable-line": {
        pattern: /^[ \t]*\$.+/m,
        greedy: !0,
        inside: {
          punctuation: /:/,
          variable: a,
          operator: i
        }
      },
      // We want to consume the whole line
      "property-line": {
        pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
        greedy: !0,
        inside: {
          property: [
            /[^:\s]+(?=\s*:)/,
            {
              pattern: /(:)[^:\s]+/,
              lookbehind: !0
            }
          ],
          punctuation: /:/,
          variable: a,
          operator: i,
          important: t.languages.sass.important
        }
      }
    }), delete t.languages.sass.property, delete t.languages.sass.important, t.languages.insertBefore("sass", "punctuation", {
      selector: {
        pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
        lookbehind: !0,
        greedy: !0
      }
    });
  })(e);
}
qb.displayName = "shell-session";
qb.aliases = ["sh-session", "shellsession"];
function qb(e) {
  e.register(_u), (function(t) {
    var a = [
      // normal string
      /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
      /'[^']*'/.source,
      /\$'(?:[^'\\]|\\[\s\S])*'/.source,
      // here doc
      // 2 capturing groups
      /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
    ].join("|");
    t.languages["shell-session"] = {
      command: {
        pattern: RegExp(
          // user info
          /^/.source + "(?:" + // <user> ":" ( <path> )?
          (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // <path>
          // Since the path pattern is quite general, we will require it to start with a special character to
          // prevent false positives.
          /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + // shell symbol
          /[$#%](?=\s)/.source + // bash command
          /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
            /<<str>>/g,
            function() {
              return a;
            }
          ),
          "m"
        ),
        greedy: !0,
        inside: {
          info: {
            // foo@bar:~/files$ exit
            // foo@bar$ exit
            // ~/files$ exit
            pattern: /^[^#$%]+/,
            alias: "punctuation",
            inside: {
              user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
              punctuation: /:/,
              path: /[\s\S]+/
            }
          },
          bash: {
            pattern: /(^[$#%]\s*)\S[\s\S]*/,
            lookbehind: !0,
            alias: "language-bash",
            inside: t.languages.bash
          },
          "shell-symbol": {
            pattern: /^[$#%]/,
            alias: "important"
          }
        }
      },
      output: /.(?:.*(?:[\r\n]|.$))*/
    }, t.languages["sh-session"] = t.languages.shellsession = t.languages["shell-session"];
  })(e);
}
Yb.displayName = "smali";
Yb.aliases = [];
function Yb(e) {
  e.languages.smali = {
    comment: /#.*/,
    string: {
      pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
      greedy: !0
    },
    "class-name": {
      pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
      lookbehind: !0,
      inside: {
        "class-name": {
          pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
          lookbehind: !0
        },
        namespace: {
          pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
          lookbehind: !0,
          inside: {
            punctuation: /\//
          }
        },
        builtin: /^L/
      }
    },
    builtin: [
      {
        // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
        pattern: /([();\[])[BCDFIJSVZ]+/,
        lookbehind: !0
      },
      {
        // e.g. .field mWifiOnUid:I
        pattern: /([\w$>]:)[BCDFIJSVZ]/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /(\.end\s+)[\w-]+/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
        lookbehind: !0
      }
    ],
    function: {
      pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
      lookbehind: !0
    },
    field: {
      pattern: /[\w$]+(?=:)/,
      alias: "variable"
    },
    register: {
      pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
      lookbehind: !0,
      alias: "variable"
    },
    boolean: {
      pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
      lookbehind: !0
    },
    number: {
      pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
      lookbehind: !0
    },
    label: {
      pattern: /(:)\w+/,
      lookbehind: !0,
      alias: "property"
    },
    operator: /->|\.\.|[\[=]/,
    punctuation: /[{}(),;:]/
  };
}
Vb.displayName = "smalltalk";
Vb.aliases = [];
function Vb(e) {
  e.languages.smalltalk = {
    comment: {
      pattern: /"(?:""|[^"])*"/,
      greedy: !0
    },
    char: {
      pattern: /\$./,
      greedy: !0
    },
    string: {
      pattern: /'(?:''|[^'])*'/,
      greedy: !0
    },
    symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
    "block-arguments": {
      pattern: /(\[\s*):[^\[|]*\|/,
      lookbehind: !0,
      inside: {
        variable: /:[\da-z]+/i,
        punctuation: /\|/
      }
    },
    "temporary-variables": {
      pattern: /\|[^|]+\|/,
      inside: {
        variable: /[\da-z]+/i,
        punctuation: /\|/
      }
    },
    keyword: /\b(?:new|nil|self|super)\b/,
    boolean: /\b(?:false|true)\b/,
    number: [
      /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
      /\b\d+(?:\.\d+)?(?:e-?\d+)?/
    ],
    operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
    punctuation: /[.;:?\[\](){}]/
  };
}
Wb.displayName = "smarty";
Wb.aliases = [];
function Wb(e) {
  e.register(Ft), (function(t) {
    t.languages.smarty = {
      comment: {
        pattern: /^\{\*[\s\S]*?\*\}/,
        greedy: !0
      },
      "embedded-php": {
        pattern: /^\{php\}[\s\S]*?\{\/php\}/,
        greedy: !0,
        inside: {
          smarty: {
            pattern: /^\{php\}|\{\/php\}$/,
            inside: null
            // see below
          },
          php: {
            pattern: /[\s\S]+/,
            alias: "language-php",
            inside: t.languages.php
          }
        }
      },
      string: [
        {
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /\{[^{}]*\}|`[^`]*`/,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^[{`]|[`}]$/,
                  alias: "punctuation"
                },
                expression: {
                  pattern: /[\s\S]+/,
                  inside: null
                  // see below
                }
              }
            },
            variable: /\$\w+/
          }
        },
        {
          pattern: /'(?:\\.|[^'\\\r\n])*'/,
          greedy: !0
        }
      ],
      keyword: {
        pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
        lookbehind: !0,
        greedy: !0
      },
      delimiter: {
        pattern: /^\{\/?|\}$/,
        greedy: !0,
        alias: "punctuation"
      },
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      variable: [
        /\$(?!\d)\w+/,
        /#(?!\d)\w+#/,
        {
          pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
          lookbehind: !0
        },
        {
          pattern: /(\[)(?!\d)\w+(?=\])/,
          lookbehind: !0
        }
      ],
      function: {
        pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
        lookbehind: !0
      },
      "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
      boolean: /\b(?:false|no|off|on|true|yes)\b/,
      punctuation: /[\[\](){}.,:`]|->/,
      operator: [
        /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
        /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
        /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
      ]
    }, t.languages.smarty["embedded-php"].inside.smarty.inside = t.languages.smarty, t.languages.smarty.string[0].inside.interpolation.inside.expression.inside = t.languages.smarty;
    var a = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/, i = RegExp(
      // comments
      /\{\*[\s\S]*?\*\}/.source + "|" + // php tags
      /\{php\}[\s\S]*?\{\/php\}/.source + "|" + // smarty blocks
      /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
        /<str>/g,
        function() {
          return a.source;
        }
      ),
      "g"
    );
    t.hooks.add("before-tokenize", function(o) {
      var l = "{literal}", c = "{/literal}", d = !1;
      t.languages["markup-templating"].buildPlaceholders(
        o,
        "smarty",
        i,
        function(m) {
          return m === c && (d = !1), d ? !1 : (m === l && (d = !0), !0);
        }
      );
    }), t.hooks.add("after-tokenize", function(o) {
      t.languages["markup-templating"].tokenizePlaceholders(o, "smarty");
    });
  })(e);
}
Xb.displayName = "sml";
Xb.aliases = ["smlnj"];
function Xb(e) {
  (function(t) {
    var a = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
    t.languages.sml = {
      // allow one level of nesting
      comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
      string: {
        pattern: /#?"(?:[^"\\]|\\.)*"/,
        greedy: !0
      },
      "class-name": [
        {
          // This is only an approximation since the real grammar is context-free
          //
          // Why the main loop so complex?
          // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
          // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
          // followed by a long identifier.
          pattern: RegExp(
            /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
              return /\s*(?:[*,]|->)/.source;
            }).replace(/<TERMINAL>/g, function() {
              return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
            }).replace(/<LONG-ID>/g, function() {
              return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
            }).replace(/<KEYWORD>/g, function() {
              return a.source;
            }),
            "i"
          ),
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        {
          pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
          lookbehind: !0
        }
      ],
      function: {
        pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
        lookbehind: !0
      },
      keyword: a,
      variable: {
        pattern: /(^|[^\w'])'[\w']*/,
        lookbehind: !0
      },
      number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
      word: {
        pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
        alias: "constant"
      },
      boolean: /\b(?:false|true)\b/i,
      operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
      punctuation: /[(){}\[\].:,;]/
    }, t.languages.sml["class-name"][0].inside = t.languages.sml, t.languages.smlnj = t.languages.sml;
  })(e);
}
Kb.displayName = "solidity";
Kb.aliases = ["sol"];
function Kb(e) {
  e.register(ze), e.languages.solidity = e.languages.extend("clike", {
    "class-name": {
      pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
      lookbehind: !0
    },
    keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
    operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
  }), e.languages.insertBefore("solidity", "keyword", {
    builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
  }), e.languages.insertBefore("solidity", "number", {
    version: {
      pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
      lookbehind: !0,
      alias: "number"
    }
  }), e.languages.sol = e.languages.solidity;
}
Zb.displayName = "solution-file";
Zb.aliases = ["sln"];
function Zb(e) {
  (function(t) {
    var a = {
      // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
      pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
      alias: "constant",
      inside: {
        punctuation: /[{}]/
      }
    };
    t.languages["solution-file"] = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: !0,
        inside: {
          guid: a
        }
      },
      object: {
        // Foo
        //   Bar("abs") = 9
        //   EndBar
        //   Prop = TRUE
        // EndFoo
        pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
        lookbehind: !0,
        greedy: !0,
        alias: "keyword"
      },
      property: {
        pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
        lookbehind: !0,
        inside: {
          guid: a
        }
      },
      guid: a,
      number: /\b\d+(?:\.\d+)*\b/,
      boolean: /\b(?:FALSE|TRUE)\b/,
      operator: /=/,
      punctuation: /[(),]/
    }, t.languages.sln = t.languages["solution-file"];
  })(e);
}
Qb.displayName = "soy";
Qb.aliases = [];
function Qb(e) {
  e.register(Ft), (function(t) {
    var a = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, i = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
    t.languages.soy = {
      comment: [
        /\/\*[\s\S]*?\*\//,
        {
          pattern: /(\s)\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      "command-arg": {
        pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
        lookbehind: !0,
        alias: "string",
        inside: {
          punctuation: /\./
        }
      },
      parameter: {
        pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
        lookbehind: !0,
        alias: "variable"
      },
      keyword: [
        {
          pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
          lookbehind: !0
        },
        /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
      ],
      delimiter: {
        pattern: /^\{+\/?|\/?\}+$/,
        alias: "punctuation"
      },
      property: /\w+(?==)/,
      variable: {
        pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
        inside: {
          string: {
            pattern: a,
            greedy: !0
          },
          number: i,
          punctuation: /[\[\].?]/
        }
      },
      string: {
        pattern: a,
        greedy: !0
      },
      function: [
        /\w+(?=\()/,
        {
          pattern: /(\|[^\S\r\n]*)\w+/,
          lookbehind: !0
        }
      ],
      boolean: /\b(?:false|true)\b/,
      number: i,
      operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
      punctuation: /[{}()\[\]|.,:]/
    }, t.hooks.add("before-tokenize", function(o) {
      var l = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g, c = "{literal}", d = "{/literal}", m = !1;
      t.languages["markup-templating"].buildPlaceholders(
        o,
        "soy",
        l,
        function(f) {
          return f === d && (m = !1), m ? !1 : (f === c && (m = !0), !0);
        }
      );
    }), t.hooks.add("after-tokenize", function(o) {
      t.languages["markup-templating"].tokenizePlaceholders(o, "soy");
    });
  })(e);
}
ku.displayName = "turtle";
ku.aliases = ["trig"];
function ku(e) {
  e.languages.turtle = {
    comment: {
      pattern: /#.*/,
      greedy: !0
    },
    "multiline-string": {
      pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
      greedy: !0,
      alias: "string",
      inside: {
        comment: /#.*/
      }
    },
    string: {
      pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
      greedy: !0
    },
    url: {
      pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
      greedy: !0,
      inside: {
        punctuation: /[<>]/
      }
    },
    function: {
      pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
      inside: {
        "local-name": {
          pattern: /([^:]*:)[\s\S]+/,
          lookbehind: !0
        },
        prefix: {
          pattern: /[\s\S]+/,
          inside: {
            punctuation: /:/
          }
        }
      }
    },
    number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
    punctuation: /[{}.,;()[\]]|\^\^/,
    boolean: /\b(?:false|true)\b/,
    keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
    tag: {
      pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
      inside: {
        punctuation: /@/
      }
    }
  }, e.languages.trig = e.languages.turtle;
}
Jb.displayName = "sparql";
Jb.aliases = ["rq"];
function Jb(e) {
  e.register(ku), e.languages.sparql = e.languages.extend("turtle", {
    boolean: /\b(?:false|true)\b/i,
    variable: {
      pattern: /[?$]\w+/,
      greedy: !0
    }
  }), e.languages.insertBefore("sparql", "punctuation", {
    keyword: [
      /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
      /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
      /\b(?:BASE|GRAPH|PREFIX)\b/i
    ]
  }), e.languages.rq = e.languages.sparql;
}
eE.displayName = "splunk-spl";
eE.aliases = [];
function eE(e) {
  e.languages["splunk-spl"] = {
    comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
    string: {
      pattern: /"(?:\\.|[^\\"])*"/,
      greedy: !0
    },
    // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
    keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
    "operator-word": {
      pattern: /\b(?:and|as|by|not|or|xor)\b/i,
      alias: "operator"
    },
    function: /\b\w+(?=\s*\()/,
    property: /\b\w+(?=\s*=(?!=))/,
    date: {
      // MM/DD/YYYY(:HH:MM:SS)?
      pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
      alias: "number"
    },
    number: /\b\d+(?:\.\d+)?\b/,
    boolean: /\b(?:f|false|t|true)\b/i,
    operator: /[<>=]=?|[-+*/%|]/,
    punctuation: /[()[\],]/
  };
}
tE.displayName = "sqf";
tE.aliases = [];
function tE(e) {
  e.register(ze), e.languages.sqf = e.languages.extend("clike", {
    string: {
      pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
      greedy: !0
    },
    keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
    boolean: /\b(?:false|true)\b/i,
    function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
    number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
    operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
    "magic-variable": {
      pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
      alias: "keyword"
    },
    constant: /\bDIK(?:_[a-z\d]+)+\b/i
  }), e.languages.insertBefore("sqf", "string", {
    macro: {
      pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        directive: {
          pattern: /#[a-z]+\b/i,
          alias: "keyword"
        },
        comment: e.languages.sqf.comment
      }
    }
  }), delete e.languages.sqf["class-name"];
}
nE.displayName = "squirrel";
nE.aliases = [];
function nE(e) {
  e.register(ze), e.languages.squirrel = e.languages.extend("clike", {
    comment: [
      e.languages.clike.comment[0],
      {
        pattern: /(^|[^\\:])(?:\/\/|#).*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
      lookbehind: !0,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
      lookbehind: !0,
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
    number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
    operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
    punctuation: /[(){}\[\],;.]/
  }), e.languages.insertBefore("squirrel", "string", {
    char: {
      pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
      lookbehind: !0,
      greedy: !0
    }
  }), e.languages.insertBefore("squirrel", "operator", {
    "attribute-punctuation": {
      pattern: /<\/|\/>/,
      alias: "important"
    },
    lambda: {
      pattern: /@(?=\()/,
      alias: "operator"
    }
  });
}
aE.displayName = "stan";
aE.aliases = [];
function aE(e) {
  (function(t) {
    var a = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
    t.languages.stan = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
      string: {
        // String literals can contain spaces and any printable ASCII characters except for " and \
        // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
        pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
        greedy: !0
      },
      directive: {
        pattern: /^([ \t]*)#include\b.*/m,
        lookbehind: !0,
        alias: "property"
      },
      "function-arg": {
        pattern: RegExp(
          "(" + a.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source
        ),
        lookbehind: !0,
        alias: "function"
      },
      constraint: {
        pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
        lookbehind: !0,
        inside: {
          expression: {
            pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          property: /\b[a-z]\w*(?=\s*=)/i,
          operator: /=/,
          punctuation: /^<|>$|,/
        }
      },
      keyword: [
        {
          pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
          alias: "program-block"
        },
        /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
        // these are functions that are known to take another function as their first argument.
        a
      ],
      function: /\b[a-z]\w*(?=\s*\()/i,
      number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
      boolean: /\b(?:false|true)\b/,
      operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
      punctuation: /[()\[\]{},;]/
    }, t.languages.stan.constraint.inside.expression.inside = t.languages.stan;
  })(e);
}
rE.displayName = "stata";
rE.aliases = [];
function rE(e) {
  e.register(ki), e.register(vu), e.register(Cu), e.languages.stata = {
    comment: [
      {
        pattern: /(^[ \t]*)\*.*/m,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|\s)\/\/.*|\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        greedy: !0
      }
    ],
    "string-literal": {
      pattern: /"[^"\r\n]*"|[`']".*?"[`']/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$\{[^{}]*\}|[`']\w[^`'\r\n]*[`']/,
          inside: {
            punctuation: /^\$\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: null
              // see below
            }
          }
        },
        string: /[\s\S]+/
      }
    },
    mata: {
      pattern: /(^[ \t]*mata[ \t]*:)[\s\S]+?(?=^end\b)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "language-mata",
      inside: e.languages.mata
    },
    java: {
      pattern: /(^[ \t]*java[ \t]*:)[\s\S]+?(?=^end\b)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "language-java",
      inside: e.languages.java
    },
    python: {
      pattern: /(^[ \t]*python[ \t]*:)[\s\S]+?(?=^end\b)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "language-python",
      inside: e.languages.python
    },
    command: {
      pattern: /(^[ \t]*(?:\.[ \t]+)?(?:(?:bayes|bootstrap|by|bysort|capture|collect|fmm|fp|frame|jackknife|mfp|mi|nestreg|noisily|permute|quietly|rolling|simulate|statsby|stepwise|svy|version|xi)\b[^:\r\n]*:[ \t]*|(?:capture|noisily|quietly|version)[ \t]+)?)[a-zA-Z]\w*/m,
      lookbehind: !0,
      greedy: !0,
      alias: "keyword"
    },
    variable: /\$\w+|[`']\w[^`'\r\n]*[`']/,
    keyword: /\b(?:bayes|bootstrap|by|bysort|capture|clear|collect|fmm|fp|frame|if|in|jackknife|mi[ \t]+estimate|mfp|nestreg|noisily|of|permute|quietly|rolling|simulate|sort|statsby|stepwise|svy|varlist|version|xi)\b/,
    boolean: /\b(?:off|on)\b/,
    number: /\b\d+(?:\.\d+)?\b|\B\.\d+/,
    function: /\b[a-z_]\w*(?=\()/i,
    operator: /\+\+|--|##?|[<>!=~]=?|[+\-*^&|/]/,
    punctuation: /[(){}[\],:]/
  }, e.languages.stata["string-literal"].inside.interpolation.inside.expression.inside = e.languages.stata;
}
iE.displayName = "iecst";
iE.aliases = [];
function iE(e) {
  e.languages.iecst = {
    comment: [
      {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    keyword: [
      /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
      /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
    ],
    "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
    address: {
      pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
      alias: "symbol"
    },
    number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/,
    operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    punctuation: /[()[\].,;]/
  };
}
sE.displayName = "supercollider";
sE.aliases = ["sclang"];
function sE(e) {
  e.languages.supercollider = {
    comment: {
      pattern: /\/\/.*|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\//,
      greedy: !0
    },
    string: {
      pattern: /(^|[^\\])"(?:[^"\\]|\\[\s\S])*"/,
      lookbehind: !0,
      greedy: !0
    },
    char: {
      pattern: /\$(?:[^\\\r\n]|\\.)/,
      greedy: !0
    },
    symbol: {
      pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'|\\\w+/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /\b(?:_|arg|classvar|const|nil|var|while)\b/,
    boolean: /\b(?:false|true)\b/,
    label: {
      pattern: /\b[a-z_]\w*(?=\s*:)/,
      alias: "property"
    },
    number: /\b(?:inf|pi|0x[0-9a-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(?:pi)?|\d+r[0-9a-zA-Z]+(?:\.[0-9a-zA-Z]+)?|\d+[sb]{1,4}\d*)\b/,
    "class-name": /\b[A-Z]\w*\b/,
    operator: /\.{2,3}|#(?![[{])|&&|[!=]==?|\+>>|\+{1,3}|-[->]|=>|>>|\?\?|@\|?@|\|(?:@|[!=]=)?\||!\?|<[!=>]|\*{1,2}|<{2,3}\*?|[-!%&/<>?@|=`]/,
    punctuation: /[{}()[\].:,;]|#[[{]/
  }, e.languages.sclang = e.languages.supercollider;
}
oE.displayName = "swift";
oE.aliases = [];
function oE(e) {
  e.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + // single-line string
          /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
          /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + // single-line string
          /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
          /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
        //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
        // where <round> is a general parentheses expression.
        /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, e.languages.swift["string-literal"].forEach(function(t) {
    t.inside.interpolation.inside = e.languages.swift;
  });
}
lE.displayName = "systemd";
lE.aliases = [];
function lE(e) {
  (function(t) {
    var a = {
      pattern: /^[;#].*/m,
      greedy: !0
    }, i = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
    t.languages.systemd = {
      comment: a,
      section: {
        pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
        greedy: !0,
        inside: {
          punctuation: /^\[|\]$/,
          "section-name": {
            pattern: /[\s\S]+/,
            alias: "selector"
          }
        }
      },
      key: {
        pattern: /^[^\s=]+(?=[ \t]*=)/m,
        greedy: !0,
        alias: "attr-name"
      },
      value: {
        // This pattern is quite complex because of two properties:
        //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
        //     the lookbehind. You will see this in the main loop where spaces are handled separately.
        //  2) Line continuations.
        //     After line continuations, empty lines and comments are ignored so we have to consume them.
        pattern: RegExp(
          /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
          "(?:" + i + `|(?=[^"\r
]))(?:` + (/[^\s\\]/.source + // handle spaces separately because of quotes
          '|[ 	]+(?:(?![ 	"])|' + i + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "attr-value",
        inside: {
          comment: a,
          quoted: {
            pattern: RegExp(/(^|\s)/.source + i),
            lookbehind: !0,
            greedy: !0
          },
          punctuation: /\\$/m,
          boolean: {
            pattern: /^(?:false|no|off|on|true|yes)$/,
            greedy: !0
          }
        }
      },
      punctuation: /=/
    };
  })(e);
}
ho.displayName = "t4-templating";
ho.aliases = [];
function ho(e) {
  (function(t) {
    function a(o, l, c) {
      return {
        pattern: RegExp("<#" + o + "[\\s\\S]*?#>"),
        alias: "block",
        inside: {
          delimiter: {
            pattern: RegExp("^<#" + o + "|#>$"),
            alias: "important"
          },
          content: {
            pattern: /[\s\S]+/,
            inside: l,
            alias: c
          }
        }
      };
    }
    function i(o) {
      var l = t.languages[o], c = "language-" + o;
      return {
        block: {
          pattern: /<#[\s\S]+?#>/,
          inside: {
            directive: a("@", {
              "attr-value": {
                pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                inside: {
                  punctuation: /^=|^["']|["']$/
                }
              },
              keyword: /\b\w+(?=\s)/,
              "attr-name": /\b\w+/
            }),
            expression: a("=", l, c),
            "class-feature": a("\\+", l, c),
            standard: a("", l, c)
          }
        }
      };
    }
    t.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
      value: i
    });
  })(e);
}
uE.displayName = "t4-cs";
uE.aliases = ["t4"];
function uE(e) {
  e.register(Ci), e.register(ho), e.languages.t4 = e.languages["t4-cs"] = e.languages["t4-templating"].createT4("csharp");
}
Iu.displayName = "vbnet";
Iu.aliases = [];
function Iu(e) {
  e.register(Nu), e.languages.vbnet = e.languages.extend("basic", {
    comment: [
      {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          keyword: /^REM/i
        }
      },
      {
        pattern: /(^|[^\\:])'.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
      lookbehind: !0,
      greedy: !0
    },
    keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
    punctuation: /[,;:(){}]/
  });
}
cE.displayName = "t4-vb";
cE.aliases = [];
function cE(e) {
  e.register(ho), e.register(Iu), e.languages["t4-vb"] = e.languages["t4-templating"].createT4("vbnet");
}
dE.displayName = "tap";
dE.aliases = [];
function dE(e) {
  e.register(Au), e.languages.tap = {
    fail: /not ok[^#{\n\r]*/,
    pass: /ok[^#{\n\r]*/,
    pragma: /pragma [+-][a-z]+/,
    bailout: /bail out!.*/i,
    version: /TAP version \d+/i,
    plan: /\b\d+\.\.\d+(?: +#.*)?/,
    subtest: {
      pattern: /# Subtest(?:: .*)?/,
      greedy: !0
    },
    punctuation: /[{}]/,
    directive: /#.*/,
    yamlish: {
      pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
      lookbehind: !0,
      inside: e.languages.yaml,
      alias: "language-yaml"
    }
  };
}
pE.displayName = "tcl";
pE.aliases = [];
function pE(e) {
  e.languages.tcl = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0
    },
    string: {
      pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
      greedy: !0
    },
    variable: [
      {
        pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
        lookbehind: !0
      },
      {
        pattern: /(\$)\{[^}]+\}/,
        lookbehind: !0
      },
      {
        pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
        lookbehind: !0
      }
    ],
    function: {
      pattern: /(^[\t ]*proc[ \t]+)\S+/m,
      lookbehind: !0
    },
    builtin: [
      {
        pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
        lookbehind: !0
      },
      /\b(?:else|elseif)\b/
    ],
    scope: {
      pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
      lookbehind: !0,
      alias: "constant"
    },
    keyword: {
      pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
      lookbehind: !0
    },
    operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
    punctuation: /[{}()\[\]]/
  };
}
fE.displayName = "tt2";
fE.aliases = [];
function fE(e) {
  e.register(ze), e.register(Ft), (function(t) {
    t.languages.tt2 = t.languages.extend("clike", {
      comment: /#.*|\[%#[\s\S]*?%\]/,
      keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
      punctuation: /[[\]{},()]/
    }), t.languages.insertBefore("tt2", "number", {
      operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
      variable: {
        pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
      }
    }), t.languages.insertBefore("tt2", "keyword", {
      delimiter: {
        pattern: /^(?:\[%|%%)-?|-?%\]$/,
        alias: "punctuation"
      }
    }), t.languages.insertBefore("tt2", "string", {
      "single-quoted-string": {
        pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
        greedy: !0,
        alias: "string"
      },
      "double-quoted-string": {
        pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
        greedy: !0,
        alias: "string",
        inside: {
          variable: {
            pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
          }
        }
      }
    }), delete t.languages.tt2.string, t.hooks.add("before-tokenize", function(a) {
      var i = /\[%[\s\S]+?%\]/g;
      t.languages["markup-templating"].buildPlaceholders(
        a,
        "tt2",
        i
      );
    }), t.hooks.add("after-tokenize", function(a) {
      t.languages["markup-templating"].tokenizePlaceholders(a, "tt2");
    });
  })(e);
}
mE.displayName = "toml";
mE.aliases = [];
function mE(e) {
  (function(t) {
    var a = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
    function i(o) {
      return o.replace(/__/g, function() {
        return a;
      });
    }
    t.languages.toml = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      table: {
        pattern: RegExp(
          i(
            /(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source
          ),
          "m"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "class-name"
      },
      key: {
        pattern: RegExp(
          i(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
          "m"
        ),
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      string: {
        pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      date: [
        {
          // Offset Date-Time, Local Date-Time, Local Date
          pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
          alias: "number"
        },
        {
          // Local Time
          pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
          alias: "number"
        }
      ],
      number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /[.,=[\]{}]/
    };
  })(e);
}
gE.displayName = "tremor";
gE.aliases = ["trickle", "troy"];
function gE(e) {
  (function(t) {
    t.languages.tremor = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: !0
      },
      "interpolated-string": null,
      // see below
      extractor: {
        pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
        greedy: !0,
        inside: {
          regex: {
            pattern: /(^re)\|[\s\S]+/,
            lookbehind: !0
          },
          function: /^\w+/,
          value: /\|[\s\S]+/
        }
      },
      identifier: {
        pattern: /`[^`]*`/,
        greedy: !0
      },
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
      keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
      boolean: /\b(?:false|null|true)\b/i,
      number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
      "pattern-punctuation": {
        pattern: /%(?=[({[])/,
        alias: "punctuation"
      },
      operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
      punctuation: /::|[;\[\]()\{\},.:]/
    };
    var a = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
    t.languages.tremor["interpolated-string"] = {
      pattern: RegExp(
        /(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + a + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + a + ')*")'
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: RegExp(a),
          inside: {
            punctuation: /^#\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              inside: t.languages.tremor
            }
          }
        },
        string: /[\s\S]+/
      }
    }, t.languages.troy = t.languages.tremor, t.languages.trickle = t.languages.tremor;
  })(e);
}
hE.displayName = "typoscript";
hE.aliases = ["tsconfig"];
function hE(e) {
  (function(t) {
    var a = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
    t.languages.typoscript = {
      comment: [
        {
          // multiline comments /* */
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0
        },
        {
          // double-slash comments - ignored when backslashes or colon is found in front
          // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
          pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // hash comments - ignored when leading quote is found for hex colors in strings
          pattern: /(^|[^"'])#.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      function: [
        {
          // old include style
          pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
          inside: {
            string: {
              pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
              inside: {
                keyword: a
              }
            },
            keyword: {
              pattern: /INCLUDE_TYPOSCRIPT/
            }
          }
        },
        {
          // new include style
          pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
          inside: {
            string: /"[^"\r\n]*"|'[^'\r\n]*'/
          }
        }
      ],
      string: {
        pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
        lookbehind: !0,
        inside: {
          function: /\{\$.*\}/,
          // constants include
          keyword: a,
          number: /^\d+$/,
          punctuation: /[,|:]/
        }
      },
      keyword: a,
      number: {
        // special highlighting for indexes of arrays in tags
        pattern: /\b\d+\s*[.{=]/,
        inside: {
          operator: /[.{=]/
        }
      },
      tag: {
        pattern: /\.?[-\w\\]+\.?/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /[{}[\];(),.:|]/,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
    }, t.languages.tsconfig = t.languages.typoscript;
  })(e);
}
bE.displayName = "unrealscript";
bE.aliases = ["uc", "uscript"];
function bE(e) {
  e.languages.unrealscript = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    category: {
      pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    },
    metadata: {
      pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        property: /\b\w+(?=\s*=)/,
        operator: /=/,
        punctuation: /[<>|]/
      }
    },
    macro: {
      pattern: /`\w+/,
      alias: "property"
    },
    "class-name": {
      pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
      lookbehind: !0
    },
    keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    boolean: /\b(?:false|true)\b/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
    operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
    punctuation: /[()[\]{};,.]/
  }, e.languages.uc = e.languages.uscript = e.languages.unrealscript;
}
EE.displayName = "uorazor";
EE.aliases = [];
function EE(e) {
  e.languages.uorazor = {
    "comment-hash": {
      pattern: /#.*/,
      alias: "comment",
      greedy: !0
    },
    "comment-slash": {
      pattern: /\/\/.*/,
      alias: "comment",
      greedy: !0
    },
    string: {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      inside: {
        punctuation: /^['"]|['"]$/
      },
      greedy: !0
    },
    "source-layers": {
      pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
      alias: "function"
    },
    "source-commands": {
      pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
      alias: "function"
    },
    "tag-name": {
      pattern: /(^\{%-?\s*)\w+/,
      lookbehind: !0,
      alias: "keyword"
    },
    delimiter: {
      pattern: /^\{[{%]-?|-?[%}]\}$/,
      alias: "punctuation"
    },
    function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
    keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
    boolean: /\b(?:false|null|true)\b/,
    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
    operator: [
      {
        pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
        lookbehind: !0
      },
      /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
    ],
    punctuation: /[()\[\]{}:.,]/
  };
}
yE.displayName = "v";
yE.aliases = [];
function yE(e) {
  e.register(ze), (function(t) {
    var a = {
      pattern: /[\s\S]+/,
      inside: null
    };
    t.languages.v = t.languages.extend("clike", {
      string: {
        pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        alias: "quoted-string",
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
            lookbehind: !0,
            inside: {
              "interpolation-variable": {
                pattern: /^\$\w[\s\S]*$/,
                alias: "variable"
              },
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              "interpolation-expression": a
            }
          }
        }
      },
      "class-name": {
        pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
        lookbehind: !0
      },
      keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
      number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
      operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
      builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
    }), a.inside = t.languages.v, t.languages.insertBefore("v", "string", {
      char: {
        pattern: /`(?:\\`|\\?[^`]{1,2})`/,
        // using {1,2} instead of `u` flag for compatibility
        alias: "rune"
      }
    }), t.languages.insertBefore("v", "operator", {
      attribute: {
        pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
        lookbehind: !0,
        alias: "annotation",
        inside: {
          punctuation: /[\[\]]/,
          keyword: /\w+/
        }
      },
      generic: {
        pattern: /<\w+>(?=\s*[\)\{])/,
        inside: {
          punctuation: /[<>]/,
          "class-name": /\w+/
        }
      }
    }), t.languages.insertBefore("v", "function", {
      "generic-function": {
        // e.g. foo<T>( ...
        pattern: /\b\w+\s*<\w+>(?=\()/,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<\w+>/,
            inside: t.languages.v.generic.inside
          }
        }
      }
    });
  })(e);
}
TE.displayName = "vala";
TE.aliases = [];
function TE(e) {
  e.register(ze), e.languages.vala = e.languages.extend("clike", {
    // Classes copied from prism-csharp
    "class-name": [
      {
        // (Foo bar, Bar baz)
        pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
        inside: {
          punctuation: /\./
        }
      },
      {
        // [Foo]
        pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      {
        // class Foo : Bar
        pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      {
        // class Foo
        pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    ],
    keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
    function: /\b\w+(?=\s*\()/,
    number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
    operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
    punctuation: /[{}[\];(),.:]/,
    constant: /\b[A-Z0-9_]+\b/
  }), e.languages.insertBefore("vala", "string", {
    "raw-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    "template-string": {
      pattern: /@"[\s\S]*?"/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
          inside: {
            delimiter: {
              pattern: /^\$\(?|\)$/,
              alias: "punctuation"
            },
            rest: e.languages.vala
          }
        },
        string: /[\s\S]+/
      }
    }
  }), e.languages.insertBefore("vala", "keyword", {
    regex: {
      pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: e.languages.regex
        },
        "regex-delimiter": /^\//,
        "regex-flags": /^[a-z]+$/
      }
    }
  });
}
SE.displayName = "velocity";
SE.aliases = [];
function SE(e) {
  e.register(xt), (function(t) {
    t.languages.velocity = t.languages.extend("markup", {});
    var a = {
      variable: {
        pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
        lookbehind: !0,
        inside: {}
        // See below
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      number: /\b\d+\b/,
      boolean: /\b(?:false|true)\b/,
      operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
      punctuation: /[(){}[\]:,.]/
    };
    a.variable.inside = {
      string: a.string,
      function: {
        pattern: /([^\w-])[a-z][\w-]*(?=\()/,
        lookbehind: !0
      },
      number: a.number,
      boolean: a.boolean,
      punctuation: a.punctuation
    }, t.languages.insertBefore("velocity", "comment", {
      unparsed: {
        pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          punctuation: /^#\[\[|\]\]#$/
        }
      },
      "velocity-comment": [
        {
          pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        },
        {
          pattern: /(^|[^\\])##.*/,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        }
      ],
      directive: {
        pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
            inside: {
              punctuation: /[{}]/
            }
          },
          rest: a
        }
      },
      variable: a.variable
    }), t.languages.velocity.tag.inside["attr-value"].inside.rest = t.languages.velocity;
  })(e);
}
_E.displayName = "verilog";
_E.aliases = [];
function _E(e) {
  e.languages.verilog = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
      greedy: !0
    },
    string: {
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: !0
    },
    "kernel-function": {
      // support for any kernel function (ex: $display())
      pattern: /\B\$\w+\b/,
      alias: "property"
    },
    // support for user defined constants (ex: `define)
    constant: /\B`\w+\b/,
    function: /\b\w+(?=\()/,
    // support for verilog and system verilog keywords
    keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
    // bold highlighting for all verilog and system verilog logic blocks
    important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
    // support for time ticks, vectors, and real numbers
    number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
    operator: /[-+{}^~%*\/?=!<>&|]+/,
    punctuation: /[[\];(),.:]/
  };
}
AE.displayName = "vhdl";
AE.aliases = [];
function AE(e) {
  e.languages.vhdl = {
    comment: /--.+/,
    // support for all logic vectors
    "vhdl-vectors": {
      pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
      alias: "number"
    },
    // support for operator overloading included
    "quoted-function": {
      pattern: /"\S+?"(?=\()/,
      alias: "function"
    },
    string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
    attribute: {
      pattern: /\b'\w+/,
      alias: "attr-name"
    },
    // support for predefined attributes included
    keyword: /\b(?:access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|private|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|view|wait|when|while|with)\b/i,
    boolean: /\b(?:false|true)\b/i,
    function: /\w+(?=\()/,
    // decimal, based, physical, and exponential numbers supported
    number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
    operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
    punctuation: /[{}[\];(),.:]/
  };
}
NE.displayName = "vim";
NE.aliases = [];
function NE(e) {
  e.languages.vim = {
    string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
    comment: /".*/,
    function: /\b\w+(?=\()/,
    keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
    builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
    operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
    punctuation: /[{}[\](),;:]/
  };
}
RE.displayName = "visual-basic";
RE.aliases = ["vb", "vba"];
function RE(e) {
  e.languages["visual-basic"] = {
    comment: {
      pattern: /(?:[']|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
      inside: {
        keyword: /^REM/i
      }
    },
    directive: {
      pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
      alias: "property",
      greedy: !0
    },
    string: {
      pattern: /\$?["](?:["]{2}|[^"])*["]C?/i,
      greedy: !0
    },
    date: {
      pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
      alias: "number"
    },
    number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
    boolean: /\b(?:False|Nothing|True)\b/i,
    keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
    operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
    punctuation: /[{}().,:?]/
  }, e.languages.vb = e.languages["visual-basic"], e.languages.vba = e.languages["visual-basic"];
}
vE.displayName = "warpscript";
vE.aliases = [];
function vE(e) {
  e.languages.warpscript = {
    comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
    string: {
      pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
      greedy: !0
    },
    variable: /\$\S+/,
    macro: {
      pattern: /@\S+/,
      alias: "property"
    },
    // WarpScript doesn't have any keywords, these are all functions under the control category
    // https://www.warp10.io/tags/control
    keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
    number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
    boolean: /\b(?:F|T|false|true)\b/,
    punctuation: /<%|%>|[{}[\]()]/,
    // Some operators from the "operators" category
    // https://www.warp10.io/tags/operators
    operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
  };
}
CE.displayName = "wasm";
CE.aliases = [];
function CE(e) {
  e.languages.wasm = {
    comment: [
      /\(;[\s\S]*?;\)/,
      {
        pattern: /;;.*/,
        greedy: !0
      }
    ],
    string: {
      pattern: /"(?:\\[\s\S]|[^"\\])*"/,
      greedy: !0
    },
    keyword: [
      {
        pattern: /\b(?:align|offset)=/,
        inside: {
          operator: /=/
        }
      },
      {
        pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
        inside: {
          punctuation: /\./
        }
      },
      /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
    ],
    variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
    number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
    punctuation: /[()]/
  };
}
wE.displayName = "web-idl";
wE.aliases = ["webidl"];
function wE(e) {
  (function(t) {
    var a = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source, i = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + a + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source, o = {};
    t.languages["web-idl"] = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /"[^"]*"/,
        greedy: !0
      },
      namespace: {
        pattern: RegExp(/(\bnamespace\s+)/.source + a),
        lookbehind: !0
      },
      "class-name": [
        {
          pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
          lookbehind: !0,
          inside: o
        },
        {
          pattern: RegExp(
            /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + i
          ),
          lookbehind: !0,
          inside: o
        },
        {
          // callback return type
          pattern: RegExp(
            "(" + /\bcallback\s+/.source + a + /\s*=\s*/.source + ")" + i
          ),
          lookbehind: !0,
          inside: o
        },
        {
          // typedef
          pattern: RegExp(/(\btypedef\b\s*)/.source + i),
          lookbehind: !0,
          inside: o
        },
        {
          pattern: RegExp(
            /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + a
          ),
          lookbehind: !0
        },
        {
          // inheritance
          pattern: RegExp(/(:\s*)/.source + a),
          lookbehind: !0
        },
        // includes and implements
        RegExp(a + /(?=\s+(?:implements|includes)\b)/.source),
        {
          pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + a),
          lookbehind: !0
        },
        {
          // function return type, parameter types, and dictionary members
          pattern: RegExp(
            i + "(?=" + /\s*(?:\.{3}\s*)?/.source + a + /\s*[(),;=]/.source + ")"
          ),
          inside: o
        }
      ],
      builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
      keyword: [
        /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
        // type keywords
        /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
      ],
      boolean: /\b(?:false|true)\b/,
      number: {
        pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
        lookbehind: !0
      },
      operator: /\.{3}|[=:?<>-]/,
      punctuation: /[(){}[\].,;]/
    };
    for (var l in t.languages["web-idl"])
      l !== "class-name" && (o[l] = t.languages["web-idl"][l]);
    t.languages.webidl = t.languages["web-idl"];
  })(e);
}
kE.displayName = "wgsl";
kE.aliases = [];
function kE(e) {
  e.languages.wgsl = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    "builtin-attribute": {
      pattern: /(@)builtin\(.*?\)/,
      lookbehind: !0,
      inside: {
        attribute: {
          pattern: /^builtin/,
          alias: "attr-name"
        },
        punctuation: /[(),]/,
        "built-in-values": {
          pattern: /\b(?:frag_depth|front_facing|global_invocation_id|instance_index|local_invocation_id|local_invocation_index|num_workgroups|position|sample_index|sample_mask|vertex_index|workgroup_id)\b/,
          alias: "attr-value"
        }
      }
    },
    attributes: {
      pattern: /(@)(?:align|binding|compute|const|fragment|group|id|interpolate|invariant|location|size|vertex|workgroup_size)/i,
      lookbehind: !0,
      alias: "attr-name"
    },
    functions: {
      pattern: /\b(fn\s+)[_a-zA-Z]\w*(?=[(<])/,
      lookbehind: !0,
      alias: "function"
    },
    keyword: /\b(?:bitcast|break|case|const|continue|continuing|default|discard|else|enable|fallthrough|fn|for|function|if|let|loop|private|return|storage|struct|switch|type|uniform|var|while|workgroup)\b/,
    builtin: /\b(?:abs|acos|acosh|all|any|array|asin|asinh|atan|atan2|atanh|atomic|atomicAdd|atomicAnd|atomicCompareExchangeWeak|atomicExchange|atomicLoad|atomicMax|atomicMin|atomicOr|atomicStore|atomicSub|atomicXor|bool|ceil|clamp|cos|cosh|countLeadingZeros|countOneBits|countTrailingZeros|cross|degrees|determinant|distance|dot|dpdx|dpdxCoarse|dpdxFine|dpdy|dpdyCoarse|dpdyFine|exp|exp2|extractBits|f32|f64|faceForward|firstLeadingBit|floor|fma|fract|frexp|fwidth|fwidthCoarse|fwidthFine|i32|i64|insertBits|inverseSqrt|ldexp|length|log|log2|mat[2-4]x[2-4]|max|min|mix|modf|normalize|override|pack2x16float|pack2x16snorm|pack2x16unorm|pack4x8snorm|pack4x8unorm|pow|ptr|quantizeToF16|radians|reflect|refract|reverseBits|round|sampler|sampler_comparison|select|shiftLeft|shiftRight|sign|sin|sinh|smoothstep|sqrt|staticAssert|step|storageBarrier|tan|tanh|textureDimensions|textureGather|textureGatherCompare|textureLoad|textureNumLayers|textureNumLevels|textureNumSamples|textureSample|textureSampleBias|textureSampleCompare|textureSampleCompareLevel|textureSampleGrad|textureSampleLevel|textureStore|texture_1d|texture_2d|texture_2d_array|texture_3d|texture_cube|texture_cube_array|texture_depth_2d|texture_depth_2d_array|texture_depth_cube|texture_depth_cube_array|texture_depth_multisampled_2d|texture_multisampled_2d|texture_storage_1d|texture_storage_2d|texture_storage_2d_array|texture_storage_3d|transpose|trunc|u32|u64|unpack2x16float|unpack2x16snorm|unpack2x16unorm|unpack4x8snorm|unpack4x8unorm|vec[2-4]|workgroupBarrier)\b/,
    "function-calls": {
      pattern: /\b[_a-z]\w*(?=\()/i,
      alias: "function"
    },
    "class-name": /\b(?:[A-Z][A-Za-z0-9]*)\b/,
    "bool-literal": {
      pattern: /\b(?:false|true)\b/,
      alias: "boolean"
    },
    "hex-int-literal": {
      pattern: /\b0[xX][0-9a-fA-F]+[iu]?\b(?![.pP])/,
      alias: "number"
    },
    "hex-float-literal": {
      pattern: /\b0[xX][0-9a-fA-F]*(?:\.[0-9a-fA-F]*)?(?:[pP][+-]?\d+[fh]?)?/,
      alias: "number"
    },
    "decimal-float-literal": [
      {
        pattern: /\d*\.\d+(?:[eE](?:\+|-)?\d+)?[fh]?/,
        alias: "number"
      },
      {
        pattern: /\d+\.\d*(?:[eE](?:\+|-)?\d+)?[fh]?/,
        alias: "number"
      },
      {
        pattern: /\d+[eE](?:\+|-)?\d+[fh]?/,
        alias: "number"
      },
      {
        pattern: /\b\d+[fh]\b/,
        alias: "number"
      }
    ],
    "int-literal": {
      pattern: /\b\d+[iu]?\b/,
      alias: "number"
    },
    operator: [
      {
        pattern: /(?:\^|~|\|(?!\|)|\|\||&&|<<|>>|!)(?!=)/
      },
      {
        pattern: /&(?![&=])/
      },
      {
        pattern: /(?:\+=|-=|\*=|\/=|%=|\^=|&=|\|=|<<=|>>=)/
      },
      {
        pattern: /(^|[^<>=!])=(?![=>])/,
        lookbehind: !0
      },
      {
        pattern: /(?:==|!=|<=|\+\+|--|(^|[^=])>=)/,
        lookbehind: !0
      },
      {
        pattern: /(?:(?:[+%]|(?:\*(?!\w)))(?!=))|(?:-(?!>))|(?:\/(?!\/))/
      },
      {
        pattern: /->/
      }
    ],
    punctuation: /[@(){}[\],;<>:.]/
  };
}
IE.displayName = "wiki";
IE.aliases = [];
function IE(e) {
  e.register(xt), e.languages.wiki = e.languages.extend("markup", {
    "block-comment": {
      pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
      lookbehind: !0,
      alias: "comment"
    },
    heading: {
      pattern: /^(=+)[^=\r\n].*?\1/m,
      inside: {
        punctuation: /^=+|=+$/,
        important: /.+/
      }
    },
    emphasis: {
      // TODO Multi-line
      pattern: /('{2,5}).+?\1/,
      inside: {
        "bold-italic": {
          pattern: /(''''').+?(?=\1)/,
          lookbehind: !0,
          alias: ["bold", "italic"]
        },
        bold: {
          pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
          lookbehind: !0
        },
        italic: {
          pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
          lookbehind: !0
        },
        punctuation: /^''+|''+$/
      }
    },
    hr: {
      pattern: /^-{4,}/m,
      alias: "punctuation"
    },
    url: [
      /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
      /\[\[.+?\]\]|\[.+?\]/
    ],
    variable: [
      /__[A-Z]+__/,
      // FIXME Nested structures should be handled
      // {{formatnum:{{#expr:{{{3}}}}}}}
      /\{{3}.+?\}{3}/,
      /\{\{.+?\}\}/
    ],
    symbol: [/^#redirect/im, /~{3,5}/],
    // Handle table attrs:
    // {|
    // ! style="text-align:left;"| Item
    // |}
    "table-tag": {
      pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
      lookbehind: !0,
      inside: {
        "table-bar": {
          pattern: /\|$/,
          alias: "punctuation"
        },
        rest: e.languages.markup.tag.inside
      }
    },
    punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
  }), e.languages.insertBefore("wiki", "tag", {
    // Prevent highlighting inside <nowiki>, <source> and <pre> tags
    nowiki: {
      pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
      inside: {
        tag: {
          pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
          inside: e.languages.markup.tag.inside
        }
      }
    }
  });
}
OE.displayName = "wolfram";
OE.aliases = ["mathematica", "nb", "wl"];
function OE(e) {
  e.languages.wolfram = {
    comment: (
      // Allow one level of nesting - note: regex taken from applescipt
      /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/
    ),
    string: {
      pattern: /"(?:\\.|[^"\\\r\n])*"/,
      greedy: !0
    },
    keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
    context: {
      pattern: /\b\w+`+\w*/,
      alias: "class-name"
    },
    blank: {
      pattern: /\b\w+_\b/,
      alias: "regex"
    },
    "global-variable": {
      pattern: /\$\w+/,
      alias: "variable"
    },
    boolean: /\b(?:False|True)\b/,
    number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
    operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, e.languages.mathematica = e.languages.wolfram, e.languages.wl = e.languages.wolfram, e.languages.nb = e.languages.wolfram;
}
xE.displayName = "wren";
xE.aliases = [];
function xE(e) {
  e.languages.wren = {
    // Multiline comments in Wren can have nested multiline comments
    // Comments: // and /* */
    comment: [
      {
        // support 3 levels of nesting
        // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
        pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    // Triple quoted strings are multiline but cannot have interpolation (raw strings)
    // Based on prism-python.js
    "triple-quoted-string": {
      pattern: /"""[\s\S]*?"""/,
      greedy: !0,
      alias: "string"
    },
    // see below
    "string-literal": null,
    // #!/usr/bin/env wren on the first line
    hashbang: {
      pattern: /^#!\/.+/,
      greedy: !0,
      alias: "comment"
    },
    // Attributes are special keywords to add meta data to classes
    attribute: {
      // #! attributes are stored in class properties
      // #!myvar = true
      // #attributes are not stored and dismissed at compilation
      pattern: /#!?[ \t\u3000]*\w+/,
      alias: "keyword"
    },
    "class-name": [
      {
        // class definition
        // class Meta {}
        pattern: /(\bclass\s+)\w+/,
        lookbehind: !0
      },
      // A class must always start with an uppercase.
      // File.read
      /\b[A-Z][a-z\d_]*\b/
    ],
    // A constant can be a variable, class, property or method. Just named in all uppercase letters
    constant: /\b[A-Z][A-Z\d_]*\b/,
    null: {
      pattern: /\bnull\b/,
      alias: "keyword"
    },
    keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
    // Functions can be Class.method()
    function: /\b[a-z_]\w*(?=\s*[({])/i,
    operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
    punctuation: /[\[\](){}.,;]/
  }, e.languages.wren["string-literal"] = {
    // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
    pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
    lookbehind: !0,
    greedy: !0,
    inside: {
      interpolation: {
        // "%(interpolation)"
        pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
        lookbehind: !0,
        inside: {
          expression: {
            pattern: /^(%\()[\s\S]+(?=\)$)/,
            lookbehind: !0,
            inside: e.languages.wren
          },
          "interpolation-punctuation": {
            pattern: /^%\(|\)$/,
            alias: "punctuation"
          }
        }
      },
      string: /[\s\S]+/
    }
  };
}
LE.displayName = "xeora";
LE.aliases = ["xeoracube"];
function LE(e) {
  e.register(xt), (function(t) {
    t.languages.xeora = t.languages.extend("markup", {
      constant: {
        pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
        inside: {
          punctuation: {
            pattern: /\$/
          }
        }
      },
      variable: {
        pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
        inside: {
          punctuation: {
            pattern: /[$.]/
          },
          operator: {
            pattern: /#+|[-+*~=^@]/
          }
        }
      },
      "function-inline": {
        pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
        inside: {
          variable: {
            pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
            inside: {
              punctuation: {
                pattern: /[,.|]/
              },
              operator: {
                pattern: /#+|[-+*~=^@]/
              }
            }
          },
          punctuation: {
            pattern: /\$\w:|[$:?.,|]/
          }
        },
        alias: "function"
      },
      "function-block": {
        pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
        inside: {
          punctuation: {
            pattern: /[$:{}?.,|]/
          }
        },
        alias: "function"
      },
      "directive-inline": {
        pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
        inside: {
          punctuation: {
            pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
            inside: {
              tag: {
                pattern: /#\d/
              }
            }
          }
        },
        alias: "function"
      },
      "directive-block-open": {
        pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
        inside: {
          punctuation: {
            pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
            inside: {
              tag: {
                pattern: /#\d/
              }
            }
          },
          attribute: {
            pattern: /![A-Z]+$/,
            inside: {
              punctuation: {
                pattern: /!/
              }
            },
            alias: "keyword"
          }
        },
        alias: "function"
      },
      "directive-block-separator": {
        pattern: /\}:[-\w.]+:\{/,
        inside: {
          punctuation: {
            pattern: /[:{}]/
          }
        },
        alias: "function"
      },
      "directive-block-close": {
        pattern: /\}:[-\w.]+\$/,
        inside: {
          punctuation: {
            pattern: /[:{}$]/
          }
        },
        alias: "function"
      }
    }), t.languages.insertBefore(
      "inside",
      "punctuation",
      {
        variable: t.languages.xeora["function-inline"].inside.variable
      },
      t.languages.xeora["function-block"]
    ), t.languages.xeoracube = t.languages.xeora;
  })(e);
}
DE.displayName = "xml-doc";
DE.aliases = [];
function DE(e) {
  e.register(xt), (function(t) {
    function a(c, d) {
      t.languages[c] && t.languages.insertBefore(c, "comment", {
        "doc-comment": d
      });
    }
    var i = t.languages.markup.tag, o = {
      pattern: /\/\/\/.*/,
      greedy: !0,
      alias: "comment",
      inside: {
        tag: i
      }
    }, l = {
      pattern: /'''.*/,
      greedy: !0,
      alias: "comment",
      inside: {
        tag: i
      }
    };
    a("csharp", o), a("fsharp", o), a("vbnet", l);
  })(e);
}
ME.displayName = "xojo";
ME.aliases = [];
function ME(e) {
  e.languages.xojo = {
    comment: {
      pattern: /(?:'|\/\/|Rem\b).+/i,
      greedy: !0
    },
    string: {
      pattern: /"(?:""|[^"])*"/,
      greedy: !0
    },
    number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
    directive: {
      pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
      alias: "property"
    },
    keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
    operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
    punctuation: /[.,;:()]/
  };
}
UE.displayName = "xquery";
UE.aliases = [];
function UE(e) {
  e.register(xt), (function(t) {
    t.languages.xquery = t.languages.extend("markup", {
      "xquery-comment": {
        pattern: /\(:[\s\S]*?:\)/,
        greedy: !0,
        alias: "comment"
      },
      string: {
        pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
        greedy: !0
      },
      extension: {
        pattern: /\(#.+?#\)/,
        alias: "symbol"
      },
      variable: /\$[-\w:]+/,
      axis: {
        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
        lookbehind: !0,
        alias: "operator"
      },
      "keyword-operator": {
        pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
        lookbehind: !0,
        alias: "operator"
      },
      keyword: {
        pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
        lookbehind: !0
      },
      function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
      "xquery-element": {
        pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
        lookbehind: !0,
        alias: "tag"
      },
      "xquery-attribute": {
        pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
        lookbehind: !0,
        alias: "attr-name"
      },
      builtin: {
        pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
        lookbehind: !0
      },
      number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
      operator: [
        /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
        {
          pattern: /(\s)-(?=\s)/,
          lookbehind: !0
        }
      ],
      punctuation: /[[\](){},;:/]/
    }), t.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, t.languages.xquery.tag.inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/, t.languages.xquery.tag.inside["attr-value"].inside.punctuation = /^="|"$/, t.languages.xquery.tag.inside["attr-value"].inside.expression = {
      // Allow for two levels of nesting
      pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
      inside: t.languages.xquery,
      alias: "language-xquery"
    };
    var a = function(o) {
      return typeof o == "string" ? o : typeof o.content == "string" ? o.content : o.content.map(a).join("");
    }, i = function(o) {
      for (var l = [], c = 0; c < o.length; c++) {
        var d = o[c], m = !1;
        if (typeof d != "string" && (d.type === "tag" && d.content[0] && d.content[0].type === "tag" ? d.content[0].content[0].content === "</" ? l.length > 0 && l[l.length - 1].tagName === a(d.content[0].content[1]) && l.pop() : d.content[d.content.length - 1].content === "/>" || l.push({
          tagName: a(d.content[0].content[1]),
          openedBraces: 0
        }) : l.length > 0 && d.type === "punctuation" && d.content === "{" && // Ignore `{{`
        (!o[c + 1] || o[c + 1].type !== "punctuation" || o[c + 1].content !== "{") && (!o[c - 1] || o[c - 1].type !== "plain-text" || o[c - 1].content !== "{") ? l[l.length - 1].openedBraces++ : l.length > 0 && l[l.length - 1].openedBraces > 0 && d.type === "punctuation" && d.content === "}" ? l[l.length - 1].openedBraces-- : d.type !== "comment" && (m = !0)), (m || typeof d == "string") && l.length > 0 && l[l.length - 1].openedBraces === 0) {
          var f = a(d);
          c < o.length - 1 && (typeof o[c + 1] == "string" || o[c + 1].type === "plain-text") && (f += a(o[c + 1]), o.splice(c + 1, 1)), c > 0 && (typeof o[c - 1] == "string" || o[c - 1].type === "plain-text") && (f = a(o[c - 1]) + f, o.splice(c - 1, 1), c--), /^\s+$/.test(f) ? o[c] = f : o[c] = new t.Token(
            "plain-text",
            f,
            null,
            f
          );
        }
        d.content && typeof d.content != "string" && i(d.content);
      }
    };
    t.hooks.add("after-tokenize", function(o) {
      o.language === "xquery" && i(o.tokens);
    });
  })(e);
}
BE.displayName = "yang";
BE.aliases = [];
function BE(e) {
  e.languages.yang = {
    // https://tools.ietf.org/html/rfc6020#page-34
    // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
    comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
    string: {
      pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
      greedy: !0
    },
    keyword: {
      pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
      lookbehind: !0
    },
    namespace: {
      pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
      lookbehind: !0
    },
    boolean: /\b(?:false|true)\b/,
    operator: /\+/,
    punctuation: /[{};:]/
  };
}
FE.displayName = "zig";
FE.aliases = [];
function FE(e) {
  (function(t) {
    function a(f) {
      return function() {
        return f;
      };
    }
    var i = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/, o = "\\b(?!" + i.source + ")(?!\\d)\\w+\\b", l = /align\s*\((?:[^()]|\([^()]*\))*\)/.source, c = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
      /<ALIGN>/g,
      a(l)
    ), d = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
      /<ID>/g,
      a(o)
    ), m = "(?!\\s)(?:!?\\s*(?:" + c + "\\s*)*" + d + ")+";
    t.languages.zig = {
      comment: [
        {
          pattern: /\/\/[/!].*/,
          alias: "doc-comment"
        },
        /\/{2}.*/
      ],
      string: [
        {
          // "string" and c"string"
          pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
          lookbehind: !0,
          greedy: !0
        },
        {
          // multiline strings and c-strings
          pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      char: {
        // characters 'a', '\n', '\xFF', '\u{10FFFF}'
        pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
        lookbehind: !0,
        greedy: !0
      },
      builtin: /\B@(?!\d)\w+(?=\s*\()/,
      label: {
        pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
        lookbehind: !0
      },
      "class-name": [
        // const Foo = struct {};
        /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
        {
          // const x: i32 = 9;
          // var x: Bar;
          // fn foo(x: bool, y: f32) void {}
          pattern: RegExp(
            /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, a(m)).replace(/<ALIGN>/g, a(l))
          ),
          lookbehind: !0,
          inside: null
          // see below
        },
        {
          // extern fn foo(x: f64) f64; (optional alignment)
          pattern: RegExp(
            /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, a(m)).replace(/<ALIGN>/g, a(l))
          ),
          lookbehind: !0,
          inside: null
          // see below
        }
      ],
      "builtin-type": {
        pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
        alias: "keyword"
      },
      keyword: i,
      function: /\b(?!\d)\w+(?=\s*\()/,
      number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
      boolean: /\b(?:false|true)\b/,
      operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
      punctuation: /[.:,;(){}[\]]/
    }, t.languages.zig["class-name"].forEach(function(f) {
      f.inside === null && (f.inside = t.languages.zig);
    });
  })(e);
}
N.register(xt);
N.register(Sr);
N.register(ze);
N.register(Pf);
N.register(Bt);
N.register(Hf);
N.register(zf);
N.register(Gf);
N.register(jf);
N.register($f);
N.register(qf);
N.register(Yf);
N.register(Vf);
N.register(co);
N.register(Wf);
N.register(Xf);
N.register(Kf);
N.register(Zf);
N.register(jn);
N.register(vi);
N.register(Qf);
N.register(Jf);
N.register(em);
N.register(_u);
N.register(Au);
N.register(tm);
N.register(nm);
N.register(am);
N.register(Ci);
N.register(rm);
N.register(im);
N.register(sm);
N.register(om);
N.register(lm);
N.register(um);
N.register(cm);
N.register(dm);
N.register(Nu);
N.register(pm);
N.register(fm);
N.register(mm);
N.register(gm);
N.register(hm);
N.register(bm);
N.register(Em);
N.register(ym);
N.register(Tm);
N.register(Sm);
N.register(_m);
N.register(Am);
N.register(Nm);
N.register(Rm);
N.register(vm);
N.register(Cm);
N.register(wm);
N.register(km);
N.register(Im);
N.register(Om);
N.register(xm);
N.register(Lm);
N.register(Dm);
N.register(Mm);
N.register(Um);
N.register(wi);
N.register(Bm);
N.register(Fm);
N.register(Pm);
N.register(Hm);
N.register(zm);
N.register(Gm);
N.register(jm);
N.register($m);
N.register(qm);
N.register(Ym);
N.register(Vm);
N.register(Ft);
N.register(Wm);
N.register(Xm);
N.register(Km);
N.register(Zm);
N.register(Qm);
N.register(Jm);
N.register(eg);
N.register(tg);
N.register(ng);
N.register(ag);
N.register(Ru);
N.register(rg);
N.register(ig);
N.register(sg);
N.register(og);
N.register(lg);
N.register(ug);
N.register(cg);
N.register(dg);
N.register(pg);
N.register(fg);
N.register(mg);
N.register(gg);
N.register(hg);
N.register(bg);
N.register(Eg);
N.register(yg);
N.register(Tg);
N.register(Sg);
N.register(_g);
N.register(Ag);
N.register(Ng);
N.register(Rg);
N.register(vg);
N.register(Cg);
N.register(wg);
N.register(kg);
N.register(Ig);
N.register(Og);
N.register(xg);
N.register(Lg);
N.register(Dg);
N.register(Mg);
N.register(po);
N.register(Ug);
N.register(Bg);
N.register(Fg);
N.register(Pg);
N.register(Hg);
N.register(zg);
N.register(fo);
N.register(Gg);
N.register(jg);
N.register($g);
N.register(qg);
N.register(Yg);
N.register(Vg);
N.register(Wg);
N.register(Xg);
N.register(Kg);
N.register(Zg);
N.register(Qg);
N.register(ki);
N.register(Ii);
N.register(Oi);
N.register(Jg);
N.register(eh);
N.register(th);
N.register(nh);
N.register(ah);
N.register(rh);
N.register(ih);
N.register(mo);
N.register(sh);
N.register(oh);
N.register(lh);
N.register(uh);
N.register(ch);
N.register(dh);
N.register(ph);
N.register(fh);
N.register(mh);
N.register(gh);
N.register(hh);
N.register(bh);
N.register(Eh);
N.register(yh);
N.register(go);
N.register(Th);
N.register(Sh);
N.register(_h);
N.register(Ah);
N.register(Nh);
N.register(Rh);
N.register(vh);
N.register(Ch);
N.register(wh);
N.register(vu);
N.register(kh);
N.register(Ih);
N.register(Oh);
N.register(xh);
N.register(Lh);
N.register(Dh);
N.register(Mh);
N.register(Uh);
N.register(Bh);
N.register(Fh);
N.register(Ph);
N.register(Hh);
N.register(zh);
N.register(Gh);
N.register(jh);
N.register($h);
N.register(qh);
N.register(Yh);
N.register(Vh);
N.register(Wh);
N.register(Xh);
N.register(Kh);
N.register(Zh);
N.register(Qh);
N.register(Jh);
N.register(eb);
N.register(tb);
N.register(nb);
N.register(ab);
N.register(rb);
N.register(ib);
N.register(sb);
N.register(ob);
N.register(lb);
N.register(ub);
N.register(cb);
N.register(db);
N.register(pb);
N.register(fb);
N.register(mb);
N.register(gb);
N.register(hb);
N.register(bb);
N.register(Eb);
N.register(yb);
N.register(Tb);
N.register(Sb);
N.register(_b);
N.register(Ab);
N.register(Nb);
N.register(Rb);
N.register(Cu);
N.register(vb);
N.register(Cb);
N.register(wb);
N.register(kb);
N.register(Ib);
N.register(Ob);
N.register(xb);
N.register(wu);
N.register(Lb);
N.register(Db);
N.register(Mb);
N.register(Ub);
N.register(Bb);
N.register(Fb);
N.register(Pb);
N.register(Hb);
N.register(zb);
N.register(Gb);
N.register(jb);
N.register($b);
N.register(qb);
N.register(Yb);
N.register(Vb);
N.register(Wb);
N.register(Xb);
N.register(Kb);
N.register(Zb);
N.register(Qb);
N.register(ku);
N.register(Jb);
N.register(eE);
N.register(tE);
N.register(nE);
N.register(aE);
N.register(rE);
N.register(iE);
N.register(sE);
N.register(oE);
N.register(lE);
N.register(ho);
N.register(uE);
N.register(Iu);
N.register(cE);
N.register(dE);
N.register(pE);
N.register(fE);
N.register(mE);
N.register(gE);
N.register(hE);
N.register(bE);
N.register(EE);
N.register(yE);
N.register(TE);
N.register(SE);
N.register(_E);
N.register(AE);
N.register(NE);
N.register(RE);
N.register(vE);
N.register(CE);
N.register(wE);
N.register(kE);
N.register(IE);
N.register(OE);
N.register(xE);
N.register(LE);
N.register(DE);
N.register(ME);
N.register(UE);
N.register(BE);
N.register(FE);
var sR = O4(N, Z4);
sR.supportedLanguages = x4;
const Q4 = {
  'code[class*="language-"]': {
    background: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    background: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  'code[class*="language-"]::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"] *::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'pre[class*="language-"] *::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"]::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"] *::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'pre[class*="language-"] *::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: "0.2em 0.3em",
    borderRadius: "0.3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(220, 10%, 40%)"
  },
  cdata: {
    color: "hsl(220, 10%, 40%)"
  },
  doctype: {
    color: "hsl(220, 14%, 71%)"
  },
  punctuation: {
    color: "hsl(220, 14%, 71%)"
  },
  entity: {
    color: "hsl(220, 14%, 71%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(29, 54%, 61%)"
  },
  "class-name": {
    color: "hsl(29, 54%, 61%)"
  },
  boolean: {
    color: "hsl(29, 54%, 61%)"
  },
  constant: {
    color: "hsl(29, 54%, 61%)"
  },
  number: {
    color: "hsl(29, 54%, 61%)"
  },
  atrule: {
    color: "hsl(29, 54%, 61%)"
  },
  keyword: {
    color: "hsl(286, 60%, 67%)"
  },
  property: {
    color: "hsl(355, 65%, 65%)"
  },
  tag: {
    color: "hsl(355, 65%, 65%)"
  },
  symbol: {
    color: "hsl(355, 65%, 65%)"
  },
  deleted: {
    color: "hsl(355, 65%, 65%)"
  },
  important: {
    color: "hsl(355, 65%, 65%)"
  },
  selector: {
    color: "hsl(95, 38%, 62%)"
  },
  string: {
    color: "hsl(95, 38%, 62%)"
  },
  char: {
    color: "hsl(95, 38%, 62%)"
  },
  builtin: {
    color: "hsl(95, 38%, 62%)"
  },
  inserted: {
    color: "hsl(95, 38%, 62%)"
  },
  regex: {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value": {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(95, 38%, 62%)"
  },
  variable: {
    color: "hsl(207, 82%, 66%)"
  },
  operator: {
    color: "hsl(207, 82%, 66%)"
  },
  function: {
    color: "hsl(207, 82%, 66%)"
  },
  url: {
    color: "hsl(187, 47%, 55%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(220, 14%, 71%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-css .token.selector": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-css .token.property": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-css .token.function": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.function": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.string.url": {
    color: "hsl(95, 38%, 62%)"
  },
  ".language-css .token.important": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-css .token.atrule .token.rule": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.operator": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    color: "hsl(5, 48%, 51%)"
  },
  ".language-json .token.operator": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-json .token.null.keyword": {
    color: "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.url": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.operator": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.content": {
    color: "hsl(207, 82%, 66%)"
  },
  ".language-markdown .token.url > .token.url": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.url-reference.url": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.code-snippet": {
    color: "hsl(95, 38%, 62%)"
  },
  ".language-markdown .token.bold .token.content": {
    color: "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.italic .token.content": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-markdown .token.strike .token.content": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.list.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    Opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.cr:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.lf:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.space:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    marginRight: "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  ".line-highlight.line-highlight": {
    background: "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-highlight.line-highlight:before": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 14%, 71%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 14%, 71%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    backgroundColor: "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    borderRightColor: "hsla(220, 14%, 71%, 0.15)"
  },
  ".command-line .command-line-prompt": {
    borderRightColor: "hsla(220, 14%, 71%, 0.15)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    color: "hsl(220, 14%, 45%)"
  },
  ".command-line .command-line-prompt > span:before": {
    color: "hsl(220, 14%, 45%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    color: "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    color: "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    color: "hsl(286, 60%, 67%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    borderColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    borderColor: "hsl(224, 13%, 17%)",
    borderRadius: "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    borderTopColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    borderBottomColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    stroke: "hsl(220, 14%, 71%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    stroke: "hsl(220, 14%, 71%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    stroke: "hsl(220, 14%, 71%)",
    fill: "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    stroke: "hsl(220, 14%, 71%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    stroke: "hsl(220, 14%, 71%)"
  }
};
function J4({ content: e, className: t = "", darkMode: a = !1 }) {
  if (!e) return null;
  const i = a ? {
    text: "text-gray-200",
    heading: "text-white",
    border: "border-gray-600",
    codeBg: "bg-gray-800",
    codeText: "text-pink-400",
    link: "text-blue-400 hover:text-blue-300",
    blockquoteBorder: "border-gray-500",
    blockquoteText: "text-gray-400",
    tableBorder: "border-gray-600",
    tableHeaderBg: "bg-gray-800"
  } : {
    text: "text-gray-800",
    heading: "text-appverse-black",
    border: "border-appverse-gray",
    codeBg: "bg-gray-100",
    codeText: "text-appverse-red",
    link: "text-appverse-blue hover:text-appverse-red",
    blockquoteBorder: "border-appverse-gray",
    blockquoteText: "text-gray-600",
    tableBorder: "border-appverse-gray",
    tableHeaderBg: "bg-gray-100"
  };
  return /* @__PURE__ */ B.jsx("div", { className: `prose prose-sm max-w-none ${a ? "prose-invert" : ""} ${t}`, children: /* @__PURE__ */ B.jsx(
    wL,
    {
      remarkPlugins: [z3],
      rehypePlugins: [QU, [l4, af]],
      components: {
        // Custom code block rendering with syntax highlighting
        code({ node: o, inline: l, className: c, children: d, ...m }) {
          const f = /language-(\w+)/.exec(c || ""), b = f ? f[1] : "";
          return l ? /* @__PURE__ */ B.jsx(
            "code",
            {
              className: `px-1.5 py-0.5 ${i.codeBg} ${i.codeText} rounded text-sm font-mono`,
              ...m,
              children: d
            }
          ) : /* @__PURE__ */ B.jsx(
            sR,
            {
              style: Q4,
              language: b || "text",
              PreTag: "div",
              className: "rounded-appverse text-sm",
              ...m,
              children: String(d).replace(/\n$/, "")
            }
          );
        },
        // Style links
        a({ node: o, children: l, href: c, ...d }) {
          return /* @__PURE__ */ B.jsx(
            "a",
            {
              href: c,
              target: "_blank",
              rel: "noopener noreferrer",
              className: `${i.link} transition-colors`,
              ...d,
              children: l
            }
          );
        },
        // Style images (for badges, etc.)
        img({ node: o, src: l, alt: c, ...d }) {
          return /* @__PURE__ */ B.jsx(
            "img",
            {
              src: l,
              alt: c || "",
              className: "inline-block h-5 my-0",
              ...d
            }
          );
        },
        // Headings
        h1({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("h1", { className: `text-2xl font-bold ${i.heading} border-b ${i.border} pb-2 mb-4`, ...c, children: l });
        },
        h2({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("h2", { className: `text-xl font-bold ${i.heading} border-b ${i.border} pb-2 mb-3 mt-6`, ...c, children: l });
        },
        h3({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("h3", { className: `text-lg font-bold ${i.heading} mb-2 mt-4`, ...c, children: l });
        },
        // Lists
        ul({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("ul", { className: `list-disc list-inside space-y-1 my-3 ${i.text}`, ...c, children: l });
        },
        ol({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("ol", { className: `list-decimal list-inside space-y-1 my-3 ${i.text}`, ...c, children: l });
        },
        li({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("li", { className: i.text, ...c, children: l });
        },
        // Paragraphs
        p({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("p", { className: "my-3 leading-relaxed", ...c, children: l });
        },
        // Blockquotes
        blockquote({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx(
            "blockquote",
            {
              className: `border-l-4 ${i.blockquoteBorder} pl-4 my-4 italic ${i.blockquoteText}`,
              ...c,
              children: l
            }
          );
        },
        // Tables (GFM)
        table({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("div", { className: "overflow-x-auto my-4", children: /* @__PURE__ */ B.jsx("table", { className: `min-w-full border ${i.tableBorder}`, ...c, children: l }) });
        },
        th({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("th", { className: `border ${i.tableBorder} px-3 py-2 ${i.tableHeaderBg} text-left font-semibold`, ...c, children: l });
        },
        td({ node: o, children: l, ...c }) {
          return /* @__PURE__ */ B.jsx("td", { className: `border ${i.tableBorder} px-3 py-2`, ...c, children: l });
        }
      },
      children: e
    }
  ) });
}
function EA({ appId: e, nid: t, compact: a = !1, className: i = "" }) {
  const { authenticated: o, loading: l, isFlagged: c, isPending: d, toggleFlag: m, siteBaseUrl: f } = jA(), b = Er(), E = o ? c(e) : !1, T = o ? d(e) : !1, S = (_) => {
    if (_.preventDefault(), _.stopPropagation(), !o) {
      const k = window.location.pathname + window.location.hash, R = `${f}/user/login?redirect=${encodeURIComponent(k)}`;
      window.location.href = R;
      return;
    }
    b("flag_app", { app_id: e, action: E ? "unflag" : "flag" }), m(e, t);
  };
  return /* @__PURE__ */ B.jsxs(
    "button",
    {
      onClick: S,
      disabled: l || T,
      className: `inline-flex items-center gap-2 text-appverse-black hover:text-gray-600
        transition-colors font-sans font-semibold text-sm whitespace-nowrap
        focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed ${i}`,
      "aria-label": o ? E ? "Remove from my apps" : "We use this App" : "Login to say you use this app",
      title: o ? E ? "Remove from my apps" : "We use this App" : "Login to say you use this app",
      children: [
        /* @__PURE__ */ B.jsx("span", { className: `grid place-items-center w-5 h-5 rounded transition-colors ${E ? "bg-appverse-green" : "bg-appverse-red"}`, children: T ? (
          // Loading spinner
          /* @__PURE__ */ B.jsx("span", { className: "w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" })
        ) : E ? /* @__PURE__ */ B.jsx(QA, { className: "w-3 h-3 text-white" }) : /* @__PURE__ */ B.jsx(e1, { className: "w-3.5 h-3.5 text-white", style: { stroke: "white", strokeWidth: 1 } }) }),
        !a && (E ? "FLAGGED" : "FLAG APP")
      ]
    }
  );
}
function eB({ app: e, isExpanded: t, onToggle: a }) {
  var G, K, Q, U, ee, ae, ue, de, ce;
  const { getFlagCountAdjustment: i } = jA(), o = Er(), l = ((G = e.attributes) == null ? void 0 : G.title) || "Untitled App", c = (Q = (K = e.attributes) == null ? void 0 : K.field_appverse_github_url) == null ? void 0 : Q.uri, d = (ee = (U = e.attributes) == null ? void 0 : U.field_appverse_readme) == null ? void 0 : ee.value, m = (ae = e.attributes) == null ? void 0 : ae.field_appverse_lastupdated, b = (((ue = e.attributes) == null ? void 0 : ue.flag_count) || 0) + i(e.id), E = ((de = e.attributes) == null ? void 0 : de.field_appverse_stars) ?? 0, T = e.organization, S = e.tags || [], _ = e.id, k = (ce = e.attributes) == null ? void 0 : ce.drupal_internal__nid, R = z.useRef(null), [C, L] = z.useState(0);
  z.useEffect(() => {
    if (t && R.current) {
      const j = R.current.scrollHeight;
      L(Math.min(j, 350));
    } else
      L(0);
  }, [t, d]);
  const x = m ? new Date(m * 1e3).toLocaleDateString("en-US", {
    year: "2-digit",
    month: "numeric",
    day: "numeric"
  }) : null, Y = () => c && /* @__PURE__ */ B.jsxs(
    "a",
    {
      href: c,
      target: "_blank",
      rel: "noopener noreferrer",
      onClick: () => o("view_repo", { app_title: l, github_url: c }),
      className: "inline-flex items-center gap-2 text-appverse-black visited:text-appverse-black hover:text-gray-600 transition-colors font-sans font-semibold text-sm whitespace-nowrap",
      children: [
        /* @__PURE__ */ B.jsx("span", { className: "grid place-items-center w-5 h-5 rounded-full bg-appverse-red", children: /* @__PURE__ */ B.jsx(Zl, { className: "w-3.5 h-3 text-white", style: { stroke: "white", strokeWidth: 1, transform: "translateX(0.5px)" } }) }),
        "VIEW REPO"
      ]
    }
  ), q = ({ className: j = "" }) => d && /* @__PURE__ */ B.jsxs(
    "button",
    {
      onClick: () => {
        o("readme_toggle", { app_title: l, action: t ? "collapse" : "expand" }), a();
      },
      className: `inline-flex items-center gap-2 text-appverse-black hover:text-gray-600 transition-colors font-sans font-semibold text-sm whitespace-nowrap focus:outline-none ${j}`,
      children: [
        /* @__PURE__ */ B.jsx(
          "span",
          {
            className: `grid place-items-center w-5 h-5 rounded-full bg-appverse-red transition-transform duration-200 ${t ? "rotate-90" : ""}`,
            children: /* @__PURE__ */ B.jsx(Zl, { className: "w-3.5 h-3 text-white", style: { stroke: "white", strokeWidth: 1, transform: "translateX(0.5px)" } })
          }
        ),
        t ? "HIDE README" : "SHOW README"
      ]
    }
  ), D = () => S.length > 0 && /* @__PURE__ */ B.jsx("div", { className: "flex flex-wrap gap-2", children: S.map((j) => /* @__PURE__ */ B.jsx(
    "span",
    {
      className: "px-2.5 py-1 text-xs font-sans text-appverse-black bg-appverse-gray rounded",
      children: j.name
    },
    j.id
  )) });
  return /* @__PURE__ */ B.jsxs("div", { className: "border border-appverse-gray rounded-appverse overflow-hidden bg-white", children: [
    /* @__PURE__ */ B.jsxs("div", { className: "!p-5", children: [
      /* @__PURE__ */ B.jsxs("div", { className: "hidden md:flex md:gap-6", children: [
        /* @__PURE__ */ B.jsxs("div", { className: "flex-1 min-w-0 flex flex-col", children: [
          /* @__PURE__ */ B.jsx("h3", { className: "text-xl font-sans font-bold text-appverse-black mb-1", children: l }),
          T && /* @__PURE__ */ B.jsx("p", { className: "text-sm font-sans text-appverse-black", children: T.name }),
          /* @__PURE__ */ B.jsx("div", { className: "mt-auto pt-3", children: /* @__PURE__ */ B.jsx(q, {}) })
        ] }),
        /* @__PURE__ */ B.jsx("div", { className: "w-[180px] flex-shrink-0", children: /* @__PURE__ */ B.jsx(D, {}) }),
        /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col gap-2 flex-shrink-0 items-start", children: [
          /* @__PURE__ */ B.jsx(Y, {}),
          /* @__PURE__ */ B.jsxs("div", { className: "bg-appverse-gray/30 rounded px-3 py-2 text-sm font-sans text-appverse-black min-w-[160px]", children: [
            /* @__PURE__ */ B.jsxs("p", { className: "flex items-center gap-1", children: [
              /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: E }),
              " ",
              /* @__PURE__ */ B.jsx(Ql, { className: "w-3 h-3" }),
              " on GitHub"
            ] }),
            /* @__PURE__ */ B.jsxs("p", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ B.jsxs("span", { children: [
                /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: b }),
                " reported usages"
              ] }),
              k && /* @__PURE__ */ B.jsx(EA, { appId: _, nid: k, compact: !0 })
            ] }),
            x && /* @__PURE__ */ B.jsxs("p", { children: [
              /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: x }),
              " last commit"
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ B.jsx("div", { className: "md:hidden", children: /* @__PURE__ */ B.jsxs("div", { className: "flex gap-4 items-start", children: [
        /* @__PURE__ */ B.jsxs("div", { className: "flex-1 min-w-0", children: [
          /* @__PURE__ */ B.jsx("h3", { className: "text-xl font-sans font-bold text-appverse-black mb-1", children: l }),
          T && /* @__PURE__ */ B.jsx("p", { className: "text-sm font-sans text-appverse-black mb-2", children: T.name }),
          S.length > 0 && /* @__PURE__ */ B.jsx("div", { className: "mb-3", children: /* @__PURE__ */ B.jsx(D, {}) }),
          /* @__PURE__ */ B.jsxs("div", { className: "flex flex-row flex-wrap gap-4", children: [
            /* @__PURE__ */ B.jsx(Y, {}),
            /* @__PURE__ */ B.jsx(q, {})
          ] })
        ] }),
        /* @__PURE__ */ B.jsxs("div", { className: "bg-appverse-gray/30 rounded px-3 py-2 text-sm font-sans text-appverse-black min-w-[160px] w-fit flex-shrink-0", children: [
          /* @__PURE__ */ B.jsxs("p", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: E }),
            " ",
            /* @__PURE__ */ B.jsx(Ql, { className: "w-3 h-3" }),
            " on GitHub"
          ] }),
          /* @__PURE__ */ B.jsxs("p", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ B.jsxs("span", { children: [
              /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: b }),
              " reported usages"
            ] }),
            k && /* @__PURE__ */ B.jsx(EA, { appId: _, nid: k, compact: !0 })
          ] }),
          x && /* @__PURE__ */ B.jsxs("p", { children: [
            /* @__PURE__ */ B.jsx("span", { className: "font-bold", children: x }),
            " last commit"
          ] })
        ] })
      ] }) })
    ] }),
    d && /* @__PURE__ */ B.jsx(
      "div",
      {
        className: "overflow-hidden transition-[max-height] duration-300 ease-in-out",
        style: { maxHeight: t ? `${C}px` : "0px" },
        children: /* @__PURE__ */ B.jsx(
          "div",
          {
            ref: R,
            className: "border-t border-gray-700 !p-5 bg-[#1e1e1e] max-h-[350px] overflow-y-auto",
            children: /* @__PURE__ */ B.jsx(J4, { content: d, className: "font-sans", darkMode: !0 })
          }
        )
      }
    )
  ] });
}
function tB({ apps: e, expandedAppId: t, onToggleApp: a }) {
  return !e || e.length === 0 ? /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center justify-center py-16", children: [
    /* @__PURE__ */ B.jsx("div", { className: "w-20 h-20 rounded-full bg-appverse-gray flex items-center justify-center mb-4", children: /* @__PURE__ */ B.jsx(ZA, { className: "w-10 h-10 text-gray-400" }) }),
    /* @__PURE__ */ B.jsx("h3", { className: "text-xl font-serif font-bold text-appverse-black mb-2", children: "No Apps Found" }),
    /* @__PURE__ */ B.jsx("p", { className: "text-gray-600 font-sans text-center max-w-md", children: "There are no applications implementing this software yet." })
  ] }) : /* @__PURE__ */ B.jsx("div", { className: "space-y-4", children: e.map((i) => /* @__PURE__ */ B.jsx(
    eB,
    {
      app: i,
      isExpanded: t === i.id,
      onToggle: () => a(i.id)
    },
    i.id
  )) });
}
function yA(e) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(e);
}
function nB() {
  const { slug: e } = CA(), [t, a] = UA(), i = uu(), { getSoftwareBySlug: o, loading: l } = $A(), c = Er(), [d, m] = z.useState(null), [f, b] = z.useState([]), [E, T] = z.useState(!0), [S, _] = z.useState(null), k = t.get("app"), R = e && !yA(e);
  z.useEffect(() => {
    async function G() {
      T(!0), _(null);
      try {
        let K = e, Q = null;
        if (R) {
          if (l) return;
          const ee = o(e);
          if (!ee) {
            m(null), b([]), T(!1);
            return;
          }
          K = ee.id, Q = await ep(K, i);
        } else
          Q = await ep(K, i);
        const U = await ZS(K, i);
        m(Q), b(U);
      } catch (K) {
        console.error("Failed to fetch software detail:", K), _(K);
      } finally {
        T(!1);
      }
    }
    e && G();
  }, [e, R, l, o, i]);
  const C = z.useRef(null);
  z.useEffect(() => {
    var G;
    d != null && d.id && !E && C.current !== d.id && (C.current = d.id, c("software_detail_view", {
      software_title: (G = d.attributes) == null ? void 0 : G.title,
      software_slug: e,
      app_count: f.length
    }));
  }, [d, f.length, E, e, c]);
  const { appSlugToId: L, appIdToSlug: x } = z.useMemo(() => {
    var Q, U;
    const G = {}, K = {};
    for (const ee of f) {
      const ae = ((Q = ee.attributes) == null ? void 0 : Q.title) || "", ue = ((U = ee.organization) == null ? void 0 : U.name) || "", de = ue ? `${Us(ue)}--${Us(ae)}` : Us(ae);
      G[de] = ee.id, K[ee.id] = de;
    }
    return { appSlugToId: G, appIdToSlug: K };
  }, [f]), Y = z.useMemo(() => k ? yA(k) ? k : L[k] || null : null, [k, L]), q = (G) => {
    const K = new URLSearchParams(t), Q = x[G];
    Y === G ? K.delete("app") : K.set("app", Q || G), a(K);
  }, D = () => {
    m(null), b([]), T(!0), _(null);
    let G = e;
    if (R) {
      const K = o(e);
      if (!K) {
        _(new Error("Software not found")), T(!1);
        return;
      }
      G = K.id;
    }
    ep(G, i).then((K) => m(K)).catch((K) => _(K)).finally(() => T(!1)), ZS(G, i).then((K) => b(K)).catch((K) => console.error("Failed to fetch apps:", K));
  };
  return E || R && l ? /* @__PURE__ */ B.jsx(SI, { message: "Loading software details..." }) : S ? /* @__PURE__ */ B.jsx(n1, { error: S, onRetry: D }) : d ? /* @__PURE__ */ B.jsx("div", { className: "mb-4 bg-white", children: /* @__PURE__ */ B.jsxs("div", { className: "px-6 py-8", children: [
    /* @__PURE__ */ B.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
      /* @__PURE__ */ B.jsxs(
        to,
        {
          to: "/",
          className: "inline-flex items-center gap-1.5 text-appverse-black hover:text-appverse-red transition-colors",
          children: [
            /* @__PURE__ */ B.jsx(
              "svg",
              {
                className: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ B.jsx(
                  "path",
                  {
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    strokeWidth: 2,
                    d: "M15 19l-7-7 7-7"
                  }
                )
              }
            ),
            "Back to Software"
          ]
        }
      ),
      /* @__PURE__ */ B.jsx(
        "a",
        {
          href: "/node/add/appverse_app",
          className: "py-3 px-6 bg-appverse-red text-white font-sans font-semibold rounded-appverse hover:bg-red-700 transition-colors",
          children: "Add an app"
        }
      )
    ] }),
    /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col lg:flex-row gap-8 lg:gap-12", children: [
      /* @__PURE__ */ B.jsx("div", { className: "w-full lg:w-[280px] lg:flex-shrink-0", children: /* @__PURE__ */ B.jsx(_I, { software: d }) }),
      /* @__PURE__ */ B.jsx("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ B.jsx(
        tB,
        {
          apps: f,
          expandedAppId: Y,
          onToggleApp: q
        }
      ) })
    ] })
  ] }) }) : /* @__PURE__ */ B.jsxs("div", { className: "flex flex-col items-center justify-center min-h-[400px] py-12 px-4", children: [
    /* @__PURE__ */ B.jsx("h2", { className: "text-2xl font-serif text-appverse-black mb-2", children: "Software Not Found" }),
    /* @__PURE__ */ B.jsx("p", { className: "text-appverse-black text-center max-w-md", children: "The software you're looking for doesn't exist or has been removed." })
  ] });
}
function aB() {
  const { "*": e } = CA(), t = Ln(), a = `/${e || ""}${t.search}`;
  return /* @__PURE__ */ B.jsx(IA, { to: a, replace: !0 });
}
function rB() {
  return Ek(), /* @__PURE__ */ B.jsx(uk, { children: /* @__PURE__ */ B.jsx(gk, { children: /* @__PURE__ */ B.jsx("div", { className: "appverse-container", children: /* @__PURE__ */ B.jsx("main", { children: /* @__PURE__ */ B.jsxs(_w, { children: [
    /* @__PURE__ */ B.jsx(Ds, { path: "/", element: /* @__PURE__ */ B.jsx(TI, {}) }),
    /* @__PURE__ */ B.jsx(Ds, { path: "/:slug", element: /* @__PURE__ */ B.jsx(nB, {}) }),
    /* @__PURE__ */ B.jsx(Ds, { path: "/appverse/*", element: /* @__PURE__ */ B.jsx(aB, {}) }),
    /* @__PURE__ */ B.jsx(Ds, { path: "*", element: /* @__PURE__ */ B.jsx(IA, { to: "/", replace: !0 }) })
  ] }) }) }) }) });
}
function iB(e, t = {}) {
  const a = document.getElementById(e);
  if (!a)
    return console.error(`AppVerse: Element with id "${e}" not found`), null;
  const i = IC.createRoot(a);
  return i.render(
    /* @__PURE__ */ B.jsx(Yw, { children: /* @__PURE__ */ B.jsx(lk, { config: t, children: /* @__PURE__ */ B.jsx(rB, {}) }) })
  ), {
    unmount: () => {
      i.unmount();
    }
  };
}
export {
  rB as AppVerseBrowser,
  iB as default,
  iB as mount
};
//# sourceMappingURL=appverse.es.js.map
